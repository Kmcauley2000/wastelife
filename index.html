<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wastelife: A Post-Apocalyptic Life Sim</title>
<style>
:root {
  /* Dusty Texas palette */
  --bg:#1a1512;          /* mesquite night */
  --panel:#1f1a16;       /* oiled leather */
  --accent:#e38f2b;      /* mesquite ember */
  --accent-dim:#995c1a;  /* aged brass */
  --danger:#c6453a;      /* rust red */
  --warn:#f2c14e;        /* sun-glare amber */
  --ok:#79b37b;          /* scrub green */
  --text:#f3e9d2;        /* parchment */
  --muted:#c9b8a6;       /* dusty khaki */
  --shadow:0 10px 24px rgba(0,0,0,.35), inset 0 0 0 1px rgba(227,143,43,.14);
  --radius:14px;
  --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  --sans:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
}

/* let page grow, always fill background */
html,body{min-height:100%}

body {
  margin:0;
  background:
    radial-gradient(1200px 800px at 30% -10%, #3b2b21 0%, var(--bg) 52%) no-repeat,
    radial-gradient(900px 700px at 110% 120%, #2a211b 0%, transparent 60%) no-repeat,
    linear-gradient(180deg, #1b1714, #16120f);
  background-attachment:fixed;
  background-color:var(--bg);
  font-family:var(--sans);
  color:var(--text);
  line-height:1.4;
}

/* ======== ORIGINAL LAYOUT (unchanged) ======== */
.wrap{max-width:1200px;margin:32px auto;padding:0 16px;}
header{display:grid;gap:12px;grid-template-columns:1fr;margin-bottom:16px;}
.topbar{display:grid;gap:12px;grid-template-columns:1.1fr 1fr;}
@media(max-width:1000px){.topbar{grid-template-columns:1fr}}
.grid{display:grid;gap:12px;grid-template-columns:330px 1fr;}
@media(max-width:1000px){.grid{grid-template-columns:1fr}}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}

/* ======== Theming only (colors), layout preserved ======== */
.card{
  background:linear-gradient(180deg, rgba(227,143,43,.06), rgba(0,0,0,.08));
  border:1px solid rgba(227,143,43,.28);
  box-shadow:var(--shadow);
  border-radius:var(--radius);
  padding:14px;
}
.title{
  font-family:var(--mono);
  color:var(--accent);
  letter-spacing:.5px;
  display:flex;align-items:center;gap:10px;
  font-size:18px;margin:0 0 6px;
  text-shadow:0 1px 0 rgba(0,0,0,.35);
}
.pill{
  border:1px solid rgba(227,143,43,.35);
  padding:6px 10px;border-radius:999px;
  font-family:var(--mono);
  background:linear-gradient(180deg, rgba(227,143,43,.08), rgba(0,0,0,.25));
}
.stat{margin:8px 0}
.stat-label{display:flex;justify-content:space-between;font-size:12px;color:var(--muted);font-family:var(--mono)}
.bar{height:12px;border-radius:8px;background:rgba(227,143,43,.12);overflow:hidden;border:1px solid rgba(227,143,43,.32)}
.bar>i{display:block;height:100%;background:var(--accent);box-shadow:inset 0 0 12px rgba(0,0,0,.4)}
.bar.warn>i{background:var(--warn)}
.bar.danger>i{background:var(--danger)}

.actions{display:grid;gap:8px}
.actions button{
  all:unset;cursor:pointer;padding:10px 12px;border-radius:10px;
  border:1px solid rgba(227,143,43,.35);
  background:linear-gradient(180deg, rgba(227,143,43,.10), rgba(0,0,0,.25));
  font-family:var(--mono);color:var(--text)
}
.actions button:hover{border-color:var(--accent)}
.actions .group{display:grid;gap:8px}

.log{height:540px;overflow:auto;padding-right:6px}
.entry{
  padding:10px 12px;border-left:3px solid rgba(227,143,43,.35);
  background:rgba(0,0,0,.22);border-radius:10px;margin:8px 0
}
.entry p{margin:0}
.choices{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
.choice{all:unset;cursor:pointer;padding:8px 10px;border-radius:8px;border:1px solid rgba(227,143,43,.35);font-family:var(--mono)}
.choice:hover{border-color:var(--accent)}

.muted{color:var(--muted)}
.hr{height:1px;background:rgba(227,143,43,.28);margin:10px 0}
footer{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
.linklike{all:unset;cursor:pointer;color:var(--accent);font-family:var(--mono)}
.dangerous{color:var(--danger)}
.center{text-align:center}

.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;place-items:center;z-index:10;}
.modal{width:min(880px,92vw);max-height:80vh;overflow:auto}
.modal .title{
  position:sticky;top:0;
  background:linear-gradient(180deg, rgba(26,21,18,1), rgba(26,21,18,.86));
  padding:14px;border-bottom:1px solid rgba(227,143,43,.28);z-index:1
}
.kv{display:grid;grid-template-columns:160px 1fr;gap:8px;margin:10px 0;font-family:var(--mono)}
.small{font-size:12px}
.hidden{display:none!important}

/* faction pill theming (slugged) */
#faction-pill-wrapper{cursor:pointer;transition:background .2s,color .2s;}
.faction-settlers{background:#efe6d4;color:#4b3a20;}          /* adobe tan */
.faction-rangers{background:#d9e8e0;color:#204535;}           /* ranger green */
.faction-scribes{background:#e8e1f2;color:#352a55;}           /* archivist violet */
.faction-dust_marauders{background:#f0e0cc;color:#5a2b14;}    /* dusty leather */
.faction-none{background:#ddd;color:#333;}

/* ── Faction Menu Enhancements (colors only) ───────────────── */
.faction-header {
  padding: 14px;
  border-radius: var(--radius);
  margin-bottom: 12px;
  background: rgba(0,0,0,.3);
  border: 1px solid rgba(227,143,43,.35);
}
.faction-header.settlers       { border-color:#c48b40; }
.faction-header.rangers        { border-color:#3a8f6b; }
.faction-header.scribes        { border-color:#8a78c4; }
.faction-header.dust_marauders { border-color:#e38f2b; } /* fixed slug */

.rep-bar {
  height: 12px;
  border-radius: 8px;
  background: rgba(227,143,43,.12);
  border: 1px solid rgba(227,143,43,.32);
  overflow: hidden;
  margin: 4px 0;
}
.rep-bar > i { display:block; height:100%; background:var(--accent); }

.faction-action {
  background: rgba(0,0,0,.2);
  border: 1px solid rgba(227,143,43,.28);
  border-radius: var(--radius);
  padding: 10px;
  margin: 8px 0;
}
.faction-action .label {
  font-family: var(--mono);
  color: var(--accent);
  margin-bottom: 6px;
}

/* Solid background for modals only */
.modal.card { background: var(--panel); }
</style>
</head>
<body>
<div class="wrap">
  <header class="card">
    <h1 class="title">WASTELIFE ▸ <span id="header-status" class="muted">new run</span></h1>
    <div class="topbar">
      <div class="card">
        <div class="row">
          <div class="pill">Name: <b id="name">—</b></div>
<!-- Stat pills row -->
<div class="pills">
  <div class="pill">Age: <b id="age">18</b></div>
  <div class="pill">HP: <b id="hp">100/100</b></div>
  <div class="pill">Caps: <b id="caps">0</b></div>
  <div class="pill">Karma: <b id="karma">0</b></div>
  <div class="pill">Level: <b id="level">1</b> (<span id="xp">0</span> XP)</div>
  <div class="pill">RAD: <b id="rad">0</b></div>
  <!-- Unified clickable Faction pill -->
  <div class="pill" id="faction-pill-wrapper">
    Faction: <b id="faction-pill">Unaffiliated</b>
  </div>
</div>

        <div id="special" class="row" style="margin-top:8px; flex-wrap:wrap"></div>
      </div>
      <div class="card">
        <div class="row">
          <div class="pill">Origin: <b id="origin">—</b></div>
          <div class="pill">Job: <b id="job">—</b></div>
          <div class="pill">Location: <b id="location">—</b></div>
          <div class="pill">Year: <b id="year">2165</b></div>
        </div>
        <div class="hr"></div>
        <div class="row small">
          <span class="muted">Tip: Hit “Age Up” yearly. Choices affect S.P.E.C.I.A.L., caps, karma, and survival.</span>
        </div>
      </div>
    </div>
  </header>

  <main class="grid">
    <aside class="card">
      <div class="title">Actions</div>
      <div class="actions">
        <div class="group">
          <button id="btn-age">▸ Age Up (1 year)</button>
          <button id="btn-explore">Explore the Wasteland</button>
          <button id="btn-work">Work / Scavenge</button>
          <button id="btn-heal">Treat Wounds / AntiRad (Cost: 12 Caps)</button>
        </div>
        <div class="hr"></div>
        <div class="group">		
		<button id="btn-inventory">Inventory</button>
		<button id="btn-trade">Visit Trader</button>
		<button id="btn-join-faction">Join a Faction</button>
		<button id="btn-perks">Perks</button>
        </div>
        <div class="hr"></div>
        <div class="group">
          <button id="btn-save">Save</button>
          <button id="btn-load">Load</button>
          <button id="btn-reset" class="dangerous">New Run</button>
        </div>
      </div>
    </aside>

    <section class="card">
      <div class="title">Life Log</div>
      <div id="log" class="log"></div>
      <footer>
        <span class="muted small">Wastelife is an original, fan-made life sim. Survive, thrive, and make choices. No two runs are the same.</span>
      </footer>
    </section>
  </main>
</div>

<!-- Modals -->
<div id="modal-backdrop" class="modal-backdrop">
  <div class="card modal" role="dialog" aria-modal="true">
    <h2 class="title" id="modal-title">Modal</h2>
    <div id="modal-content"></div>
    <div class="hr"></div>
    <div class="row" style="padding:0 14px 14px">
      <button class="linklike" id="modal-close">Close</button>
    </div>
  </div>
</div>

<script>

// ========= Utility =========
// NOTE: These helpers ( $, el, rnd, sample, clamp ) are general-purpose.
// Add new helper functions here if you want them available everywhere.

const $ = sel => document.querySelector(sel);
const el = (t, cls, txt) => {
  const n = document.createElement(t);
  if (cls) n.className = cls;
  if (txt != null) n.textContent = txt;
  return n;
};
const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const sample = arr => arr[Math.floor(Math.random()*arr.length)];
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));


// Common reward applier
function grantBattleRewards(rew){
  let cap = rew.caps || 0, xp = rew.xp || 0;
  if (state.perks.includes("scrounger")) cap = Math.round(cap * 1.15);
  if (cap) { state.caps += cap; }
  if (xp)  { gainXP(xp); }
  if (rew.rad) rad(rew.rad);
  if (rew.items){
    for (const [id, q] of Object.entries(rew.items)) addItem(id, q);
  }
}

// Hook to spin up combat with probability; returns true if combat started
function maybeStartCombat(prob=0.3, tier="wastes", source="explore"){
  if (state.buffs?.fleeBoost > 0) prob *= 0.55; // stealth reduces chance
  if (!state.alive) return false;
  if (!chance(prob)) return false;
  const enemy = generateEnemy(tier);
  openCombat(enemy, { source });
  return true;
}



/* ========= Items & Inventory Helpers ========= */
// NOTE: Add new items to ITEMS
// NOTE: Add new crafting recipes to RECIPES

const ITEMS = {
  canteen: { 
    name:"Canteen",
    desc:"Refillable water bottle. Restores a bit of health or reduces radiation.",
    use:()=>{ 
      if(state.rad > 0){ 
        derad(5); 
        log("You sip clean water. RAD -5."); 
      } else { 
        heal(2); 
        log("You sip water. HP +2."); 
      }
      return true; 
    }
  },

 // ==== Ammo (stackable resources) ====
  ammo_38:      { name: ".38 Rounds",       desc:"Pistol cartridges for revolvers." },
  ammo_308:     { name: ".308 Rounds",      desc:"High-power rifle ammunition." },
  shells_12g:   { name: "12g Shells",       desc:"Shotgun shells." },
  carbine_round:{ name: "Carbine Rounds",   desc:"Intermediate carbine cartridges." },
  ammo_9mm:      { name:"9mm Rounds",        desc:"Common pistol/SMG cartridge." },
  ammo_556:      { name:"5.56 Rounds",       desc:"Intermediate rifle cartridge." },
  ammo_762:      { name:"7.62 Rounds",       desc:"Full-power rifle cartridge." },
  ammo_44:       { name:".44 Magnum",        desc:"Big-bore lever/handgun round." },
  energy_cell:   { name:"Energy Cell",       desc:"Standard energy weapon cell." },

//// SETTLER MAIN CAMPAIGN ITEMS /////
    settlers_coat: {
    name:"Union Field Coat",
    desc:"Sturdy Settlers issue. +5 DEF, +1 AGI.",
    slot:"chest", bonus:{ def:5, agi:1 }
  },
  settlers_carbine: {
    name:"Settlers Carbine",
    desc:"Reliable union carbine. +11 ATK, +2% crit.",
    slot:"weapon", bonus:{ atk:11, crit:0.02 },
    ammo:{ id:"carbine_round", perShot:1 }
  },
  diplomats_coat: {
    name:"Diplomat’s Coat",
    desc:"Worn by peacemakers. +4 DEF, +2 AGI.",
    slot:"chest", bonus:{ def:4, agi:2 }
  },

////////////////////////////////////////////////////////

  helmet: { name:"Makeshift Helmet", desc:"Protects your head. +2 defense.", slot:"head", bonus:{def:2} },
  armor:  { name:"Leather Armor",   desc:"Light chest armor. +3 defense.",   slot:"chest", bonus:{def:3} },
  boots:  { name:"Sturdy Boots",    desc:"Protect your legs. +1 defense.",   slot:"legs",  bonus:{def:1} },
  knife:  { name:"Combat Knife",    desc:"Reliable melee weapon. +6 attack.",slot:"weapon",bonus:{atk:6} },

  junk:       { name:"Junk",        desc:"Assorted scrap. Useful for crafting or selling." },
  duct_tape:  { name:"Duct Tape",   desc:"Binds the world together. Often used in crafting." },

  rad_purge: {
    name: "Rad Purge",
    desc: "Flushes radiation from your system. -25 RAD.",
    use:()=>{ derad(25); log("You flush radiation. RAD -25."); return true; }
  },

  rad_shield: {
    name: "Rad Shield",
    desc: "Halves radiation intake for 5 actions.",
    use:()=>{ state.buffs.radShield.turns = Math.max(state.buffs.radShield.turns, 5);
              log("You take Rad Shield. Radiation intake reduced for a while."); return true; }
  },

  battle_tonic: {
    name: "Battle Tonic",
    desc: "Adrenal surge. +4 ATK for the next 3 combats.",
    use:()=>{ state.buffs.atkBoost = Math.max(state.buffs.atkBoost, 3);
              log("You feel a rush of aggression. ATK boosted for a few fights."); return true; }
  },

  bulk_tonic: {
    name: "Bulk Tonic",
    desc: "+2 STR & +2 END for the next 3 actions.",
    use:()=>{ state.buffs.strEnd = Math.max(state.buffs.strEnd, 3);
              log("Your muscles bulge. STR/END up briefly."); return true; }
  },

  focus_pills: {
    name: "Focus Pills",
    desc: "+3 PER & +3 INT for the next 3 actions.",
    use:()=>{ state.buffs.percInt = Math.max(state.buffs.percInt, 3);
              log("Your thoughts sharpen. PER/INT up briefly."); return true; }
  },

  stealth_field: {
    name: "Stealth Field",
    desc: "Cloaks you for 3 actions. Easier to flee; fewer encounters.",
    use:()=>{ state.buffs.fleeBoost = Math.max(state.buffs.fleeBoost, 3);
              log("A shimmer trails your steps. Flee chance up; encounters rarer."); return true; }
  },

/// === FireArms ===
  revolver: {
    name:"Revolver",
    desc:"+8 attack. Slightly better crits.",
    slot:"weapon", bonus:{ atk:8, crit:0.03 },
    ammo:{ id:"ammo_38", perShot:1 }
  },

  hunting_rifle: {
    name:"Hunting Rifle",
    desc:"+10 attack. Keen sights (+5% crit).",
    slot:"weapon", bonus:{ atk:10, crit:0.05 },
    ammo:{ id:"ammo_308", perShot:1 }
  },

  shotgun: {
    name:"Shotgun",
    desc:"+9 attack. Packs a punch at close range.",
    slot:"weapon", bonus:{ atk:9 },
    ammo:{ id:"shells_12g", perShot:1 }
  },

  pipe_pistol: {
    name:"Pipe Pistol",
    desc:"Crude but serviceable. +5 ATK. Uses .38 rounds.",
    slot:"weapon", bonus:{ atk:5 },
    ammo:{ id:"ammo_38", perShot:1 }
  },

  smg_9mm: {
    name:"9mm SMG",
    desc:"Compact spray. +7 ATK, +2% crit. Uses 9mm.",
    slot:"weapon", bonus:{ atk:7, crit:0.02 },
    ammo:{ id:"ammo_9mm", perShot:1 }
  },

  assault_rifle_556: {
    name:"5.56 Assault Rifle",
    desc:"Service rifle. +12 ATK, +1% crit. Uses 5.56.",
    slot:"weapon", bonus:{ atk:12, crit:0.01 },
    ammo:{ id:"ammo_556", perShot:1 }
  },

  battle_rifle_762: {
    name:"7.62 Battle Rifle",
    desc:"Full-power thumper. +13 ATK, +1.5% crit. Uses 7.62.",
    slot:"weapon", bonus:{ atk:13, crit:0.015 },
    ammo:{ id:"ammo_762", perShot:1 }
  },

  marksman_rifle: {
    name:"Marksman Rifle",
    desc:"Scoped precision. +12 ATK, +7% crit. Uses .308.",
    slot:"weapon", bonus:{ atk:12, crit:0.07 },
    ammo:{ id:"ammo_308", perShot:1 }
  },

  lever_action_44: {
    name:"Lever-Action .44",
    desc:"Classic punch. +11 ATK, +4% crit. Uses .44 Magnum.",
    slot:"weapon", bonus:{ atk:11, crit:0.04 },
    ammo:{ id:"ammo_44", perShot:1 }
  },

  machine_pistol_38: {
    name:"Machine Pistol",
    desc:"Snappy sidearm. +6 ATK, +2% crit. Uses .38.",
    slot:"weapon", bonus:{ atk:6, crit:0.02 },
    ammo:{ id:"ammo_38", perShot:1 }
  },

  laser_pistol: {
    name:"Laser Pistol",
    desc:"Clean shots, no drop. +9 ATK, +3% crit. Uses Energy Cells.",
    slot:"weapon", bonus:{ atk:9, crit:0.03 },
    ammo:{ id:"energy_cell", perShot:1 }
  },

  laser_rifle: {
    name:"Laser Rifle",
    desc:"Beam-line precision. +11 ATK, +4% crit. Uses Energy Cells.",
    slot:"weapon", bonus:{ atk:11, crit:0.04 },
    ammo:{ id:"energy_cell", perShot:1 }
  },

  med_patch: { 
    name:"Med Patch", desc:"Heals 15 HP.", 
    use:()=>{ heal(15); log("You apply a Med Patch. HP +15."); return true; }
  },

  antirad: { 
    name:"AntiRad", desc:"Reduces RAD by 12.", 
    use:()=>{ derad(12); log("You take AntiRad. RAD -12."); return true; }
  },

  food: { 
    name:"Canned Food", desc:"Heals 4 HP or can be consumed before travel.", 
    use:()=>{ heal(4); log("You eat canned food. HP +4."); return true; }
  },

  holotape: { name:"Ancient Holotape", desc:"Collectors pay well. Can be sold to traders." },

  water_filter:{ 
    name:"Water Filter", 
    desc:"Allows safe refilling of a canteen at events.",
    use:()=>{ 
      if(countItem("canteen") > 0){ 
        heal(5); 
        log("You purify and drink water. HP +5."); 
        return true; 
      } 
      log("You need a canteen to use the Water Filter."); 
      return false;
    }
  },

//////// === Melee weappons 

  scrap_blade: {
    name:"Scrap Blade",
    desc:"A crude melee weapon. Increases combat effectiveness.",
    slot:"weapon",
    bonus:{ atk:5 },
    use:()=>{ equipItem("scrap_blade"); return false; }
  },

machete: {
    name:"Machete",
    desc:"Chopped and ready. +7 ATK.",
    slot:"weapon", bonus:{ atk:7 }
  },
  sledgehammer: {
    name:"Sledgehammer",
    desc:"Hefty bruiser. +12 ATK, -1 AGI.",
    slot:"weapon", bonus:{ atk:12, agi:-1 }
  },
};


// simple recipes: requires → produces
const RECIPES = [
  {id:"repair_kit", name:"Repair Kit", 
   requires:{junk:1, duct_tape:1}, 
   produces:{med_patch:1},
   desc:"1 Junk + 1 Duct Tape → 1 Med Patch"},
  
  {id:"sell_junk", name:"Sell Junk Bundle", 
   requires:{junk:3}, 
   produces:{caps:12},
   desc:"Trade 3 Junk for 12 caps."},

  {id:"craft_blade", name:"Craft Scrap Blade", 
   requires:{junk:2, duct_tape:1}, 
   produces:{scrap_blade:1},
   desc:"2 Junk + 1 Duct Tape → 1 Scrap Blade"}
];

// ========= Equipment System =========
// Tracks equipped gear and bonuses

// expand state on new runs
function initEquipment(){
  if(!state.equipment){
    state.equipment = { head:null, chest:null, legs:null, weapon:null };
  }
}

function equipItem(id){
  const meta = ITEMS[id];
  if(!meta || !meta.slot){ log("That item can’t be equipped."); return false; }

  // unequip existing
  if(state.equipment[meta.slot]){
    addItem(state.equipment[meta.slot], 1);
  }

  // equip new
  state.equipment[meta.slot] = id;
  removeItem(id,1);
  log(`You equipped ${meta.name} in ${meta.slot} slot.`);
  updateUI();
  return true;
}

function unequip(slot){
  if(!state.equipment[slot]){ log("Nothing equipped there."); return false; }
  addItem(state.equipment[slot],1);
  log(`You unequipped ${ITEMS[state.equipment[slot]].name}.`);
  state.equipment[slot] = null;
  updateUI();
  return true;
}

function calcStats(){
  let atk = 0, def = 0, crit = 0, agi = 0;
  for (const slot of Object.keys(state.equipment)){
    const id = state.equipment[slot];
    if(id && ITEMS[id].bonus){
      const b = ITEMS[id].bonus;
      atk += b.atk || 0;
      def += b.def || 0;
      crit += b.crit || 0;
      agi  += b.agi  || 0;
    }
  }
  return {atk, def, crit, agi};
}


function showEquipment(){
  let txt = "Equipped Gear:<br>";
  for(const slot of ["head","chest","legs","weapon"]){
    const id = state.equipment[slot];
    txt += `${slot}: ${id ? ITEMS[id].name : "None"}<br>`;
  }
  return txt;
}


// ========= Inventory Functions (hardened) =========
function inv(){
  if (!Array.isArray(state.inventory)) state.inventory = [];
  sanitizeInventory();                  // ensure invariant every time we read
  return state.inventory;
}

function objectIdToKey(obj){
  // Try to resolve an object to an ITEMS key
  for (const [key, meta] of Object.entries(ITEMS)){
    if (meta === obj) return key;                     // identity match
    if (obj && typeof obj === "object" && obj.name && meta.name === obj.name) return key; // name match
  }
  return null;
}

function pushStackSafe(normalized, id, qty=1){
  // id must be string; qty becomes integer >=1
  if (typeof id !== "string" || !id) return;
  id = slugify(id);
  qty = Math.max(1, Number(qty) || 1);
  const existing = normalized.find(s => s.id === id);
  if (existing) existing.qty += qty;
  else normalized.push({ id, qty });
}

function sanitizeInventory(){
  const src = state.inventory;
  const normalized = [];

  for (const s of src){
    // 1) Simple string: ["junk","duct_tape"]
    if (typeof s === "string"){
      pushStackSafe(normalized, s, 1);
      continue;
    }

    // 2) Proper stack: [{ id:"junk", qty:2 }]
    if (s && typeof s === "object" && "id" in s){
      let id = s.id;
      // rescue if id is an object (e.g., ITEMS.junk)
      if (typeof id !== "string"){
        const rescued = objectIdToKey(id);
        if (!rescued) continue; // skip unrescuable garbage
        id = rescued;
      }
      pushStackSafe(normalized, id, s.qty);
      continue;
    }

    // 3) Meta object itself was pushed (e.g., ITEMS.junk)
    if (s && typeof s === "object" && !Array.isArray(s) && ("name" in s || "desc" in s)){
      const rescued = objectIdToKey(s);
      if (rescued) pushStackSafe(normalized, rescued, 1);
      // if not rescued, drop it silently
      continue;
    }

    // 4) Dictionary shape: [{ junk:2, duct_tape:1 }]
    if (s && typeof s === "object" && !Array.isArray(s)){
      let treated = false;
      for (const [k,v] of Object.entries(s)){
        if (typeof k === "string"){
          pushStackSafe(normalized, k, v);
          treated = true;
        }
      }
      if (treated) continue;
    }

    // Anything else → ignore
  }

  state.inventory = normalized;
}

function findStack(id){
  id = slugify(id);
  return inv().find(s => s.id === id);
}

// for adding items from quests and actions etc
function addItem(id, qty = 1){
  // Coerce various shapes
  if (id && typeof id === "object"){
    // Stack shape
    if ("id" in id && "qty" in id) return addItem(id.id, Number(id.qty) || 1);

    // Meta object (ITEMS.*)
    const rescued = objectIdToKey(id);
    if (rescued) return addItem(rescued, qty);

    // Dictionary: { junk:2, duct_tape:1 }
    const entries = Object.entries(id);
    if (entries.length && entries.every(([k]) => typeof k === "string")){
      for (const [k,v] of entries) addItem(k, Number(v) || 1);
      return;
    }

    console.warn("addItem: unsupported object ignored", id);
    return;
  }

  if (typeof id !== "string" || !id) return;
  id = slugify(id);
  qty = Math.max(1, Number(qty) || 1);

  const it = findStack(id);
  if (it) it.qty += qty;
  else state.inventory.push({ id, qty });
}

function countItem(id){
  const s = findStack(id);
  return s ? s.qty : 0;
}

function removeItem(id, qty = 1){
  id = slugify(id);
  qty = Math.max(1, Number(qty) || 1);

  // Get current stack (this call is fine; it sanitizes once up front)
  const it = findStack(id);
  if (!it) return false;

  it.qty -= qty;

  if (it.qty > 0) return true;

  // Remove the stack entirely by id (no inv() call here)
  state.inventory = Array.isArray(state.inventory)
    ? state.inventory.filter(s => !(s && typeof s === "object" && s.id === id))
    : [];

  return true;
}


// req shape: { itemId: quantity, caps?: number }
function hasItems(req){
  return Object.entries(req).every(([id, n]) =>
    (id === "caps" ? state.caps : countItem(id)) >= n
  );
}

// sign -1 to consume req, +1 to grant req
function applyDelta(req, sign){
  for (const [id, n] of Object.entries(req)){
    if (id === "caps"){ state.caps += sign * n; continue; }
    if (sign < 0) removeItem(id, n); else addItem(id, n);
  }
}

function useItem(id){
  id = slugify(id);
  const meta = ITEMS[id];
  if (!meta || !meta.use){
    log("You can’t use that.");
    return false;
  }
  const ok = meta.use();         // meta.use returns true if consumed
  if (ok) removeItem(id, 1);
  updateUI();
  return ok;
}

function craft(recipeId){
  const r = RECIPES.find(x => x.id === recipeId);
  if (!r){ log("No such recipe."); return; }
  if (!hasItems(r.requires)){ log("Missing ingredients."); return; }

  applyDelta(r.requires, -1);    // consume

  if (r.produces.caps) state.caps += r.produces.caps;
  for (const [id, n] of Object.entries(r.produces)){
    if (id !== "caps") addItem(id, n);
  }

  log(`Crafted: ${r.name}.`);
  updateUI();
}

// ====== Ammo / Weapon helpers ======
function equippedWeaponId(){
  return state?.equipment?.weapon || null;
}
function equippedWeaponMeta(){
  const w = equippedWeaponId();
  return w ? ITEMS[w] : null;
}
function weaponUsesAmmo(meta){
  return !!(meta && meta.ammo && meta.ammo.id);
}
function ammoCount(ammoId){
  return countItem(ammoId);
}
function consumeAmmo(ammoId, n=1){
  n = Math.max(1, Number(n) || 1);
  if (countItem(ammoId) < n) return false; // don't partially consume
  removeItem(ammoId, n);
  return true;
}

/**
 * Returns {atk, def, crit, agi} like calcStats(), but with weapon bonus excluded.
 * Useful when a firearm is out of ammo (melee buttstroke / bash).
 */
function calcStatsWithoutWeapon(){
  let atk = 0, def = 0, crit = 0, agi = 0;
  for (const slot of Object.keys(state.equipment)){
    const id = state.equipment[slot];
    if(!id) continue;
    if (slot === "weapon") continue; // skip weapon bonuses
    const b = ITEMS[id]?.bonus;
    if(!b) continue;
    atk += b.atk || 0;
    def += b.def || 0;
    crit += b.crit || 0;
    agi  += b.agi  || 0;
  }
  return { atk, def, crit, agi };
}

/**
 * Convenience: compute temporary "current attack + crit" applying melee fallback
 * if the equipped weapon is a gun with no ammo.
 * Relies on global calcStats() you already have.
 */
function currentAttackAndCritWithAmmoGate(){
  const base = calcStats(); // includes weapon bonus if any
  const wMeta = equippedWeaponMeta();
  if (!weaponUsesAmmo(wMeta)) {
    return { atk: base.atk, crit: base.crit, usedAmmo:false, out:false, ammoName:null, perShot:0 };
  }
  const ammoId = wMeta.ammo.id;
  const per = Math.max(1, Number(wMeta.ammo.perShot) || 1);
  const have = ammoCount(ammoId);

  if (have >= per){
    // We will consume ammo; caller should actually remove it on successful attack
    return { atk: base.atk, crit: base.crit, usedAmmo:true, out:false, ammoName:ITEMS[ammoId]?.name||ammoId, perShot:per, ammoId };
  } else {
    // Out of ammo → melee fallback (strip weapon's bonus)
    const wAtk  = (wMeta.bonus?.atk || 0);
    const wCrit = (wMeta.bonus?.crit || 0);
    const fallbackAtk  = Math.max(0, base.atk - wAtk);
    const fallbackCrit = Math.max(0, base.crit - wCrit);
    return { atk: fallbackAtk, crit: fallbackCrit, usedAmmo:false, out:true, ammoName:ITEMS[ammoId]?.name||ammoId, perShot:per, ammoId };
  }
}





/* ========= Game Data ========= */
// NOTE: All static game data: names, origins, locations, jobs, factions, perks
// - Add new jobs in JOBS[]
// - Add new factions in FACTIONS[]
// - Add new perks in PERKS[]

const NAMES = ["Ash","Rae","Piper","Vale","Rook","Nova","Jax","Morgan","Quinn","Alex","Harper","Rowan","Kit","Dak","Remy","Skye","Indy","Jet","Mack","Sable","Rune","Tess","Wren","Zed"];
const ORIGINS = ["Wastelander","Settlement Kid","Dust-towner"];
const LOCATIONS = ["Dustown","Ironwood", "Wasteland Dunes", "Cracked Ruins", "Salt Flats", "Red Canyons", "Irrad. Swamp",];
const JOBS = [
  { id:"none",   name:"Unemployed",       minAge:0,  base: 0,              req: ()=>true },

  // Always available at 18+
  { id:"scav",   name:"Scavenger",        minAge:18, base: rnd(10,25),     req: ()=>true },
  { id:"trader", name:"Caravan Trader",   minAge:18, base: rnd(20,40),     req: ()=>true },
  { id:"guard",  name:"Settlement Guard", minAge:18, base: rnd(25,55),     req: ()=>true },
  { id:"scribe", name:"Scribe",           minAge:18, base: rnd(35,70),     req: ()=>true },

  // Only locked job
  { id:"med",    name:"Field Medic",      minAge:18, base: rnd(40,80),     req: s => s.I >= 8 }
];


const FACTIONS = [
  { id:"none", name:"Unaffiliated", req: s=>true, blurb:"You walk your own road." },
  { id:"settlers", name:"Settlers Union", req: s=>s.C>=4, blurb:"Builders and traders striving for stability." },
  { id:"rangers", name:"Desert Rangers", req: s=>s.A>=5 && s.P>=5, blurb:"Lean, disciplined scouts of the wastes." },
  { id:"scribes", name:"Scribes of the Old World", req: s=>s.I>=6, blurb:"Archivists preserving tech and knowledge." },
  { id:"dust_marauders", name:"Dust Marauders", req: s=>s.S>=6 || s.L>=7, blurb:"Lawless plunderers—high risk, high reward." }
];

const PERKS = [
  { id:"toughness", name:"Toughness", desc:"+10 max HP", req:(state)=> state.level>=3 },
  { id:"silverTongue", name:"Silver Tongue", desc:"+15% job pay & trade", req:(state)=> state.special.C>=6 },
  { id:"scrounger", name:"Scrounger", desc:"Better loot on Explore", req:(state)=> state.special.L>=6 },
  { id:"medic", name:"Medic", desc:"Heal more; reduce RAD", req:(state)=> state.special.I>=6 },
  { id:"swift", name:"Swift", desc:"+10% escape chances", req:(state)=> state.special.A>=6 },
];

/* ========= Enemies ========= */
// tier: "wastes" | "work" | "Dust_Marauders" | "rangers" etc.
const ENEMIES = [
  { id:"molerat",    name:"Molerat",    tier:"wastes",  hp:28, atk:6,  def:2,  spd:9,  reward:{ xp:10, caps: rnd(3,7) } },
  { id:"wild_dogs",  name:"Wild Dogs",  tier:"wastes",  hp:34, atk:7,  def:3,  spd:11, reward:{ xp:12, caps: rnd(4,9) } },
  { id:"feral",      name:"Feral Ghoul",tier:"wastes",  hp:40, atk:8,  def:4,  spd:12, reward:{ xp:14, caps: rnd(6,12) } },
  { id:"scav_band",  name:"Scav Bandit",tier:"work",    hp:36, atk:8,  def:4,  spd:10, reward:{ xp:14, caps: rnd(7,13) } },
  { id:"mutant_verm",name:"Mutant Vermin", tier:"wastes", hp:30, atk:7, def:3, spd:13, reward:{ xp:12, caps: rnd(5,10) } },
  { id:"waste_stalker", name:"Wasteland Stalker", tier:"rangers", hp:46, atk:10, def:5, spd:14, reward:{ xp:18, caps: rnd(9,18) } },

// ========= Dust Marauders (Texas Raiders) =========
  { id:"dust_pistolero", name:"Dust Pistolero", tier:"dust_marauders", hp:46, atk:10, def:4, spd:13, reward:{ xp:18, caps: rnd(10,18) } },
  { id:"rust_rider", name:"Rust Rider", tier:"dust_marauders", hp:54, atk:12, def:5, spd:12, reward:{ xp:22, caps: rnd(12,22) } },
  { id:"buckshot_bandit", name:"Buckshot Bandit", tier:"dust_marauders", hp:58, atk:13, def:5, spd:11, reward:{ xp:24, caps: rnd(15,26) } },
  { id:"oilfield_raider", name:"Oilfield Outlaw", tier:"dust_marauders", hp:62, atk:12, def:6, spd:12, reward:{ xp:28, caps: rnd(18,30) } },
  { id:"dust_warlord", name:"Dust Warlord", tier:"dust_marauders", hp:72, atk:14, def:7, spd:13, reward:{ xp:34, caps: rnd(20,36) } },
];

// Simple generator that picks by tier (falls back to wastes)
function generateEnemy(tier="wastes"){
  const pool = ENEMIES.filter(e=>e.tier===tier);
  const base = (pool.length? pool : ENEMIES.filter(e=>e.tier==="wastes"));
  const e = sample(base);
  // Copy with fresh HP so we don’t mutate base definition
  return { ...e, curHP: e.hp };
}


const SPECIAL_KEYS = ["S","P","E","C","I","A","L"];

/* ========= Game State ========= */
let state = null;

function newRun() {
  const name = sample(NAMES);
  const origin = sample(ORIGINS);
  const location = sample(LOCATIONS);
  const S = Object.fromEntries(SPECIAL_KEYS.map(k=>[k, rnd(1,10)]));
  let pool = 5; while (pool--) { const k = sample(SPECIAL_KEYS); S[k] = clamp(S[k]+1,1,10); }

  state = {
    alive: true,
    year: 2165,
    age: 18,
    name, origin, location,
    special: S,
    hp: 100, hpMax: 100,
    rad: 0,
    caps: rnd(5,25),
    karma: 0,
    level: 1, xp: 0,
    job: "none",
    faction: "none",
    inventory: ["Canteen","Junk","Duct Tape","Knife",],
    perks: [],
    pendingChoice: null,
    log: [],
    factionRep: 0,
    factionActionUsed: false,
    equipment: { head:null, chest:null, legs:null, weapon:null },
    battlesWon: 0,
    battlesLost: 0,
    buffs: { radShield:{turns:0}, fleeBoost:0, atkBoost:0, strEnd:0, percInt:0 },
  };

  log(`You begin at age 18...`);
  log(`Your S.P.E.C.I.A.L.: ${SPECIAL_KEYS.map(k => k + ":" + state.special[k]).join(" ")}`, "muted");
  updateUI();
}



/* ========= UI ========= */
function updateUI() {
  $("#name").textContent = state.name;
  $("#age").textContent = state.age;
  $("#caps").textContent = state.caps;
  $("#karma").textContent = state.karma;
  $("#level").textContent = state.level;
  $("#xp").textContent = state.xp;
  $("#hp").textContent = `${state.hp}/${state.hpMax}`;
  $("#rad").textContent = state.rad;
  $("#origin").textContent = state.origin;
  $("#job").textContent = getJob().name;
  $("#location").textContent = state.location;
  $("#year").textContent = state.year;
  $("#header-status").textContent = state.alive ? "alive" : "deceased";

  // Update the sidebar button label based on faction status
  const joinBtn = $("#btn-join-faction");
  if (joinBtn) {
    joinBtn.textContent = (state.faction === "none")
      ? "Join a Faction"
      : "View Faction";
  }

  // --- Faction pill update ---
  const f = getFaction();
  const pillWrap = $("#faction-pill-wrapper");

  if (state.faction === "none") {
    $("#faction-pill").textContent = "Unaffiliated";
  } else {
    $("#faction-pill").textContent = `${f.name} (Rep ${state.factionRep})`;
  }

  // reset + apply faction color class
  pillWrap.classList.remove(
    "faction-settlers","faction-rangers","faction-scribes","faction-Dust_Marauders","faction-none"
  );
  pillWrap.classList.add("faction-" + state.faction);

  // --- S.P.E.C.I.A.L. bars ---
  const wrap = $("#special");
  wrap.innerHTML = "";
  SPECIAL_KEYS.forEach(k => {
    const v = state.special[k];
    const s = el("div", "stat");
    const lbl = el("div","stat-label");
    lbl.append(el("span", null,
      k==="S"?"Strength":k==="P"?"Perception":k==="E"?"Endurance":
      k==="C"?"Charisma":k==="I"?"Intelligence":k==="A"?"Agility":"Luck"
    ));
    lbl.append(el("span", null, v + "/10"));
    const bar = el("div","bar" + (v<=3?" danger": v<=5?" warn":""));
    const fill = el("i"); fill.style.width = (v*10) + "%";
    bar.append(fill);
    s.append(lbl, bar);
    wrap.append(s);
  });

  // disable actions if pending choice or dead
  const disable = !!state.pendingChoice || !state.alive;
  ["#btn-age","#btn-explore","#btn-work","#btn-heal", "#btn-inventory","#btn-join-faction","#btn-perks"]
    .forEach(sel => { $(sel).disabled = disable; $(sel).style.opacity = disable? .6 : 1; });

  // death checks
  if (state.alive && (state.hp<=0 || state.rad>=100 || state.age>=120)) {
    die();
  }
}


function log(text, cls) {
  const entry = el("div","entry"+(cls? " "+cls:""));
  const p = el("p", null, text);
  entry.append(p);
  $("#log").prepend(entry);
  state.log.push(text);
}

function info(text){ log(text,"muted") }

function getJob(){ return JOBS.find(j=>j.id===state.job) || JOBS[0]; }
function getFaction(){ return FACTIONS.find(f=>f.id===state.faction) || FACTIONS[0]; }

/* ========= Mechanics (leveled combat power) ========= */
function gainXP(n) {
  state.xp += n;
  while (state.xp >= needXP(state.level)) {
    state.xp -= needXP(state.level);
    state.level++;

    // Core survivability bump each level
    const hpGain = 6;                 // was +5
    state.hpMax += hpGain;
    state.hp = Math.min(state.hpMax, state.hp + Math.ceil(hpGain / 2));

    // Combat power: SPECIAL growth (feeds into ATK/DEF/SPD/CRIT)
    applyLevelBonuses(state.level);

    log(`Level up! You are now level ${state.level}. Max HP +${hpGain}.`);
  }
  updateUI();
}

// Slightly steeper XP curve to pace the extra power
function needXP(level){ return 50 + level * 30; }  // was 25/level

function changeKarma(n){
  state.karma = clamp(state.karma + n, -100, 100);
}

/* ---- Level-up helpers ---- */

// Job-flavoured stat growth + milestone bumps.
// Keeps numbers small, capped at 10, but makes you meaningfully stronger over time.
function applyLevelBonuses(level){
  const job = (getJob()?.id) || "none";

  // Primary/secondary per job (affects playerBattleStats downstream)
  const primary = job === "guard"  ? "S" :
                  job === "scav"   ? "P" :
                  job === "trader" ? "C" :
                  job === "scribe" ? "I" :
                  job === "med"    ? "I" : "A";

  const secondary = job === "guard"  ? "E" :
                    job === "scav"   ? "A" :
                    job === "trader" ? "L" :
                    job === "scribe" ? "P" :
                    job === "med"    ? "P" : "S";

  // Always +1 to your primary each level
  bumpSPECIAL(primary, +1, `+1 ${fullName(primary)}`);

  // Every 3 levels: +1 to your secondary
  if (level % 3 === 0) bumpSPECIAL(secondary, +1, `+1 ${fullName(secondary)}`);

  // Every 5 levels: +1 Luck (nudges crit & events)
  if (level % 5 === 0) bumpSPECIAL("L", +1, "+1 Luck");

  // Gentle pacing boost: every even level +1 Agility (helps SPD/flee)
  if (level % 2 === 0) bumpSPECIAL("A", +1, "+1 Agility");
}

function bumpSPECIAL(k, delta, note){
  if (!SPECIAL_KEYS.includes(k)) return;
  const before = state.special[k];
  state.special[k] = clamp(state.special[k] + delta, 1, 10);
  if (state.special[k] !== before) {
    info(`Level bonus: ${note}`);
  }
}

function fullName(k){
  return k==="S"?"Strength" :
         k==="P"?"Perception" :
         k==="E"?"Endurance" :
         k==="C"?"Charisma" :
         k==="I"?"Intelligence" :
         k==="A"?"Agility" : "Luck";
}


  // ========= Yearly Event Pool =========
  // NOTE: Events are chosen from this pool each year
  // - Add new events into pool.push() based on age or faction

function yearlyEvent() {
  const a = state.age;
  const pool = [];

  // universal
  pool.push(evt_findStash, evt_radStorm, evt_tradeOffer, evt_bandits, evt_sick, evt_helpStranger, evt_mysteriousStranger);

  if (a <= 12) {
    pool.push(evt_schoolyard, evt_vaultDrill);
  } else if (a <= 18) {
    pool.push(evt_sneakOut, evt_training, evt_firstJob);
  } else {
    pool.push(evt_workAccident, evt_factionScout, evt_repairOldTech);
  }
  // faction flavored
  if (state.faction==="rangers") pool.push(evt_rangerPatrol);
  if (state.faction==="scribes") pool.push(evt_lostArchive);
  if (state.faction==="Dust_Marauders") pool.push(evt_shakedown);

  const e = sample(pool);
  return e();
}

function setChoice(prompt, choices) {
  state.pendingChoice = { prompt, choices };
  renderChoice();
  updateUI();
}

function renderChoice() {
  const c = state.pendingChoice;
  if (!c) return;

  const entry = el("div","entry");
  entry.append(el("p",null, c.prompt));
  const box = el("div","choices");

  c.choices.forEach(choice => {
    const b = el("button","choice", choice.label);
    b.onclick = () => {
      // guard against double clicks
      if (entry.dataset.resolved === "1") return;
      entry.dataset.resolved = "1";
      entry.classList.add("resolved");

      // immediately disable all buttons in this choice block
      box.querySelectorAll("button").forEach(btn => { btn.disabled = true; });

      try { choice.run(); }
      catch(e){ console.error(e); log("Something went wrong with that choice.","muted"); }

      state.pendingChoice = null;
      updateUI();
    };
    box.append(b);
  });

  entry.append(box);
  $("#log").prepend(entry);
}


/* ========= Events ========= */
function skillCheck(key, diff){
  const roll = rnd(1,10) + (state.perks.includes("swift") && key==="A" ? 1 : 0);
  const total = state.special[key] + roll;
  return total >= diff;
}

function money(mult=1){
  let base = rnd(5, 25);
  if (state.perks.includes("silverTongue")) base = Math.round(base * 1.15);
  if (state.perks.includes("scrounger")) base = Math.round(base * 1.25);
  return Math.round(base * mult);
}

function damage(n){
  state.hp = clamp(state.hp - n, 0, state.hpMax);
  updateUI();
}
function heal(n){
  state.hp = clamp(state.hp + n, 0, state.hpMax);
  updateUI();
}
function rad(n){
  let amt = n;
  if (state.buffs?.radShield?.turns > 0) amt = Math.ceil(n * 0.5);
  state.rad = clamp(state.rad + amt, 0, 100);
  updateUI();
}
function derad(n){
  state.rad = clamp(state.rad - n, 0, 100);
  updateUI();
}
function addCaps(amount){
  state.caps += amount;
  updateUI();
}



// NOTE: Each evt_* function defines one scenario with choices
// - Add new events here
// - Use setChoice() to present options

function evt_findStash(){
  const amt = money(1 + (state.special.L/20));
  setChoice(
    "You discover a hidden cache behind a cracked wall.",
    [
      { label:`Loot it (+${amt} caps, +XP)`, run:()=>{ state.caps+=amt; gainXP(12); log(`You pocket ${amt} caps and a few trinkets.`);} },
      { label:"Leave it (Karma +3)", run:()=>{ changeKarma(+3); log("You leave it for someone in greater need."); gainXP(5);} }
    ]
  );
}

function evt_radStorm(){
  setChoice("A radiation storm rolls over the wastes.", [
    { label:"Find shelter (P+E check)", run:()=>{
      if (skillCheck("P",12) && skillCheck("E",12)){ log("You hunker down safely. XP +10."); gainXP(10); }
      else { log("You fail to find proper cover. RAD +12, HP -5."); rad(12); damage(5); }
    }},
    { label:"Push through (-HP, +XP)", run:()=>{ damage(10); rad(6); gainXP(15); log("You brave the storm and make progress."); } }
  ]);
}

function evt_tradeOffer(){
  const price = rnd(12,28);
  setChoice("A caravan offers a water filter.", [
    { label:`Buy (${price} caps)`, run:()=>{
      if (state.caps>=price){ state.caps-=price; addItem("water_filter",1); log("You buy the filter. Hydration secured."); changeKarma(+1); }
      else { log("Not enough caps."); }
    }},
    { label:"Haggle (C check)", run:()=>{
      if (skillCheck("C", 12)){ const p = Math.max(4, price-8); log(`You talk them down to ${p} caps.`); state.caps = Math.max(0, state.caps - p); changeKarma(+1); }
      else { log("Your haggling backfires. Price goes up 5 caps."); const p=price+5; if (state.caps>=p){ state.caps-=p; log("You begrudgingly pay."); } else log("You walk away."); }
    }},
    { label:"Pass", run:()=>{ log("You pass on the offer."); } }
  ]);
}

function evt_bandits(){
  setChoice("Bandits block your path and demand caps.", [
    { label:"Fight (S+A check)", run:()=>{
      const ok = skillCheck("S",12) && skillCheck("A",12);
      if (ok){ log("You outmaneuver them. XP +20, caps +"+money(1.2)); state.caps+=money(1.2); gainXP(20); changeKarma(+1);}
      else { log("They rough you up. HP -15, caps -10."); damage(15); state.caps=Math.max(0, state.caps-10); changeKarma(-1); }
    }},
    { label:"Flee (A check)", run:()=>{
      const ok = skillCheck("A", 13 - (state.perks.includes("swift")?1:0));
      if (ok){ log("You slip away into the ruins. XP +12."); gainXP(12); }
      else { log("You stumble. HP -8, caps -6."); damage(8); state.caps=Math.max(0, state.caps-6); }
    }},
    { label:"Pay 12 caps", run:()=>{
      const cost=12; if (state.caps>=cost){ state.caps-=cost; log("They let you pass."); changeKarma(-1);}
      else log("You don't have enough. They laugh and shove you.");
    }},
  ]);
}

function evt_sick(){
  setChoice("You fall ill after drinking questionable water.", [
    { label:"Rest (-work this year, +HP)", run:()=>{ heal(8); log("You rest and recover a bit. XP +5."); gainXP(5); } },
    { label:"Self-medicate (I check)", run:()=>{
      if (skillCheck("I",12)){ heal(10); derad(5); log("You successfully treat yourself."); gainXP(10); }
      else { damage(8); rad(6); log("Treatment goes poorly."); }
    }},
  ]);
}

function evt_helpStranger(){
  setChoice("A wounded stranger begs for help.", [
    { label:"Help (Karma +5, -time)", run:()=>{ changeKarma(+5); gainXP(10); heal(5); log("They thank you and hand you a trinket (+5 caps)."); state.caps+=5; } },
    { label:"Ignore (Karma -5)", run:()=>{ changeKarma(-5); log("You move on."); } }
  ]);
}

function evt_mysteriousStranger(){
  if (rnd(1,100) <= (5 + state.special.L)) {
    const amt = money(2.0);
    setChoice("A mysterious figure nods and vanishes.", [
      { label:`Check your pocket (+${amt} caps)`, run:()=>{ state.caps+=amt; log("A note reads: “Make your own luck.”"); } }
    ]);
  } else {
    return evt_findStash();
  }
}

function evt_schoolyard(){
  setChoice("At the settlement school, a radroach skitters by.", [
    { label:"Stomp it (S check)", run:()=>{ if (skillCheck("S",10)){ gainXP(6); log("Splat. The class cheers."); } else { damage(2); log("It nips you. Ouch."); } } },
    { label:"Observe (I +1)", run:()=>{ state.special.I = clamp(state.special.I+1,1,10); gainXP(4); log("You study its behavior. +1 INT."); } },
    { label:"Run (A +1)", run:()=>{ state.special.A = clamp(state.special.A+1,1,10); log("You’re quick on your feet. +1 AGI."); } },
  ]);
}

function evt_vaultDrill(){
  setChoice("Vault safety drill time.", [
    { label:"Lead classmates (C +1)", run:()=>{ state.special.C = clamp(state.special.C+1,1,10); log("You take charge. +1 CHA."); } },
    { label:"Carry supplies (S +1)", run:()=>{ state.special.S = clamp(state.special.S+1,1,10); log("Heavy lifting builds muscle. +1 STR."); } },
  ]);
}

function evt_sneakOut(){
  setChoice("Friends want to sneak out after curfew.", [
    { label:"Go (A check)", run:()=>{ if (skillCheck("A",12)){ gainXP(8); log("You make it back unseen."); } else { damage(6); log("You trip over debris and get scraped."); } } },
    { label:"Decline (Karma +2)", run:()=>{ changeKarma(+2); log("You decide against it."); } },
  ]);
}

function evt_training(){
  setChoice("A mentor offers combat drills.", [
    { label:"Train (S +1 or A +1)", run:()=>{ if (Math.random()<.5) { state.special.S=clamp(state.special.S+1,1,10); log("+1 STR."); } else { state.special.A=clamp(state.special.A+1,1,10); log("+1 AGI."); } gainXP(10); } },
    { label:"Study tactics (I +1)", run:()=>{ state.special.I=clamp(state.special.I+1,1,10); gainXP(8); log("+1 INT."); } },
  ]);
}

function evt_firstJob(){
  if (state.age>=14 && state.job==="none"){
    setChoice("You’re old enough to work. Pick a path?", [
      ...JOBS.filter(j=>j.id!=="none" && j.minAge<=state.age && j.req(state.special))
        .map(j=>({label:j.name, run:()=>{ state.job = j.id; log(`You start as a ${j.name}.`); gainXP(10);} })),
      {label:"Not now", run:()=>{ log("You put it off."); }}
    ]);
  } else {
    return evt_training();
  }
}

function evt_workAccident(){
  setChoice("A workplace mishap occurs.", [
    { label:"React fast (A check)", run:()=>{ if (skillCheck("A",12)){ log("You prevent injury. XP +10."); gainXP(10);} else { damage(10); log("You get hurt. HP -10."); } } },
    { label:"Shield others (Karma +3)", run:()=>{ changeKarma(+3); damage(6); gainXP(8); log("You protect coworkers."); } }
  ]);
}

function evt_factionScout(){
  if (state.faction==="none"){
    setChoice("A faction scout sizes you up.", [
      { label:"Hear them out", run:()=>{ openJoinFaction(); } },
      { label:"Ignore", run:()=>{ log("Maybe another time."); } }
    ]);
  } else {
    return evt_repairOldTech();
  }
}

function evt_repairOldTech(){
  setChoice("You find a busted pre-war device.", [
    { label:"Tinker (I check)", run:()=>{ if (skillCheck("I",13)){ gainXP(16); state.caps+=money(1.3); log("It whirs to life. You sell parts for caps."); } else { damage(4); log("It sparks and bites you."); } } },
    { label:"Salvage (+caps, +RAD)", run:()=>{ state.caps+=money(1.1); rad(6); log("Profitable, but dirty work."); } },
  ]);
}

function evt_rangerPatrol(){
  setChoice("On patrol, you spot movement.", [
    { label:"Investigate (P check)", run:()=>{ if (skillCheck("P",12)){ gainXP(12); log("It’s a harmless critter. All clear."); } else { damage(6); log("Ambush! You’re grazed."); } } },
    { label:"Radio in (+Karma)", run:()=>{ changeKarma(+2); gainXP(8); log("Teamwork keeps people safe."); } }
  ]);
}

function evt_lostArchive(){
  setChoice("A rumor about a hidden archive spreads among Scribes.", [
    { label:"Research (I +1)", run:()=>{ state.special.I=clamp(state.special.I+1,1,10); gainXP(14); log("Clues emerge. +1 INT."); } },
    { label:"Field search (E check)", run:()=>{ if (skillCheck("E",12)){ gainXP(16); addItem("holotape",1); log("You recover an old holotape."); } else { rad(8); log("The trail leads through hot zones. RAD +8."); } } },
  ]);
}

function evt_shakedown(){
  setChoice("Your crew eyes a shakedown opportunity.", [
    { label:"Intimidate (C check)", run:()=>{ 
        if (skillCheck("C",12)){ state.caps+=money(1.4); changeKarma(-5); log("You score loot, but word spreads. Karma -5."); } 
        else { log("They weren’t impressed. Awkward."); } 
      } 
    },
    { label:"Pass (Karma +2)", run:()=>{ changeKarma(+2); log("You keep the peace—for now."); } }
  ]);
} // <-- this closing brace was missing

// One-click actions for each faction (shown in the Faction menu after you join)
// ========= Faction Actions =========
// NOTE: Each faction has repeatable actions here
// - Add new actions inside settlers/rangers/scribes/Dust_Marauders arrays
// - Use changeRep() and changeKarma() for outcomes

const FACTION_ACTIONS = {
  settlers: [
    {
      label: "Escort a trade caravan",
      run: () => {
        // 30% chance the escort turns into a fight (wastes-tier enemy)
        if (maybeStartCombat(0.30, "wastes", "faction")) return;

        const ambush = rnd(1,100) < 35;
        const pay = money(1.1) + 5;
        state.caps += pay;
        changeRep(+3);
        changeKarma(+1);
        gainXP(10);
        log(`You escort a caravan. +${pay} caps, +rep, +karma.`);
        if (ambush) {
          if (skillCheck("A",12)) {
            log("Bandit ambush avoided.");
            gainXP(6);
          } else {
            damage(6);
            log("Ambushed on the road. HP -6.");
          }
        }
      }
    },
    {
      label: "Help build defenses (cost 8 caps)",
      run: () => {
         // Small chance a Dust Marauder scout pokes the line
        if (maybeStartCombat(0.15, "Dust_Marauders", "faction")) return;
        if (state.caps < 8) { log("Not enough caps for materials."); return; }
        state.caps -= 8;
        changeRep(+4);
        gainXP(12);
        log("You reinforce palisades and set traps. +rep, +XP.");
      }
    },
    {
      label: "Work the fields",
      run: () => {
           // Vermin encounter, low chance
        if (maybeStartCombat(0.12, "wastes", "faction")) return;
        const harvest = rnd(2,5);
        state.caps += harvest;
        changeRep(+2);
        changeKarma(+1);
        gainXP(8);
        log(`You toil in the fields. Earned ${harvest} caps, gained trust and karma.`);
      }
    },
    {
      label: "Teach survival skills",
      run: () => {
        changeRep(+3);
        changeKarma(+2);
        gainXP(15);
        log("You show settlers how to purify water and forage safely. +rep, +karma, +XP.");
      }
    }
  ],

  rangers: [
    {
      label: "Perimeter patrol",
      run: () => {
         // Patrols should fight sometimes
        if (maybeStartCombat(0.25, "rangers", "faction")) return;
        if (skillCheck("P",12)) {
          gainXP(12);
          changeRep(+3);
          log("Quiet patrol. You spot tracks and report in. +rep, +XP.");
        } else {
          damage(4);
          gainXP(8);
          log("You spring a snare. HP -4, +XP.");
        }
      }
    },
    {
      label: "Track Dust Marauders",
      run: () => {
          // High chance of Dust_Marauders combat
        if (maybeStartCombat(0.50, "Dust_Marauders", "faction")) return;
        const tough = !skillCheck("A",13) || !skillCheck("S",12);
        if (tough) {
          damage(10);
          log("Skirmish turns nasty. HP -10.");
        } else {
          const bounty = money(1.3);
          state.caps += bounty;
          changeRep(+5);
          gainXP(16);
          log(`Successful interdiction. +${bounty} caps, +rep, +XP.`);
        }
      }
    },
    {
      label: "Scout dangerous territory",
      run: () => {
         // Chance of hostile wildlife
        if (maybeStartCombat(0.30, "wastes", "faction")) return;
        const find = rnd(1,100) < 40;
        if (find) {
          const loot = money(1.0) + 3;
          state.caps += loot;
          gainXP(10);
          changeRep(+2);
          log(`You map new ground and recover salvage. +${loot} caps, +rep, +XP.`);
        } else {
          damage(5);
          gainXP(6);
          log("You blunder into a mutant nest. HP -5, +XP.");
        }
      }
    },
    {
      label: "Train recruits",
      run: () => {
        changeRep(+4);
        gainXP(14);
        log("You drill fresh recruits in marksmanship and survival. +rep, +XP.");
      }
    }
  ],

  scribes: [
    {
      label: "Research pre-war schematics",
      run: () => {
        if (skillCheck("I",12)) {
          gainXP(16);
          changeRep(+3);
          log("Breakthrough! +rep, +XP.");
        } else {
          log("You hit a dead end in the archives.");
        }
      }
    },
    {
      label: "Field retrieval (hot zone)",
      run: () => {
         // Retrievals can pull a fight (ghouls/vermin)
        if (maybeStartCombat(0.35, "wastes", "faction")) return;
        if (skillCheck("E",12)) {
          addItem("holotape",1);
          gainXP(14);
          changeRep(+4);
          log("Recovered an intact holotape. +rep, +XP.");
        } else {
          rad(8);
          log("Radiation pockets slow you. RAD +8.");
        }
      }
    },
    {
      label: "Repair salvaged tech",
      run: () => {
        if (skillCheck("I",13)) {
          const reward = money(1.2) + 4;
          state.caps += reward;
          gainXP(12);
          changeRep(+2);
          log(`You restore a working device. +${reward} caps, +rep, +XP.`);
        } else {
          log("Your repair attempt fails — components fried.");
        }
      }
    },
    {
      label: "Teach wastelanders literacy",
      run: () => {
        gainXP(10);
        changeRep(+5);
        changeKarma(+2);
        log("You hold lessons in reading and history. +rep, +karma, +XP.");
      }
    }
  ],

  dust_marauders: [
    {
      label: "Shakedown a toll post",
      run: () => {
          // Sometimes enforcers show up to stop you
        if (maybeStartCombat(0.25, "rangers", "faction")) return;
        const haul = money(1.4);
        state.caps += haul;
        changeRep(+4);
        changeKarma(-6);
        log(`Your cut from the tolls: +${haul} caps. Karma -6, +rep.`);
      }
    },
    {
      label: "Raid a convoy",
      run: () => {
          // Often becomes a battle
        if (maybeStartCombat(0.60, "Dust_Marauders", "faction")) return;
        const fail = !skillCheck("S",12) || !skillCheck("A",12);
        if (fail) {
          damage(12);
          log("The guards were ready. HP -12.");
          changeRep(-1);
        } else {
          const loot = money(1.8);
          state.caps += loot;
          gainXP(16);
          changeRep(+6);
          changeKarma(-8);
          log(`Convoy cracked. +${loot} caps, +rep, Karma -8, +XP.`);
        }
      }
    },
    {
      label: "Extort a settlement",
      run: () => {
         // Sometimes defenders push back
        if (maybeStartCombat(0.30, "settlers", "faction")) return;
        const payout = money(1.2) + 8;
        state.caps += payout;
        changeRep(+5);
        changeKarma(-10);
        gainXP(12);
        log(`The settlers pay up. +${payout} caps, +rep, Karma -10, +XP.`);
      }
    },
    {
      label: "Pit fight",
      run: () => {
          // Rarely, a rival champion steps in (treated as Dust_Marauders tier)
        if (maybeStartCombat(0.20, "Dust_Marauders", "faction")) return;
        const win = skillCheck("S",13) || skillCheck("A",13);
        if (win) {
          const prize = money(1.5) + 5;
          state.caps += prize;
          changeRep(+3);
          gainXP(14);
          changeKarma(-4);
          log(`You win the brawl. +${prize} caps, +rep, Karma -4, +XP.`);
        } else {
          damage(10);
          log("You get beaten bloody in the pit. HP -10.");
        }
      }
    }
  ]
}; // <-- end FACTION_ACTIONS


// ── Faction Ranks ───────────────────────────────
const FACTION_RANKS = [
  { min: 0,  name: "Outsider" },
  { min: 20, name: "Associate" },
  { min: 50, name: "Member" },
  { min: 80, name: "Trusted" },
  { min: 100,name: "Champion" }
];

function factionRank(rep){
  let r = "Outsider";
  for (const tier of FACTION_RANKS){
    if (rep >= tier.min) r = tier.name;
  }
  return r;
}


  // NOTE: Right now factionRep is a single number
  // To implement tiers: check thresholds here and log tier-up messages
function changeRep(n){
  if (typeof state.factionRep !== "number") state.factionRep = 0;
  state.factionRep = clamp(state.factionRep + n, -100, 100);
}





/* ========= Actions ========= */
// NOTE: Core buttons (Age Up, Explore, Work, Heal)
// - Add new player action functions here

function ageUp(){
  if (!state.alive) return;
  state.age += 1; state.year += 1;

  // yearly upkeep: job pay; hunger/rad decay
  const job = getJob();
  if (job.id!=="none"){
    let pay = (typeof job.base === "number" ? job.base : job.base()) + Math.round(state.special.C * 1.5);
    if (state.perks.includes("silverTongue")) pay = Math.round(pay*1.15);
    state.caps += pay;
    log(`Your ${job.name} income: +${pay} caps.`);
  }
  derad(3);
  heal(3);

  // birthday note
  log(`You turned ${state.age}.`, "muted");

  yearlyEvent();
  gainXP(10);
  tickBuffs("action");
}



function work(){
  if (!state.alive) return;

  /* ── Local helpers/data (scoped to this function) ───────────────── */

  // Risk + encounter profile per job
  const JOB_RISK = {
    scav:   { label: "Medium",       chance: 0.28, tier: "wastes"  },
    trader: { label: "Medium",       chance: 0.18, tier: "Dust_Marauders" },
    guard:  { label: "High",         chance: 0.45, tier: "Dust_Marauders" },
    scribe: { label: "Low",          chance: 0.08, tier: "wastes"  },
    med:    { label: "Medium-High",  chance: 0.22, tier: "work"    },
    none:   { label: "—",            chance: 0.00, tier: "wastes"  }
  };

  // Pay hint bands just for display on the board
  const PAY_HINTS = {
    scav:   [10, 10],
    trader: [20, 20],
    guard:  [30, 30],
    scribe: [20, 20],
    med:    [40, 40]
  };

  const jobRiskInfo = (jobId)=>
    JOB_RISK[jobId] || { label:"Medium", chance:0.20, tier:"work" };

  // Inline Job Board modal (only used from here)
  function openJobBoard(){
    const m = openModal("Job Board");
    m.content.append(
      el("p","small muted",
        "Higher pay usually means higher risk. Some jobs require certain S.P.E.C.I.A.L. scores."),
      el("div","hr")
    );

    const eligible = j => j.minAge <= state.age && j.req(state.special);

    JOBS
      .filter(j => j.id !== "none")
      .sort((a,b)=> (PAY_HINTS[b.id]?.[1]||0) - (PAY_HINTS[a.id]?.[1]||0))
      .forEach(j=>{
        const risk = jobRiskInfo(j.id);
        const pay  = PAY_HINTS[j.id] || [5,15];

        const row = el("div","kv");
        row.append(el("div", null, j.name));

        const right = el("div");
        right.append(
          el("div","small muted", `Pay: ~${pay[0]}–${pay[1]} caps/shift`),
          el("div","small muted", `Risk: ${risk.label} • Encounters ~${Math.round(risk.chance*100)}% • Tier: ${risk.tier}`)
        );

        const b = el("button","choice", eligible(j) ? "Take job" : "Locked (requirements not met)");
        b.disabled = !eligible(j);
        b.onclick = ()=>{
          state.job = j.id;
          log(`You take a position as ${j.name}.`);
          updateUI();
          closeModal();
        };

        right.append(b);
        row.append(right);
        m.content.append(row, el("div","hr"));
      });

    const closeRow = el("div","kv");
    closeRow.append(el("div", null, ""));
    const closeBox = el("div");
    const later = el("button","choice","Not now");
    later.onclick = closeModal;
    closeBox.append(later);
    closeRow.append(closeBox);
    m.content.append(closeRow);
  }

  /* ── Main flow ──────────────────────────────────────────────────── */

  const job = getJob();

  // If jobless, show the inline Job Board and return
  if (!job || job.id === "none"){
    openJobBoard();
    return;
  }

  // Use risk profile to gate encounters (higher pay → more danger)
  const risk = jobRiskInfo(job.id);
  if (maybeStartCombat(risk.chance, risk.tier, job.id)) return;

  // Base pay (handles number or function)
  let basePay = 5;
  try {
    if (typeof job.base === "number") basePay = job.base;
    else if (typeof job.base === "function") basePay = job.base();
  } catch(e){ console.warn("Job base pay missing:", job, e); }

// No CHA or perk bonus
// basePay stays as job.base

  addCaps(basePay);

  // Performance by job
  const prod = rnd(0,100)
             + (state.special.E || 0)
             + (state.special.C || 0)
             + (state.perks?.includes("silverTongue") ? 10 : 0);

  try {
    switch(job.id){
      case "guard": {
        if (prod > 80){
          const bonus = rnd(3,6);
          addCaps(bonus); gainXP(12);
          log(`Steady duty on the wall. Pay +${basePay}, hazard bonus +${bonus}. XP +12.`);
        } else if (prod > 50){
          gainXP(8);
          log(`Uneventful watch. Pay +${basePay}. XP +8.`);
        } else {
          damage(10); gainXP(5);
          log(`Skirmish at the gate. Pay +${basePay}, HP -10. XP +5.`);
        }
        break;
      }
      case "scav": {
        if (prod > 85){
          const find = rnd(0,100) < 50 ? "duct_tape" : "junk";
          addItem(find, 1); gainXP(10);
          log(`Scav run pays +${basePay}. You also find a ${ITEMS[find].name}! XP +10.`);
        } else {
          rad(5); gainXP(6);
          log(`Dirty work. Pay +${basePay}, RAD +5. XP +6.`);
        }
        break;
      }
      case "trader": {
        if (prod > 75){
          const tip = rnd(2,5);
          addCaps(tip); gainXP(10);
          log(`Good trading day. Pay +${basePay}, tips +${tip}. XP +10.`);
        } else {
          gainXP(6);
          log(`Slow market day. Pay +${basePay}. XP +6.`);
        }
        break;
      }
      case "scribe": {
        if (prod > 75){
          gainXP(12);
          log(`Repairing and cataloging yields insights. Pay +${basePay}. XP +12.`);
        } else {
          gainXP(6);
          log(`Archive grind. Pay +${basePay}. XP +6.`);
        }
        break;
      }
      case "med": {
        if (prod > 80){
          gainXP(14);
          log(`You handle a tough case. Pay +${basePay}. XP +14.`);
        } else {
          gainXP(8);
          log(`Routine field care. Pay +${basePay}. XP +8.`);
        }
        break;
      }
      default: {
        if (prod > 80){ gainXP(8); log(`Steady shift as ${job.name}. Pay +${basePay}. XP +8.`); }
        else { gainXP(5); log(`Long shift as ${job.name}. Pay +${basePay}. XP +5.`); }
      }
    }
  } catch(err){
    console.error("Error inside job branch:", err, job);
  }

  // Small chance to find scrap
  if (rnd(1,100) > 95){ addItem("junk", 1); log("On your break, you salvage some scrap. +1 junk."); }

  tickBuffs("action");
  updateUI();
}


function healAction(){
  if (!state.alive) return;
  const cost = 12;
  if (state.caps < cost){
    log("Not enough caps for supplies. You improvise. HP +3, RAD -1.");
    heal(3); derad(1);
    return;
  }
  state.caps -= cost;
  let h = 15, r = 8;
  if (state.perks.includes("medic")){ h += 5; r += 4; }
  heal(h); derad(r);
  log(`You patch up and detox. HP +${h}, RAD -${r}.`);
}


function explore(){
  if (!state.alive) return;
  // 35% chance to get a combat encounter while exploring
  if (maybeStartCombat(0.35, "wastes", "explore")) { return; }


  const roll = rnd(1,100) + state.special.L;

  // rare weapon find
  if (roll > 98){
    addItem("knife", 1);
    log("Jackpot! You find a serviceable combat knife.");
    gainXP(12);
  }
  // uncommon duct tape find
  else if (roll > 92){
    addItem("duct_tape", 1);
    log("Score! You salvage a roll of duct tape.");
    gainXP(8);
  }
  // common junk find
    else if (roll > 75){
    const n = rnd(1, 3); // make sure rnd is inclusive
    // If your rnd is exclusive, use: Math.floor(Math.random()*3)+1
    addItem("junk", n);
    log(`You scavenge useful junk. +${n} junk.`);
    gainXP(6);
   }
  // barter scrap for caps (no items)
  else if (roll > 55){
    const amt = money(0.8);
    state.caps += amt;
    log(`You find scrap and barter it. +${amt} caps.`);
    gainXP(6);
  }
  else if (roll > 35){
    log("Quiet day. You map some ruins. XP +6.");
    gainXP(6);
  }
  else if (roll > 20){
    rad(5);
    log("Irradiated puddles slow you. RAD +5.");
  }
  else {
    damage(10);
    log("Wild dogs attack. HP -10.");
  }
  updateUI;
}

function openInventory(){
  migrateInventoryShape();
  const m = openModal("Inventory");

  // ── Equipment panel ───────────────────────────────────────────────
  const eqTitle = el("div","title"); 
  eqTitle.textContent = "Equipment";
  m.content.append(eqTitle);

  // Show total bonuses from equipped gear
  const { atk=0, def=0 } = calcStats();
  const statRow = el("div","kv");
  statRow.append(el("div", null, "Bonuses"));
  statRow.append(el("div", "small", `ATK +${atk} / DEF +${def}`));
  m.content.append(statRow, el("div","hr"));

  // Per-slot rows
  ["head","chest","legs","weapon"].forEach(slot=>{
    const row = el("div","kv");
    const label = slot[0].toUpperCase() + slot.slice(1);
    row.append(el("div", null, label));

    const d = el("div");
    const id = state.equipment[slot];
    if (id){
      const meta = ITEMS[id] || { name:id };
      d.append(el("div", null, meta.name || id));
      if (meta.desc) d.append(el("div","small muted", meta.desc));

      const u = el("button","choice");
      u.textContent = "Unequip";
      u.onclick = ()=>{ unequip(slot); openInventory(); };
      d.append(u);
    } else {
      d.append(el("div","small muted","(empty)"));
    }

    m.content.append(row, d, el("div","hr"));
  });

  // ── Inventory list ────────────────────────────────────────────────
  const invTitle = el("div","title"); 
  invTitle.textContent = "Inventory";
  m.content.append(invTitle);

  if (!inv().length){
    m.content.append(el("p","muted","(empty)"));
  } else {
    inv().forEach(s => {
      const meta = ITEMS[s.id] || { name: s.id };
      const row = el("div","kv");
      row.append(el("div", null, `${meta.name || s.id} ×${s.qty}`));
      const actions = el("div");

      if (meta.desc) actions.append(el("div","small muted", meta.desc));

      // Use (if usable)
      if (meta.use){
        const b = el("button","choice","Use");
        b.onclick = () => { useItem(s.id); openInventory(); };
        actions.append(b);
      }

      // Equip (if equippable)
      if (meta.slot){
        const eqBtn = el("button","choice","Equip");
        eqBtn.onclick = () => { equipItem(s.id); openInventory(); };
        actions.append(eqBtn);
      }

      // Simple sell example
      if (s.id === "holotape"){
        const sell = el("button","choice","Sell (20 caps)");
        sell.onclick = () => {
          removeItem("holotape",1);
          state.caps += 20;
          log("Sold an Ancient Holotape for 20 caps.");
          updateUI();
          openInventory();
        };
        actions.append(sell);
      }

      // Drop
      const drop = el("button","choice","Drop");
      drop.onclick = () => { removeItem(s.id,1); log(`Dropped 1 ${meta.name || s.id}.`); updateUI(); openInventory(); };
      actions.append(drop);

      m.content.append(row, actions, el("div","hr"));
    });
  }

  // ── Crafting section ──────────────────────────────────────────────
  const craftTitle = el("div","title"); 
  craftTitle.textContent = "Crafting";
  m.content.append(craftTitle);

  let any = false;
  RECIPES.forEach(r => {
    const can = hasItems(r.requires);
    const row = el("div","kv");
    row.append(el("div", null, r.name));
    const d = el("div");
    d.append(el("div","small muted", r.desc));
    const b = el("button","choice"); 
    b.textContent = can ? "Craft" : "Missing reqs";
    b.disabled = !can;
    b.onclick = () => { craft(r.id); openInventory(); };
    d.append(b);
    m.content.append(row, d, el("div","hr"));
    any = true;
  });

  if (!any) m.content.append(el("p","muted","No recipes known."));
}



// ========= Faction Menu =========
// If no faction → list joinable ones.
// If in a faction → show actions, reputation, rank (and allow leaving).
function openJoinFaction(){
  // Not in a faction yet: show join list
  if (state.faction === "none") {
    const m = openModal("Factions");
    const canJoin = FACTIONS.filter(f => f.id !== "none" && f.req(state.special));
    if (!canJoin.length){
      m.content.append(el("p", null, "No one’s recruiting you right now. Train up!"));
      return;
    }
    canJoin.forEach(f => {
      const row = el("div", "kv");
      row.append(el("div", null, f.name));
      const d = el("div");
      d.append(el("div","small muted", f.blurb));
      const b = el("button","choice","Join");
      b.onclick = () => {
        state.faction = f.id;
        state.factionRep = 0;
        log(`You joined ${f.name}.`);
        updateUI();
        closeModal();
      };
      d.append(b);
      m.content.append(row, d, el("div","hr"));
    });
    return;
  }

  // Already in a faction: show personalized actions
  const f = getFaction();
  const m = openModal(`${f.name}`);

  // ── Header block
  const header = el("div","faction-header " + f.id);
  header.innerHTML = `
    <div class="title">${f.name}</div>
    <div class="small muted">${f.blurb}</div>
  `;
  m.content.append(header);

  // ── Reputation bar + rank
  const infoRow = el("div","kv");
  infoRow.append(el("div", null, "Reputation"));
  const bar = el("div","rep-bar");
  const fill = el("i");
  fill.style.width = clamp(state.factionRep, 0, 100) + "%";
  bar.append(fill);
  infoRow.append(bar);
  m.content.append(infoRow);

  const rankRow = el("div","kv");
  rankRow.append(el("div", null, "Rank"));
  rankRow.append(el("div","small muted", factionRank(state.factionRep)));
  m.content.append(rankRow, el("div","hr"));

  // ── Actions
  const actions = FACTION_ACTIONS[state.faction] || [];
  if (!actions.length) {
    m.content.append(el("p","muted","No special actions available right now."));
  } else {
    actions.forEach(a => {
      const box = el("div","faction-action");
      box.append(el("div","label", a.label));
      const b = el("button","choice","Do it");
      b.onclick = () => {
        try { a.run(); } catch(e){ console.error(e); log("Action failed.","muted"); }
        updateUI();
        closeModal();
      };
      box.append(b);
      m.content.append(box);
    });
  }

  // --- Campaign (Settlers only) ---
  if (state.faction === "settlers") {
    const box = el("div","faction-action");
    box.append(el("div","label", "Settlers Campaign"));
    const b = el("button","choice","Open Campaign");
    b.onclick = openSettlersCampaign;
    box.append(b);
    m.content.append(box);
  }

  // ── Leave faction (danger zone) at bottom
  m.content.append(el("div","hr"));
  const leaveRow = el("div","kv");
  leaveRow.append(el("div", null, "Leave faction"));
  const leaveBox = el("div");
  const leaveBtn = el("button","choice dangerous","Leave");
  leaveBtn.onclick = () => {
    const name = f.name;
    if (confirm(`Leave ${name}? You’ll lose your reputation with them.`)) {
      state.faction = "none";
      state.factionRep = 0;
      log(`You left ${name}.`);
      updateUI();     // updates pill and changes sidebar text to "Join a Faction"
      closeModal();
    }
  };
  leaveBox.append(leaveBtn);
  leaveRow.append(leaveBox);
  m.content.append(leaveRow);
}


 // ========= Perks Menu =========
  // NOTE: Unlock perks here
  // Add new perks in PERKS array above

function openPerks(){
  const m = openModal("Perks");
  const owned = el("p","small muted","Owned: "+(state.perks.map(p=>PERKS.find(x=>x.id===p)?.name).filter(Boolean).join(", ") || "none"));
  m.content.append(owned, el("div","hr"));
  PERKS.forEach(p=>{
    const ok = p.req(state);
    const row = el("div","kv");
    row.append(el("div",null,p.name));
    const d = el("div");
    d.append(el("div","small muted", p.desc));
    const b = el("button","choice"); b.textContent = state.perks.includes(p.id) ? "Owned" : (ok ? "Unlock (1 perk point)" : "Locked");
    b.disabled = state.perks.includes(p.id) || !ok || (perkPoints()<=0);
    b.onclick=()=>{ if (perkPoints()>0){ state.perks.push(p.id); log(`Perk unlocked: ${p.name}.`); updateUI(); openPerks(); } };
    d.append(b);
    m.content.append(row,d,el("div","hr"));
  });
  const footer = el("p","small muted", `Perk Points: ${perkPoints()}`);
  m.content.append(footer);
}

function perkPoints(){ return Math.floor(state.level/3) - state.perks.length; }

/* ===================== Settlers Campaign (branching) ===================== */
function ensureCampaignState(){
  if (!state.campaign) state.campaign = {};
  if (!state.campaign.settlers)
    state.campaign.settlers = { chapter: 0, flags:{}, ending: null, title: "Dustford Rising" };
}

function openSettlersCampaign(){
  ensureCampaignState();
  const c = state.campaign.settlers;
  const m = openModal(`Settlers Campaign — ${c.title}`);

  // Header / status
  const head = el("div","kv");
  head.append(el("div",null,"Status"));
  head.append(el("div","small muted",
    c.ending ? `Completed: ${c.ending}` : `Chapter ${c.chapter+1}/5`));
  m.content.append(head, el("div","hr"));

  // If finished, show summary only (no replay/reset)
  if (c.ending){
    const doneRow = el("div","kv");
    doneRow.append(el("div", null, "Campaign"));
    const note = el("div");
    note.append(el("div","small muted","Completed — not replayable."));
    doneRow.append(note);
    m.content.append(doneRow);

    if (Object.keys(c.flags).length){
      m.content.append(el("div","hr"));
      const flags = el("p","small muted", "Your key choices: " +
        Object.keys(c.flags).map(k=>`${k}=${c.flags[k]}`).join(", "));
      m.content.append(flags);
    }
    return; // no start/continue button when completed
  }

  // Start / continue button (only if not completed)
  const startRow = el("div","kv");
  startRow.append(el("div",null,"Continue"));
  const startBox = el("div");
  const startBtn = el("button","choice", `Begin Chapter ${c.chapter+1}`);
  startBtn.onclick = ()=>{ closeModal(); runSettlersChapter(); };
  startBox.append(startBtn);
  startRow.append(startBox);
  m.content.append(startRow);

  // Small log of key flags (optional)
  if (Object.keys(c.flags).length){
    m.content.append(el("div","hr"));
    const flags = el("p","small muted", "Choices so far: " +
      Object.keys(c.flags).map(k=>`${k}=${c.flags[k]}`).join(", "));
    m.content.append(flags);
  }
}

function runSettlersChapter(){
  ensureCampaignState();
  const c = state.campaign.settlers;
  const ch = c.chapter;

  // Guard: must be in the Settlers faction
  if (state.faction !== "settlers"){
    setChoice("You must be a Settlers Union member to undertake this campaign.", [
      { label:"Okay", run:()=>{} }
    ]);
    return;
  }

  // Guard: campaign is one-time only
  if (c.ending){
    setChoice("The Settlers campaign is already complete and cannot be replayed.", [
      { label:"OK", run:()=>{} }
    ]);
    return;
  }

  // CHAPTERS 0..4 then Ending
  if (ch === 0){
    setChoice("Ch.1 — Caravan Contract: A Dustford caravan needs an escort. Which route do you choose?", [
      { label:"Direct through the salt flats (E check, faster, riskier)",
        run:()=>{
          const ok = skillCheck("E",12);
          c.flags.route = "direct";
          if (ok){ changeRep(+3); gainXP(12); state.caps += money(1.0); log("Efficient run. You dodge the worst of it. +rep, +XP, +caps."); }
          else { damage(6); rad(6); changeRep(+2); gainXP(8); log("Rough crossing. You still deliver. HP -6, RAD +6, +rep."); }
          c.chapter++; updateUI();
        } },
      { label:"Back roads (safer, slower, lower payout)",
        run:()=>{
          c.flags.route = "back";
          changeRep(+3); gainXP(10); state.caps += money(0.6);
          log("Long way round. Fewer scrapes, lighter purse. +rep, modest caps.");
          c.chapter++; updateUI();
        } },
      { label:"Decline the job (Karma +2, but Union takes note)",
        run:()=>{
          c.flags.route = "decline";
          changeKarma(+2); changeRep(-2); log("You pass. The caravan finds other guards. Karma up; reputation dips.");
          c.chapter++; updateUI();
        } },
    ]);
    return;
  }

  if (ch === 1){
    setChoice("Ch.2 — Where to Invest: Dustford needs funds. Where do you push resources?", [
      { label:"Fortify the palisade (-10 caps, +rep)",
        run:()=>{
          if (state.caps < 10){ log("Not enough caps to fund the wall."); return; }
          state.caps -= 10; c.flags.walls = 1; changeRep(+4); gainXP(10);
          log("You organize lumber and braces. The wall stiffens. +rep.");
          c.chapter++; updateUI();
        } },
      { label:"Repair the water plant (-10 caps, +rep, better recovery)",
        run:()=>{
          if (state.caps < 10){ log("Not enough caps to fix the plant."); return; }
          state.caps -= 10; c.flags.water = 1; changeRep(+3); gainXP(10);
          log("Clean water flows steadier. Spirits rise. +rep.");
          c.chapter++; updateUI();
        } },
      { label:"Split resources (-16 caps total, modest both)",
        run:()=>{
          if (state.caps < 16){ log("You need 16 caps to split effectively."); return; }
          state.caps -= 16; c.flags.walls = 1; c.flags.water = 1; changeRep(+4); gainXP(12);
          log("Tight budget, but both projects improve. +rep.");
          c.chapter++; updateUI();
        } },
    ]);
    return;
  }

  if (ch === 2){
    setChoice("Ch.3 — A Knife in the Dark: Dust Marauder scouts probe the outskirts. Your approach?", [
      { label:"Ambush them (A check)",
        run:()=>{
          const ok = skillCheck("A",12);
          c.flags.ambush = ok ? "clean" : "messy";
          if (ok){ changeRep(+4); gainXP(12); log("Swift and clean. They scatter. +rep."); }
          else { damage(8); changeRep(+2); gainXP(8); log("You win, but not without cuts. HP -8, +rep."); }
          c.chapter++; updateUI();
        } },
      { label:"Shadow and warn the town (P check, +karma)",
        run:()=>{
          const ok = skillCheck("P",12);
          c.flags.warned = !!ok;
          changeKarma(+2);
          if (ok){ changeRep(+3); gainXP(12); log("You track them and alert the watch. +rep, +karma."); }
          else { changeRep(+1); gainXP(8); log("You lose the trail, but the warning helps a little. +rep."); }
          c.chapter++; updateUI();
        } },
      { label:"Attempt a parley (C check, big swing)",
        run:()=>{
          const ok = skillCheck("C",13);
          c.flags.truce = !!ok;
          if (ok){ changeRep(+2); changeKarma(+5); gainXP(14); log("A fragile understanding—no blood tonight. +karma."); }
          else { changeRep(-2); damage(6); log("Talks sour. Word spreads you were duped. HP -6, rep down."); }
          c.chapter++; updateUI();
        } },
    ]);
    return;
  }

  if (ch === 3){
    setChoice("Ch.4 — The Eve: The town prepares. How do you spend the day?", [
      { label:"Train militia (+rep, +XP)",
        run:()=>{
          c.flags.militia = 1; changeRep(+3); gainXP(14);
          log("You drill townsfolk until sundown. +rep, +XP.");
          c.chapter++; updateUI();
        } },
      { label:"Lay traps (cost: 2 Junk + 1 Duct Tape)",
        run:()=>{
          if (countItem("junk")>=2 && countItem("duct_tape")>=1){
            removeItem("junk",2); removeItem("duct_tape",1);
            c.flags.traps = 1; changeRep(+3); gainXP(12);
            log("Wire and pits along likely routes. +rep, +XP.");
            c.chapter++; updateUI();
          } else {
            log("You need 2× Junk and 1× Duct Tape.");
          }
        } },
      { label:"Stock granary (-10 caps, improves endurance)",
        run:()=>{
          if (state.caps < 10){ log("Not enough caps for supplies."); return; }
          state.caps -= 10; c.flags.stock = 1; gainXP(10); changeRep(+2);
          log("You shore up food stores and medicine. +rep.");
          c.chapter++; updateUI();
        } },
    ]);
    return;
  }

  if (ch === 4){
    // Finale — compute ending
    const end = settlersFinale();
    setChoice(`Ch.5 — The Dustford Crisis: ${end.title}`, [
      { label:"Acknowledge outcome", run:()=>{
        // rewards already granted in settlersFinale
        state.campaign.settlers.ending = end.key;
        c.chapter++; updateUI();
      } }
    ]);
    return;
  }

  // Safety: if somehow called again after completion
  setChoice("The Settlers campaign is complete.", [
    { label:"OK", run:()=>{} }
  ]);
}

function settlersFinale(){
  const f = state.campaign.settlers.flags || {};
  // Score prep
  let score = 0;
  if (f.walls) score += 1;
  if (f.water) score += 1;
  if (f.traps) score += 1;
  if (f.militia) score += 1;
  if (f.stock) score += 1;
  if (f.warned) score += 1;
  if (f.route === "direct") score += 1;      // bold earlier choice helps
  if (f.route === "decline") score -= 1;
  if (f.ambush === "clean") score += 1;
  if (f.ambush === "messy") score -= 1;
  if (f.truce) score += 2;                   // strong alternate path

  // Branches / endings
  // 1) Pacifist accord (truce true) — special coat
  if (f.truce){
    changeRep(+12); changeKarma(+6); gainXP(30);
    addItem("diplomats_coat", 1);
    log("Ending: The Accord — A fragile ceasefire routes Dust Marauders away from Dustford.");
    log("Reward: Diplomat’s Coat (+4 DEF, +2 AGI), big reputation, XP.", "muted");
    updateUI();
    return { key:"Accord", title:"A fragile ceasefire holds." };
  }

  // 2) Strong defense — clear victory
  if (score >= 6){
    changeRep(+15); gainXP(40); state.caps += money(1.6);
    addItem("settlers_carbine", 1); addItem("settlers_coat", 1);
    log("Ending: Secure Settlement — The traps spring, militia holds, walls stand.");
    log("Rewards: Settlers Carbine & Union Field Coat, +rep, +caps, +XP.", "muted");
    updateUI();
    return { key:"Secure Settlement", title:"Dustford stands strong." };
  }

  // 3) Narrow win — pyrrhic
  if (score >= 3){
    changeRep(+8); gainXP(25); state.caps += money(1.0);
    damage(8); // cost of victory
    log("Ending: Pyrrhic Victory — The town survives, but it hurts. HP -8.", "muted");
    updateUI();
    return { key:"Pyrrhic", title:"The town survives at a cost." };
  }

  // 4) Evacuation — fallback ending
  changeRep(+5); gainXP(18);
  addItem("food", 2); addItem("med_patch", 1);
  log("Ending: Caravan Exodus — You organize a retreat to fight another day. Supplies gained.");
  updateUI();
  return { key:"Exodus", title:"Orderly retreat under your lead." };
}



/* ========= Modal ========= */
function openModal(title){
  $("#modal-title").textContent = title;
  $("#modal-content").innerHTML = "";
  $("#modal-backdrop").style.display = "grid";
  return { content: $("#modal-content") };
}
function closeModal(){ $("#modal-backdrop").style.display="none"; }
$("#modal-close").onclick = closeModal;
$("#modal-backdrop").addEventListener("click", e=>{
  if (e.target.id==="modal-backdrop") closeModal();
});

/* ========= Combat Helpers ========= */

// e.g. chance(0.3) or chance(30)
function chance(p){ if (p > 1) p = p / 100; return Math.random() < p; }

function maybeStartCombat(prob = 0.3, tier = "wastes", source = "misc"){
  if (Math.random() < prob){
    const enemy = generateEnemy(tier || "wastes");
    openCombat(enemy, { source });
    return true;
  }
  return false;
}

function playerBattleStats(){
  const S  = state.special || {S:5,P:5,E:5,C:5,I:5,A:5,L:5};
  const eq = calcStats();

  let atk  = 2 + Math.floor(S.S/2) + Math.floor(S.P/4) + Math.floor(state.level/2);
  let def  = Math.floor(S.E/2) + Math.floor(S.A/4) + (eq.def || 0);
  let spd  = 8 + S.A + Math.floor(state.level/3) + (eq.agi || 0);
  let crit = clamp(0.03 + (S.L * 0.005) + (eq.crit || 0), 0, 0.5);

  const turns = v => (typeof v === "object" ? (v?.turns||0) : (v||0));
  if (turns(state.buffs?.strEnd)  > 0) { atk += 1; def += 1; }
  if (turns(state.buffs?.percInt) > 0) { crit += 0.01; }

  return { atk, def, spd, crit };
}







/* ========= Save/Load ========= */
// NOTE: Saves state into localStorage
// - If you add new state fields, they’ll be saved automatically

function save(){
  try {
    localStorage.setItem("wastelife-save", JSON.stringify(state));
    info("Game saved.");
  } catch (e) {
    console.error(e);
    log("Save failed (storage full or blocked).","muted");
  }
}

function load(){
  const raw = localStorage.getItem("wastelife-save");
  if (!raw){ info("No save found."); return; }

  try {
    // parse and assign
    state = JSON.parse(raw);
 
     ensureCampaignState();

    // --- backfill for older saves ---
    if (!state.equipment) state.equipment = { head:null, chest:null, legs:null, weapon:null };
    if (!Array.isArray(state.inventory)) state.inventory = [];
    if (typeof state.factionRep !== "number") state.factionRep = 0;
    if (!Array.isArray(state.perks)) state.perks = [];
    if (!Array.isArray(state.log)) state.log = [];
    if (!state.buffs) state.buffs = { radShield:{turns:0}, fleeBoost:0, atkBoost:0, strEnd:0, percInt:0 };
    // migrate very old saves that used a number
    if (typeof state.buffs.radShield === "number") {
    state.buffs.radShield = { turns: Number(state.buffs.radShield) || 0 };
}



    // migrate any old inventory formats
    migrateInventoryShape();

    info("Save loaded.");
    updateUI();
  } catch(e){
    console.error(e);
    log("Save file corrupted.","muted");
  }
}

function migrateInventoryShape(){
  if (!Array.isArray(state.inventory)) state.inventory = [];

  const normalized = [];

  const pushStack = (id, qty=1) => {
    id = slugify(id);
    qty = Number(qty) || 1;
    const existing = normalized.find(s => s.id === id);
    if (existing) existing.qty += qty;
    else normalized.push({ id, qty });
  };

  // Old saves: array of strings
  if (state.inventory.some(x => typeof x === "string")) {
    const counts = {};
    state.inventory.forEach(x => {
      const id = slugify(x);
      counts[id] = (counts[id] || 0) + 1;
    });
    Object.entries(counts).forEach(([id,qty]) => pushStack(id, qty));
  } else {
    // Mixed / malformed shapes
    state.inventory.forEach(s => {
      if (typeof s === "string") pushStack(s, 1);
      else if (s && typeof s === "object") {
        if ("id" in s && "qty" in s) pushStack(s.id, s.qty);
        else {
          // objects like {junk:2, duct_tape:1}
          Object.entries(s).forEach(([k,v]) => pushStack(k, v));
        }
      }
    });
  }

  state.inventory = normalized;
}


function slugify(x){
  return String(x)
    .toLowerCase()
    .replace(/\[object\s*object\]/g, "object_object") // optional – before stripping
    .replace(/[^a-z0-9\s_]/g, "")                     // remove non-word chars
    .trim()
    .replace(/\s+/g, "_");
}

function reset(){
  if (confirm("Start a new run? Current progress will be lost unless saved.")) {
    newRun();
    $("#log").innerHTML = "";
  }
}

/* ========= Death ========= */
// NOTE: Called when player dies (HP 0, RAD 100, age 120)
// - You can expand death causes or add permadeath logs here

function die(){
  state.alive = false;
  const cause = state.hp<=0 ? "your injuries" : state.rad>=100 ? "radiation sickness" : "old age";
  log(`You died at age ${state.age} from ${cause}. Final caps: ${state.caps}. Karma: ${state.karma}.`, "muted");
  updateUI();
}

/* ========= Trade / Barter ========= */
// Base buy prices (caps) — tweak freely
// Base buy prices (caps) — tweak freely
const TRADE_BASE = {
  // Consumables & misc
  food: 6,
  med_patch: 18,
  antirad: 24,
  water_filter: 28,
  duct_tape: 7,
  junk: 4,
  canteen: 12,
  holotape: 20,
  rad_purge: 30,
  rad_shield: 26,
  battle_tonic: 22,
  bulk_tonic: 24,
  focus_pills: 20,
  stealth_field: 34,

  // Armor / clothing
  helmet: 30,
  armor: 60,
  boots: 24,
  settlers_coat: 80,
  diplomats_coat: 70,

  // Melee
  knife: 45,
  scrap_blade: 28,
  machete: 28,
  sledgehammer: 60,

  // Firearms (existing)
  revolver: 60,
  shotgun: 75,
  hunting_rifle: 85,

  // Firearms (new)
  pipe_pistol: 30,
  smg_9mm: 75,
  assault_rifle_556: 100,
  battle_rifle_762: 120,
  marksman_rifle: 110,
  lever_action_44: 95,
  machine_pistol_38: 55,
  laser_pistol: 95,
  laser_rifle: 135,
  settlers_carbine: 90,

  // Ammo
  ammo_38: 4,
  ammo_9mm: 5,
  shells_12g: 6,
  ammo_308: 10,
  ammo_556: 8,
  ammo_762: 9,
  ammo_44: 12,
  carbine_round: 7,
  energy_cell: 14
};


// Vendor stock generator (called per visit)
function genVendorStock(kind="Trader"){
  // id -> qty
  const stock = {};
  const put = (id, q)=>{ stock[slugify(id)] = (stock[slugify(id)]||0) + q; };
  const roll = (pct)=> rnd(1,100) <= pct;

  // ===== Core consumables (always some)
  put("food",        rnd(2,6));
  put("med_patch",   rnd(1,3));
  put("antirad",     rnd(1,2));
  put("duct_tape",   rnd(1,4));
  put("junk",        rnd(2,6));
  if (roll(35)) put("rad_purge",    rnd(1,2));
  if (roll(30)) put("rad_shield",   1);
  if (roll(35)) put("battle_tonic", rnd(1,2));
  if (roll(35)) put("bulk_tonic",   rnd(1,2));
  if (roll(35)) put("focus_pills",  rnd(1,2));
  if (roll(25)) put("stealth_field",1);
  if (roll(35)) put("water_filter", 1);
  if (roll(40)) put("canteen",      1);

  // ===== Armor / clothing (sometimes)
  if (roll(45)) put("helmet", 1);
  if (roll(35)) put("boots",  1);
  if (roll(30)) put("armor",  1);

  // Faction gear (rare)
  if (roll(10)) put("settlers_coat",   1);
  if (roll(10)) put("diplomats_coat",  1);

  // ===== Melee (common-ish)
  if (roll(55)) put("knife",        1);
  if (roll(45)) put("scrap_blade",  1);
  if (roll(40)) put("machete",      1);
  if (roll(30)) put("sledgehammer", 1);

  // ===== Firearms (rarity tiers)
  // basic
  if (roll(45)) put("pipe_pistol", 1);
  if (roll(35)) put("revolver",    1);
  if (roll(30)) put("shotgun",     1);
  if (roll(28)) put("hunting_rifle", 1);

  // mid
  if (roll(25)) put("machine_pistol_38", 1);
  if (roll(22)) put("smg_9mm",           1);
  if (roll(20)) put("assault_rifle_556", 1);
  if (roll(18)) put("marksman_rifle",    1);
  if (roll(16)) put("settlers_carbine",  1);

  // high-end
  if (roll(14)) put("battle_rifle_762",  1);
  if (roll(14)) put("lever_action_44",   1);
  if (roll(12)) put("laser_pistol",      1);
  if (roll(10)) put("laser_rifle",       1);

  // ===== Ammo (more plentiful)
  const ammoLots = [
    ["ammo_38",      [6,18]],
    ["ammo_9mm",     [6,18]],
    ["shells_12g",   [4,12]],
    ["ammo_308",     [4,10]],
    ["ammo_556",     [6,16]],
    ["ammo_762",     [5,14]],
    ["ammo_44",      [3,10]],
    ["carbine_round",[6,16]],
    ["energy_cell",  [3,9]]
  ];
  ammoLots.forEach(([id, [a,b]])=>{
    if (roll(75)) put(id, rnd(a,b));
  });

  // Occasional curios
  if (roll(25)) put("holotape", rnd(1,2));

  return { kind, stock, haggleCut: 0, visitedYear: state.year, sessionId: rnd(10000,99999) };
}


// Price calculator with Charisma/perk/faction/haggle
function tradePrice(id, mode, vendor){
  // mode: "buy" or "sell"
  const base = TRADE_BASE[id] || 10;
  // vendors buy cheaper than they sell
  let price = mode === "buy" ? base : Math.max(1, Math.round(base * 0.5));

  // charisma effect (~3% per point from 5)
  const cha = state.special?.C || 5;
  const chaAdj = 1 - ((cha - 5) * 0.03);
  price = Math.max(1, Math.round(price * chaAdj));

  // perk: Silver Tongue ~15% better
  if (state.perks?.includes("silverTongue")){
    price = Math.round(mode === "buy" ? price * 0.85 : price * 1.15);
  }

  // Settlers faction small discount with their caravans
  if (state.faction === "settlers" && vendor?.kind === "Caravan"){
    price = Math.round(mode === "buy" ? price * 0.95 : price * 1.05);
  }

  // one-time haggle cut for this vendor session (applies to buy only)
  if (mode === "buy" && (vendor?.haggleCut||0) > 0){
    price = Math.round(price * (1 - vendor.haggleCut));
  }

  return Math.max(1, price);
}

function openTrade(kind="Trader"){
  const vendor = genVendorStock(kind);

  const m = openModal(vendor.kind === "Caravan" ? "Caravan Trader" : "Trader");
  const head = el("div","kv");
  head.append(el("div", null, "Your Caps"));
  head.append(el("div", null, `${state.caps}`));
  m.content.append(head, el("div","hr"));

  // HAGGLE (once per visit, CHA check)
  const hagRow = el("div","kv");
  hagRow.append(el("div", null, "Haggle"));
  const hagBox = el("div");
  const hagBtn = el("button","choice","Try to Haggle");
  const hagNote = el("span","small muted","  (better buy prices this visit)");
  hagBtn.onclick = ()=>{
    // modest charisma check; Swift doesn't help here
    const ok = skillCheck("C", 12);
    if (ok){
      vendor.haggleCut = 0.10 + (state.perks.includes("silverTongue") ? 0.05 : 0);
      log("Your pitch lands. Prices down this visit.");
    } else {
      vendor.haggleCut = 0; // no penalty
      log("Trader shrugs. No deal.");
    }
    openTrade(kind); // re-render with new prices
  };
  // disable if already haggled
  if (vendor.haggleCut>0) { hagBtn.textContent = "Haggled ✓"; hagBtn.disabled = true; }
  hagBox.append(hagBtn, hagNote);
  hagRow.append(hagBox);
  m.content.append(hagRow, el("div","hr"));

  // Tabs: Buy / Sell
  let tab = state._tradeTab || "buy";
  const tabs = el("div","kv");
  tabs.append(el("div", null, "Mode"));
  const tbox = el("div");
  const buyBtn = el("button","choice", tab==="buy" ? "Buy ✓" : "Buy");
  const sellBtn = el("button","choice", tab==="sell" ? "Sell ✓" : "Sell");
  buyBtn.onclick = ()=>{ state._tradeTab="buy"; openTrade(kind); };
  sellBtn.onclick = ()=>{ state._tradeTab="sell"; openTrade(kind); };
  tbox.append(buyBtn, sellBtn);
  tabs.append(tbox);
  m.content.append(tabs, el("div","hr"));

  if (tab === "buy"){
    // BUY LIST
    const ids = Object.keys(vendor.stock).filter(id=>vendor.stock[id]>0);
    if (!ids.length){
      m.content.append(el("p","muted","(Trader is out of stock)"));
    } else {
      ids.sort();
      ids.forEach(id=>{
        const qty = vendor.stock[id];
        const meta = ITEMS[id] || { name:id };
        const row = el("div","kv");
        row.append(el("div",null, `${meta.name || id} ×${qty}`));
        const d = el("div");

        if (meta.desc) d.append(el("div","small muted", meta.desc));

        const p = tradePrice(id, "buy", vendor);
        const buy1 = el("button","choice", `Buy (${p} caps)`);
        buy1.onclick = ()=>{
          if (vendor.stock[id] <= 0){ log("Sold out."); return; }
          if (state.caps < p){ log("Not enough caps."); return; }
          state.caps -= p;
          vendor.stock[id]--;
          addItem(id, 1);
          log(`Bought 1 ${meta.name || id} for ${p} caps.`);
          updateUI(); openTrade(kind);
        };
        d.append(buy1);
        row.append(d);
        m.content.append(row, el("div","hr"));
      });
    }
  } else {
    // SELL LIST (your inventory, anything with a base price)
    migrateInventoryShape();
    const sellables = inv().filter(s => TRADE_BASE.hasOwnProperty(s.id) && s.qty>0);
    if (!sellables.length){
      m.content.append(el("p","muted","(You have nothing the trader wants.)"));
    } else {
      sellables.sort((a,b)=> (ITEMS[a.id]?.name||a.id).localeCompare(ITEMS[b.id]?.name||b.id));
      sellables.forEach(s=>{
        const meta = ITEMS[s.id] || { name:s.id };
        const row = el("div","kv");
        row.append(el("div",null, `${meta.name || s.id} ×${s.qty}`));
        const d = el("div");

        if (meta.desc) d.append(el("div","small muted", meta.desc));

        const p = tradePrice(s.id, "sell", vendor);
        const sell1 = el("button","choice", `Sell (+${p} caps)`);
        sell1.onclick = ()=>{
          if (countItem(s.id) <= 0) return;
          removeItem(s.id, 1);
          state.caps += p;
          // vendor gains it (optional)
          vendor.stock[s.id] = (vendor.stock[s.id]||0) + 1;
          log(`Sold 1 ${meta.name || s.id} for ${p} caps.`);
          updateUI(); openTrade(kind);
        };
        d.append(sell1);
        row.append(d);
        m.content.append(row, el("div","hr"));
      });
    }
  }

  // Footer tip
  m.content.append(el("p","small muted",
    vendor.haggleCut>0 ? "Haggled prices active for this visit." :
    "Tip: Charisma and Silver Tongue improve deals.")
  );
}

/* ========= Event Wiring ========= */
// NOTE: Buttons in HTML are connected to functions here
// - Add new button handlers if you add new buttons in HTML
$("#btn-age").onclick = ()=>{ if (!state.pendingChoice) ageUp(); };
$("#faction-pill-wrapper").onclick = () => {
  openJoinFaction();
};
$("#btn-explore").onclick = ()=>{ if (!state.pendingChoice) explore(); updateUI(); };
$("#btn-work").onclick = ()=>{ if (!state.pendingChoice) work(); updateUI(); };
$("#btn-heal").onclick = ()=>{ if (!state.pendingChoice) healAction(); updateUI(); };
$("#btn-trade").onclick = ()=> openTrade("Caravan");
$("#btn-inventory").onclick = ()=> openInventory();
$("#btn-join-faction").onclick = ()=> openJoinFaction();
$("#btn-perks").onclick = ()=> openPerks();

$("#btn-save").onclick = save;
$("#btn-load").onclick = load;
$("#btn-reset").onclick = reset;

// --- Boot & wiring ---
window.addEventListener("DOMContentLoaded", () => {
  // Start a new run (or replace with load(); if you want to auto-load)
  newRun();             // creates state and calls updateUI()
  ensureCampaignState(); // safe now that state exists

  // Main action buttons
  $("#btn-age").onclick = ageUp;
  $("#btn-explore").onclick = explore;
  $("#btn-work").onclick = work;
  $("#btn-heal").onclick = healAction;

  // Menus / modals
  $("#btn-inventory").onclick = openInventory;
  $("#btn-trade").onclick = () => openTrade("Trader");
  $("#btn-join-faction").onclick = openJoinFaction;
  $("#btn-perks").onclick = openPerks;

  // Save / load / reset
  $("#btn-save").onclick = save;
  $("#btn-load").onclick = () => { load(); ensureCampaignState(); updateUI(); };
  $("#btn-reset").onclick = reset;

  // Make the faction pill open the faction menu
  $("#faction-pill-wrapper").onclick = openJoinFaction;
});

/* ====== TEXT MAP + Wilderness Integration (fixed) ======================= */
(function(){
  if (window.WL_TextMap) return; // keep only one copy

  /* --- Data --- */
  const WORLD = [
    { id:"dustford", name:"Dustford",        type:"town", desc:"Hardy town around a recycler." },
    { id:"ironwood", name:"Ironwood",        type:"town", desc:"Frontier town by foundry + pines." },
    { id:"dunes",    name:"Wasteland Dunes", type:"wild", desc:"Scrub dunes. Storms hit." },
    { id:"ruins",    name:"Cracked Ruins",   type:"wild", desc:"Collapsed towers, salvage, rads." },
    { id:"flats",    name:"Salt Flats",      type:"wild", desc:"White wastes, smugglers run." },
    { id:"canyon",   name:"Red Canyons",     type:"wild", desc:"Tight passes, raiders." },
    { id:"swamp",    name:"Irrad. Swamp",    type:"wild", desc:"Glowing mire, vicious biters." },
  ];
  const TOWNS = { dustford:[], ironwood:[] }; // stub buildings

  /* Wilderness config */
  const WILD = {
    dunes:  { rad:0, ch:0.32, loot:[["junk",6],["duct_tape",3],["canteen",1],["food",2]], enemies:["sand_stalker","burrower_beetle","dune_scorpion"] },
    ruins:  { rad:2, ch:0.38, loot:[["junk",5],["duct_tape",4],["holotape",1],["energy_cell",2]], enemies:["feral","rebar_scavver","auto_turret_mk1"] },
    flats:  { rad:1, ch:0.28, loot:[["junk",4],["water_filter",1],["caps",2],["food",2]], enemies:["brine_tortoise","flat_wraith","smuggler_skiff"] },
    canyon: { rad:0, ch:0.35, loot:[["junk",3],["ammo_38",2],["shells_12g",1]], enemies:["cliff_raptor","rock_viper","marauder_lookout"] },
    swamp:  { rad:3, ch:0.40, loot:[["junk",3],["food",2],["antirad",2]], enemies:["bog_snapper","glow_mireling","skeeter_swarm"] },
  };

  /* --- Sidebar button --- */
  function $(s){ return document.querySelector(s); }
  function ensureMapBtn(){
    if ($("#btn-map")) return;
    const b = document.createElement("button");
    b.id = "btn-map";
    b.textContent = "Travel / Map";
    b.onclick = openWorld;
    (document.querySelector(".actions .group") || $(".actions") || document.body).appendChild(b);
  }

function openWorld(){
  const m = openModal("World Travel"), c = m.content;
  const here = state.location || "Unknown";

  // clear + header
  c.innerHTML = "";
  c.append(pSmall("You are at: " + here), hr());

  // towns
  c.append(section("Towns"));
  WORLD.filter(n => n.type === "town").forEach(n => c.append(worldRow(n)));

  // wilderness
  c.append(section("Wilderness"));
  WORLD.filter(n => n.type !== "town").forEach(n => c.append(worldRow(n)));
}

// ADD this tiny helper anywhere near your other helpers:
function section(titleText){
  const d = document.createElement("div");
  d.className = "title";
  d.textContent = titleText;
  return d;
}
  function worldRow(n){
    const r = kv();
    r.left.textContent = n.name;
    r.right.append(pSmall(n.desc));
    if (state.location === n.name) r.left.appendChild(tag("here"));
    const go = choice(state.location === n.name ? "—" : "Travel");
    go.disabled = (state.location === n.name);
    go.onclick = () => travelTo(n.id);
    r.right.append(go);
    return r.wrap;
  }

  /* --- Travel + region set --- */
  function travelTo(id){
    const n = WORLD.find(x => x.id === id); if (!n) return;
    if (typeof maybeStartCombat === "function" && maybeStartCombat(n.type==="town" ? 0.15 : 0.30, "wastes", "travel")) {
      closeModal(); return;
    }
    state.location = n.name;
    state.region   = (n.type === "wild") ? n.id : null;
    log("You travel to " + n.name + ".");
    updateUI();
    closeModal();
  }

  /* --- Explore override for wilderness --- */
  window.exploreCurrentRegion = function(){
    const id = state.region, r = WILD[id];
    if (!r){ log("Nothing special to explore here."); return; }
    if (r.rad) rad(r.rad);
    if (Math.random() < r.ch){ openCombat(genEnemy(id)); return; }
    const l = roll(r.loot); if (!l){ log("Nothing found."); return; }
    if (l === "caps"){ const amt = rnd(3,12); addCaps(amt); log("Found "+amt+" caps."); }
    else { addItem(l,1); log("Scavenged " + (ITEMS[l]?.name || l)); }
  };

  /* --- Helpers --- */
  function roll(tab){ if(!tab) return null; let tot=tab.reduce((s,[,w])=>s+w,0), r=Math.random()*tot; for(const [id,w] of tab){ if((r-=w)<=0) return id; } return null; }
  function genEnemy(region){
    const pool = WILD[region]?.enemies || [];
    const id   = pool[rnd(0, pool.length-1)];
    const e    = ENEMIES.find(x => x.id === id) || ENEMIES[0];
    return { ...e, curHP: e.hp }; // <-- fixed from `{.e,...}` bug
  }

  function kv(){ const w=document.createElement("div"); w.className="kv"; const a=document.createElement("div"), b=document.createElement("div"); w.append(a,b); return {wrap:w,left:a,right:b}; }
  function choice(t){ const b=document.createElement("button"); b.className="choice"; b.textContent=t; return b; }
  function hr(){ const d=document.createElement("div"); d.className="hr"; return d; }
  function pSmall(t){ const p=document.createElement("p"); p.className="small muted"; p.textContent=t; return p; }
  function tag(t){ const s=document.createElement("span"); s.className="pill"; s.textContent=t; return s; }

  ensureMapBtn();
  const _update = window.updateUI;
  window.updateUI = function(){ _update && _update(); ensureMapBtn(); };

  window.WL_TextMap = { world:WORLD, towns:TOWNS, openWorld, travelTo };
})();
</script>
<style>
  /* --- End-of-Battle Overlay — themed to Wastelife globals --- */
  /* Uses your existing :root vars:
     --bg --panel --accent --accent-dim --danger --warn --ok --text --muted --shadow --radius --mono --sans */

  /* Overlay + centering (hardened) */
  #wl-combat-end{
    position:fixed!important; inset:0!important;
    display:none; align-items:center; justify-content:center;
    z-index:2147483647!important;
    background:rgba(0,0,0,.6); /* match .modal-backdrop */
    font-family:var(--sans); color:var(--text);
  }
  #wl-combat-end.wl-show{ display:flex!important }
  #wl-combat-end *{ box-sizing:border-box }

  /* Modal — larger */
  #wl-combat-end .wl-modal{
    display:block!important;
    width:min(900px,98vw)!important; max-width:98vw; min-height:420px!important;
    background:var(--panel)!important;
    border:1px solid rgba(227,143,43,.28)!important; /* accent border */
    border-radius:var(--radius)!important;
    box-shadow:var(--shadow)!important;
    color:var(--text);
    overflow:hidden;
  }

  /* Header */
  #wl-combat-end .wl-hdr{
    padding:16px 18px!important;
    border-bottom:1px solid rgba(227,143,43,.28)!important;
    background:linear-gradient(180deg, rgba(26,21,18,1), rgba(26,21,18,.86))!important;
    display:flex!important; gap:12px; align-items:center;
  }
  #wl-combat-end .wl-icon{
    width:44px; height:44px; border-radius:12px;
    display:grid; place-items:center; font-weight:800;
    background:linear-gradient(180deg, rgba(227,143,43,.08), rgba(0,0,0,.25));
    border:1px solid rgba(227,143,43,.28);
    color:var(--accent);
    font-family:var(--mono);
    text-shadow:0 1px 0 rgba(0,0,0,.35);
  }
  #wl-combat-end .wl-ttl{
    margin:0; font-size:20px;
    font-family:var(--mono);
    color:var(--accent);
    letter-spacing:.5px;
    text-shadow:0 1px 0 rgba(0,0,0,.35);
  }
  #wl-combat-end .wl-sub{ margin:4px 0 0; color:var(--muted); font-size:13px }

  /* Body */
  #wl-combat-end .wl-body{ padding:22px 22px 8px!important }
  #wl-combat-end .wl-grid{ display:grid; grid-template-columns:1fr 1fr; gap:16px }

  /* Cards */
  #wl-combat-end .wl-card{
    background:linear-gradient(180deg, rgba(227,143,43,.06), rgba(0,0,0,.08));
    border:1px solid rgba(227,143,43,.28);
    border-radius:var(--radius);
    padding:14px;
  }
  #wl-combat-end .wl-card h4{
    margin:0 0 6px; font-size:12px; color:var(--muted); font-family:var(--mono)
  }
  #wl-combat-end .wl-big{ font-size:32px; font-weight:900; color:var(--text) }
  #wl-combat-end .wl-badge{
    padding:3px 8px; font-size:11px; border-radius:999px;
    background:linear-gradient(180deg, rgba(227,143,43,.08), rgba(0,0,0,.25));
    border:1px solid rgba(227,143,43,.28);
    color:var(--muted);
    font-family:var(--mono);
  }

  /* Loot chips */
  #wl-combat-end .wl-loot{ display:flex; gap:8px; flex-wrap:wrap }
  #wl-combat-end .wl-loot .wl-chip{
    font-size:12px; padding:6px 10px; border-radius:999px;
    background:linear-gradient(180deg, rgba(227,143,43,.08), rgba(0,0,0,.25));
    border:1px solid rgba(227,143,43,.35);
    color:var(--text);
    font-family:var(--mono);
  }
  #wl-combat-end .wl-note{ margin-top:10px; font-size:12px; color:var(--muted) }

  /* Actions (match .actions/.choice look) */
  #wl-combat-end .wl-actions{
    display:flex!important; justify-content:flex-end; gap:10px;
    padding:16px 22px 22px;
  }
  #wl-combat-end .wl-btn{
    all:unset; cursor:pointer; padding:10px 14px; border-radius:10px;
    border:1px solid rgba(227,143,43,.35);
    background:linear-gradient(180deg, rgba(227,143,43,.10), rgba(0,0,0,.25));
    color:var(--text);
    font-family:var(--mono);
  }
  #wl-combat-end .wl-btn:hover{ border-color:var(--accent) }
  #wl-combat-end .wl-btn.wl-primary{
    background:linear-gradient(180deg, rgba(227,143,43,.14), rgba(0,0,0,.28));
    border-color:rgba(227,143,43,.45);
  }

  /* Outcome icon tints */
  #wl-combat-end.wl-win .wl-icon{
    color:var(--ok);
    box-shadow: inset 0 0 0 1px rgba(121,179,123,.35);
  }
  #wl-combat-end.wl-lose .wl-icon{
    color:var(--danger);
    box-shadow: inset 0 0 0 1px rgba(198,69,58,.35);
  }
  #wl-combat-end.wl-flee .wl-icon{
    color:var(--warn);
    box-shadow: inset 0 0 0 1px rgba(242,193,78,.35);
  }

  @media(max-width:560px){
    #wl-combat-end .wl-grid{ grid-template-columns:1fr }
  }
</style>

<div id="wl-combat-end" class="wl-overlay" role="dialog" aria-modal="true" aria-labelledby="wl-title" aria-describedby="wl-desc">
  <div class="wl-modal" role="document">
    <div class="wl-hdr">
      <div class="wl-icon" id="wl-icon">★</div>
      <div>
        <h2 id="wl-title" class="wl-ttl">Battle Result</h2>
        <div id="wl-desc" class="wl-sub">You win!</div>
      </div>
    </div>
    <div class="wl-body">
      <div class="wl-grid">
        <div class="wl-card">
          <h4>Rewards</h4>
          <div class="wl-big"><span id="wl-xp">+0</span> <span class="wl-badge">XP</span></div>
          <div class="wl-sub">Caps: <b id="wl-caps">0</b></div>
        </div>
        <div class="wl-card">
          <h4>Loot</h4>
          <div id="wl-loot" class="wl-loot"><span class="wl-sub">None</span></div>
        </div>
      </div>
      <div id="wl-note" class="wl-note"></div>
    </div>
    <div class="wl-actions">
      <button id="wl-close" class="wl-btn">Close</button>
      <button id="wl-again" class="wl-btn wl-primary">Continue</button>
    </div>
  </div>
</div>

<script>
/* ---- end-screen helper ---- */
(function(){
  const $=id=>document.getElementById(id);
  const overlay=$("wl-combat-end"), ttl=$("wl-title"), desc=$("wl-desc"), icon=$("wl-icon");
  const xp=$("wl-xp"), caps=$("wl-caps"), loot=$("wl-loot"), note=$("wl-note");
  const btnClose=$("wl-close"), btnAgain=$("wl-again");
  const defaults={win:{t:"Victory!",d:"You overcame the threat.",i:"🏆"},
                  lose:{t:"Defeat",d:"You were overwhelmed...",i:"💀"},
                  flee:{t:"Retreat",d:"You escaped safely.",i:"🏃"}};
  function setLoot(items){
    loot.innerHTML=""; if(!items||!items.length){const s=document.createElement("span");s.className="wl-sub";s.textContent="None";loot.appendChild(s);return;}
    items.forEach(n=>{const c=document.createElement("span");c.className="wl-chip";c.textContent=n;loot.appendChild(c);});
  }
  function open(opts={}){
    const mode=(opts.outcome||"win").toLowerCase();
    overlay.classList.remove("wl-win","wl-lose","wl-flee"); overlay.classList.add("wl-"+mode);
    const d=defaults[mode]||defaults.win;
    ttl.textContent=opts.title||d.t; desc.textContent=opts.message||d.d; icon.textContent=opts.icon||d.i;
    xp.textContent="+"+(opts.xp??0); caps.textContent=(opts.caps??0); setLoot(opts.items||[]); note.textContent=opts.note||"";
    overlay.classList.add("wl-show"); setTimeout(()=>btnAgain.focus(),0);
    const onEsc=e=>{if(e.key==="Escape") close("close");}; document.addEventListener("keydown",onEsc);
    function close(result){ overlay.classList.remove("wl-show"); document.removeEventListener("keydown",onEsc);
      if(typeof opts.onClose==="function") opts.onClose(result);
      if(result==="again" && typeof opts.onAgain==="function") opts.onAgain(); }
    btnClose.onclick=()=>close("close"); btnAgain.onclick=()=>close("again");
    overlay.onclick=e=>{ if(e.target===overlay) close("close"); };
  }
  window.WLCombatEnd={open};
})();

/* ---- openCombat HARD OVERRIDE (with safe shims) ---- */
(function(){
  const safe = (name, ...args) => { try { const fn = window[name]; if (typeof fn === "function") return fn(...args); } catch(_){} };
  const has   = name => typeof window[name] === "function";

  window.openCombat = function(enemy, ctx = {}) {
    const m = openModal("Encounter");
    let logBox, enemyHPFill, playerHPFill;

    const pstats = () => playerBattleStats();
    const enemyStats = { atk: enemy.atk, def: enemy.def, spd: enemy.spd };

    const hud = el("div","kv");
    hud.append(el("div",null,"Enemy"));
    hud.append(el("div","small",`${enemy.name} (Lv ?)`));
    m.content.append(hud);

    const eRow = el("div","kv");
    eRow.append(el("div",null,enemy.name));
    const eBar = el("div","bar"); enemyHPFill = el("i"); eBar.append(enemyHPFill); eRow.append(eBar); m.content.append(eRow);

    const pRow = el("div","kv");
    pRow.append(el("div",null,state.name));
    const pBar = el("div","bar"); playerHPFill = el("i"); pBar.append(playerHPFill); pRow.append(pBar);
    m.content.append(pRow, el("div","hr"));

    logBox = el("div"); m.content.append(logBox);

    const actionRow = el("div","kv"); actionRow.append(el("div",null,"Actions"));
    const buttonsBox = el("div");
    const btnAttack = el("button","choice","Attack");
    const btnItem   = el("button","choice","Item");
    const btnFlee   = el("button","choice","Flee");
    buttonsBox.append(btnAttack, btnItem, btnFlee); actionRow.append(buttonsBox); m.content.append(actionRow);
    const itemBox = el("div"); m.content.append(itemBox);

    function uiLog(t){ const p = el("p",null,t); logBox.append(p); logBox.scrollTop = logBox.scrollHeight; }
    function refreshBars(){
      const ePct = Math.max(0, Math.round((enemy.curHP / enemy.hp) * 100)); enemyHPFill.style.width = ePct + "%";
      const pPct = Math.max(0, Math.round((state.hp / state.hpMax) * 100));  playerHPFill.style.width = pPct + "%";
    }
    function dmgCalc(attackerAtk, defenderDef, critChance = 0.05){
      let raw = attackerAtk + rnd(1,6) - 3;
      const K = 25, mult = 1 - (defenderDef / (defenderDef + K));
      let amount = Math.max(1, Math.round(raw * mult)); let crit=false;
      if (Math.random() < critChance){ amount = Math.round(amount * 1.5); crit = true; }
      return { amount, crit };
    }

    function endCombat(victory){
      [btnAttack, btnItem, btnFlee].forEach(b=>b.disabled=true);

      if (victory){
        state.battlesWon++;
        const reward = { ...enemy.reward };
        if (has("chance") ? chance(0.10) : Math.random() < 0.10) reward.items = { ...(reward.items||{}), food: 1 };
        if (has("chance") ? chance(0.08)  : Math.random() < 0.08) reward.items = { ...(reward.items||{}), duct_tape: (reward.items?.duct_tape||0) + 1 };
        safe("grantBattleRewards", reward);

        uiLog(`Victory! +${reward.xp||0} XP, +${reward.caps||0} caps${reward.items ? " (loot gained)" : ""}.`);
        safe("log", `Defeated ${enemy.name}.`); safe("updateUI"); safe("tickBuffs","combat");

        closeModal();
        WLCombatEnd.open({
          outcome:"win",
          xp: reward.xp||0,
          caps: reward.caps||0,
          items: reward.items ? Object.keys(reward.items) : [],
          note:`You defeated ${enemy.name}.`
        });
      } else {
        state.battlesLost++; safe("log",`You were overwhelmed by ${enemy.name}.`); safe("updateUI");
        if (state.hp <= 0) safe("die"); safe("tickBuffs","combat");
        closeModal();
        WLCombatEnd.open({ outcome:"lose", xp:0, caps:0, items:[], note:`You were defeated by ${enemy.name}.` });
      }
    }

    function enemyTurn(){
      if (enemy.curHP <= 0) return;
      const { def } = pstats();
      const result = dmgCalc(enemyStats.atk, def, 0.05);
      safe("damage", result.amount);
      uiLog(`${enemy.name} hits you for ${result.amount}${result.crit ? " (CRIT!)" : ""}.`);
      refreshBars();
      if (state.hp <= 0){ uiLog("You collapse!"); endCombat(false); return true; }
      return false;
    }
    function playerTurn(){ [btnAttack, btnItem, btnFlee].forEach(b=>b.disabled=false); }

    // Attack
    btnAttack.onclick = () => {
      [btnAttack, btnItem, btnFlee].forEach(b=>b.disabled=true);
      const gate = safe("currentAttackAndCritWithAmmoGate") || {};

      if (gate.usedAmmo && gate.perShot > 0 && gate.ammoId){
        const ok = safe("consumeAmmo", gate.ammoId, gate.perShot);
        uiLog(ok ? `[${gate.ammoName} -${gate.perShot}]` : `*Click.* Out of ammo (${gate.ammoName}). You swing your weapon!`);
      }
      if (gate.out) uiLog(`*Click.* Out of ammo (${gate.ammoName}). You strike with a melee bash!`);

      const ps = playerBattleStats();
      const atkBoostActive = (state.buffs?.atkBoost && (state.buffs.atkBoost.turns || state.buffs.atkBoost) > 0);
      const baseAtk  = (typeof gate.atk  === "number" && gate.atk  > 0) ? gate.atk  : ps.atk;
      const baseCrit = (typeof gate.crit === "number" && gate.crit > 0) ? gate.crit : ps.crit;
      const totalAtk  = Math.max(1, baseAtk + (atkBoostActive ? 4 : 0));
      const totalCrit = clamp(baseCrit, 0, 0.5);

      const result = dmgCalc(totalAtk, enemyStats.def, totalCrit);
      enemy.curHP = Math.max(0, enemy.curHP - result.amount);
      uiLog(`You hit ${enemy.name} for ${result.amount}${result.crit ? " (CRIT!)" : ""}.`);
      refreshBars();

      if (enemy.curHP <= 0){ uiLog(`${enemy.name} collapses!`); endCombat(true); return; }

      setTimeout(()=>{ const ended = enemyTurn(); if (!ended) playerTurn(); },150);
    };

    // Item
    btnItem.onclick = () => {
      itemBox.innerHTML = "";
      safe("migrateInventoryShape");
      const all = safe("inv") || [];
      const usable = all.filter(s => (window.ITEMS||{})[s.id]?.use);
      if (!usable.length){ itemBox.append(el("p","small muted","(No usable items)")); return; }
      usable.forEach(s=>{
        const meta = (window.ITEMS||{})[s.id] || {name:s.id};
        const b = el("button","choice",`${meta.name} ×${s.qty}`);
        b.onclick = () => {
          safe("useItem", s.id);
          uiLog(`You use ${meta.name}.`); refreshBars(); itemBox.innerHTML = "";
          setTimeout(()=>{ const ended = enemyTurn(); if (!ended) playerTurn(); },150);
        };
        itemBox.append(b, el("span","small muted"," "));
      });
    };

    // Flee
    btnFlee.onclick = () => {
      [btnAttack, btnItem, btnFlee].forEach(b=>b.disabled=true);
      const ps = pstats(); const pSpd = Number(ps?.spd ?? 0); const eSpd = Number(enemyStats?.spd ?? 0);
      let base = 0.35 + ((pSpd - eSpd) * 0.03);
      if (Array.isArray(state?.perks) && state.perks.includes("swift")) base += 0.10;
      if ((state?.buffs?.fleeBoost ?? 0) > 0) base += 0.15;
      const fleeChance = clamp(isFinite(base) ? base : 0.35, 0.10, 0.90);

      if (Math.random() < fleeChance){
        uiLog("You slip away!"); safe("log",`You fled from ${enemy.name}.`); safe("updateUI"); safe("tickBuffs","combat");
        closeModal();
        WLCombatEnd.open({ outcome:"flee", xp:0, caps:0, items:[], note:`You escaped from ${enemy.name}.` });
        return;
      }
      uiLog("You fail to escape!");
      setTimeout(()=>{ const ended = enemyTurn(); if (!ended) playerTurn(); safe("tickBuffs","combat"); },150);
    };

    enemy.curHP = enemy.curHP ?? enemy.hp;
    refreshBars(); playerTurn();
  };

  /* ensure node is under <body> even if something moved it */
  (function(){ const n=document.getElementById('wl-combat-end'); if(n && n.parentNode!==document.body){ document.body.appendChild(n); }})();
})();

/* Wastelife — Living World v0.5 (consolidated, no conflicts)
   - Social button
   - NPCs with Chat / Rumors / Trade / Hire / Lore / Request
   - Travel-to-them if far (uses your Text Map travel)
*/
(function(){
  "use strict";
  const W = window;
  const ST = () => (W.state || (W.state = {}));  // TDZ-safe: never touch bare `state`

  // Modal helper (uses your existing modal markup)
  function showModalSimple(title, html){
    const mb=document.getElementById("modal-backdrop"),
          mt=document.getElementById("modal-title"),
          mc=document.getElementById("modal-content");
    if(!mb||!mt||!mc) return alert(title+"\n\n"+String(html||"").replace(/<[^>]+>/g,""));
    mt.textContent=title; mc.innerHTML=html; mb.style.display="grid";
  }
  const logSafe = s => { try{ W.log(s); } catch { console.log("[WORLD]", s); } };

  // Canonical locations (scoped here only) with aliases to match your WORLD ids
  const LOC = {
    CANON: {
      dustown:    { name:"Dustown",        worldId:"dustford" }, // Dustford↔Dustown
      ironwood:   { name:"Ironwood",       worldId:"ironwood" },
      dunes:      { name:"Wasteland Dunes",worldId:"dunes" },
      ruins_zone: { name:"Cracked Ruins",  worldId:"ruins" },
      flats_zone: { name:"Salt Flats",     worldId:"flats" },
      canyon:     { name:"Red Canyons",    worldId:"canyon" },
      swamp:      { name:"Irrad. Swamp",   worldId:"swamp" },
    },
    ALIASES: {
      "dustown":"dustown", "dustford":"dustown", "ironwood":"ironwood",
      "wasteland dunes":"dunes", "cracked ruins":"ruins_zone", "salt flats":"flats_zone",
      "red canyons":"canyon", "irrad. swamp":"swamp", "swamp":"swamp"
    },
    slug(s){ return String(s||"").toLowerCase().replace(/[^\w]+/g," ").trim(); },
    idFromAny(x){ if(!x) return null; if(this.CANON[x]) return x; const id=this.ALIASES[this.slug(x)]; return id||null; },
    name(id){ return this.CANON[id]?.name || String(id||"Unknown"); },
    worldId(id){ return this.CANON[id]?.worldId || null; }
  };

  // Make sure the player has a canonical id alongside the display name
  (function bootstrapPlayerLoc(){
    const s = ST();
    if (!s.locationId){
      s.locationId = LOC.idFromAny(s.location) || "ironwood";
      s.location   = LOC.name(s.locationId);
    }
  })();

  // Factions (fallbacks)
  const FACS = (Array.isArray(W.FACTIONS) && W.FACTIONS.length)
    ? W.FACTIONS
    : [
        {id:"none", name:"Unaffiliated"},
        {id:"settlers", name:"Settlers Union"},
        {id:"rangers",  name:"Desert Rangers"},
        {id:"scribes",  name:"Scribes of the Old World"},
        {id:"dust_marauders", name:"Dust Marauders"}
      ];

  // LW state
  const S = {
    tick: 0,
    news: [],
    faction: Object.fromEntries(FACS.map(f => [f.id, { id:f.id, name:f.name, caps:50, land:0, recruits:8 }])),
    npcs: [
      { id:"joe",  name:"Trader Joe", role:"Trader", trust:50, locId:"dustown",  alive:true },
      { id:"sara", name:"Merc Sara",  role:"Merc",   trust:50, locId:"ironwood", alive:true },
      { id:"eli",  name:"Scribe Eli", role:"Scribe", trust:50, locId:"dunes",    alive:true },
    ],
  };
  function pushNews(t){ S.news.push(String(t)); if (S.news.length>40) S.news.shift(); }
  const hereId  = () => ST().locationId;
  const hereStr = () => LOC.name(ST().locationId);

  // NPC wandering (lightweight)
  function moveNPCs(){
    const ring = Object.keys(LOC.CANON);
    S.npcs.forEach(n=>{
      if(!n.alive) return;
      if (Math.random()<0.45){
        const i = Math.max(0, ring.indexOf(n.locId));
        n.locId = ring[(i + (Math.random()<0.5?-1:1) + ring.length) % ring.length];
      }
    });
  }
  function tick(){
    S.tick++; moveNPCs();
    pushNews(`The year ${2165 + S.tick} passes in the wastes.`);
    ensureSocialBtn();
  }

  // Travel helper (prefer your Text Map)
  function travelToId(id){
    const cid = LOC.idFromAny(id); if (!cid) return;
    const wid = LOC.worldId(cid);
    if (typeof W.WL_TextMap?.travelTo === "function"){ W.WL_TextMap.travelTo(wid); return; }
    // fallback if Text Map is missing
    const s = ST(); s.locationId = cid; s.location = LOC.name(cid); logSafe(`You travel to ${s.location}.`); W.updateUI?.();
  }

  // Social button
  function ensureSocialBtn(){
    if (document.getElementById("btn-social")) return;
    const anchor = document.getElementById("btn-inventory")?.closest(".group")
                || document.querySelector(".actions .group")
                || document.querySelector(".actions")
                || document.body;
    const b = document.createElement("button");
    b.id = "btn-social"; b.textContent = "Social / NPCs"; b.onclick = openSocial;
    anchor.appendChild(b);
  }

  function openSocial(){
    const rowsF = FACS.map(f=>{
      const F=S.faction[f.id]; if(!F) return "";
      return `<tr><td>${F.name}</td><td>${F.caps}</td><td>${F.recruits}</td></tr>`;
    }).join("");

    const all    = S.npcs.filter(n => n.alive);
    const nearby = all.filter(n => n.locId === hereId());
    const other  = all.filter(n => n.locId !== hereId());

    const rows = (list) => list.map(n => `
      <tr>
        <td><button class="choice" onclick="LW.openNPC('${n.id}')">${n.name}</button></td>
        <td>${n.role}</td>
        <td>${LOC.name(n.locId)}</td>
      </tr>`).join("") || `<tr><td colspan="3">—</td></tr>`;

    const news = S.news.slice(-7).map(s=>`<li>${s}</li>`).join("") || "<li>(quiet)</li>";

    showModalSimple("Social — NPCs", `
      <div class="title">Factions</div>
      <table style="width:100%;font-family:var(--mono);font-size:12px;border-collapse:collapse">
        <tr><th align="left">Name</th><th>Caps</th><th>Recruits</th></tr>${rowsF}
      </table>
      <div class="title" style="margin-top:8px">Here in ${hereStr()}</div>
      <table style="width:100%;font-family:var(--mono);font-size:12px;border-collapse:collapse">
        <tr><th align="left">Name</th><th>Role</th><th align="left">Location</th></tr>${rows(nearby)}
      </table>
      <div class="hr"></div>
      <details><summary class="linklike">Show NPCs elsewhere</summary>
        <table style="width:100%;font-family:var(--mono);font-size:12px;border-collapse:collapse">
          <tr><th align="left">Name</th><th>Role</th><th align="left">Location</th></tr>${rows(other)}
        </table>
      </details>
      <div class="title" style="margin-top:8px">Recent News</div>
      <ul style="margin:6px 0 0 18px">${news}</ul>
    `);
  }

  function openNPC(idOrObj){
    const npc = (typeof idOrObj === "string") ? S.npcs.find(x=>x.id===idOrObj && x.alive) : idOrObj;
    if (!npc) return showModalSimple("NPC not found","");

    const near = (npc.locId === hereId());
    let html = `
      <p><b>${npc.name}</b> (${npc.role})<br>
      Location: ${LOC.name(npc.locId)}${near ? " (nearby)" : ""}<br>
      Trust: ${npc.trust ?? 0}</p>`;

    if (!near){
      html += `<button class="choice" onclick="(function(){ LW.travelToId('${npc.locId}'); LW.openNPC('${npc.id}'); })()">Travel to ${LOC.name(npc.locId)}</button>`;
    } else {
      html += `
        <button class="choice" onclick="LW.talk('${npc.id}','chat')">Chat</button>
        <button class="choice" onclick="LW.talk('${npc.id}','rumor')">Ask for Rumors</button>`;
      if (npc.role === "Trader") html += `<button class="choice" onclick="LW.talk('${npc.id}','trade')">Trade</button>`;
      if (npc.role === "Merc")   html += `<button class="choice" onclick="LW.talk('${npc.id}','hire')">Hire as Guard</button>`;
      if (npc.role === "Scribe") html += `
        <button class="choice" onclick="LW.talk('${npc.id}','lore')">Share Knowledge</button>
        <button class="choice" onclick="LW.talk('${npc.id}','request')">Request Research</button>`;
    }
    showModalSimple(npc.name, html);
  }

  function talk(id, action){
    const npc = S.npcs.find(n=>n.id===id && n.alive); if(!npc) return;
    const near = (npc.locId === hereId());
    const s = ST();
    let out="", trust=0;

    if (!near && action!=="rumor"){ showModalSimple(npc.name, `<p>${npc.name} is at ${LOC.name(npc.locId)}. Travel there first.</p>`); return; }

    switch(action){
      case "trade":
        out = `${npc.name} lays out wares. (Hook: open trader UI)`;
        try{ W.openTrade?.("Trader"); }catch{}
        trust = 1; break;
      case "rumor":
        out = `${npc.name} shares rumors about faction movements.`; trust = 2; break;
      case "hire": {
        const cost = 15;
        if ((s.caps||0) >= cost){ s.caps -= cost; out = `${npc.name} agrees to guard you for a while. (Companion stub)`; trust = 3; W.updateUI?.(); }
        else out = `${npc.name}: "Come back with ${cost} caps."`;
        break;
      }
      case "lore":
        out = `${npc.name} teaches you pre-war tech insights. (+10 XP)`; W.gainXP?.(10); trust = 2; break;
      case "request":
        out = `${npc.name}: "Bring me a Holotape and I'll share a schematic."`; trust = 1; break;
      default:
        out = `${npc.name} chats about the road.`; trust = 1;
    }

    npc.trust = Math.min(100, (npc.trust||0) + trust);
    pushNews(out); logSafe(out);
    showModalSimple(npc.name, `<p>${out}</p><p>Trust now: ${npc.trust}</p>`);
  }

  // Wire up
  function patch(){
    ensureSocialBtn();
    const age = document.getElementById("btn-age");
    if (age && !age.dataset._lw){ age.dataset._lw="1"; age.addEventListener("click", ()=> setTimeout(tick,0)); }
    const c = document.getElementById("modal-close");
    if (c && !c.dataset._lw){ c.dataset._lw="1"; c.addEventListener("click", ()=>{ const mb=document.getElementById("modal-backdrop"); if(mb) mb.style.display="none"; }); }
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", patch);
  else patch();

  // Expose for onclicks
  W.LW = { state:S, openSocial, openNPC, talk, travelToId };
})();
</script>
</body>
</html>
