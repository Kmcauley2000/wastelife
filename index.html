<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wastelife: A Post-Apocalyptic Life Sim</title>
<style>
:root {
  /* Dusty Texas palette */
  --bg:#1a1512;          /* mesquite night */
  --panel:#1f1a16;       /* oiled leather */
  --accent:#e38f2b;      /* mesquite ember */
  --accent-dim:#995c1a;  /* aged brass */
  --danger:#c6453a;      /* rust red */
  --warn:#f2c14e;        /* sun-glare amber */
  --ok:#79b37b;          /* scrub green */
  --text:#f3e9d2;        /* parchment */
  --muted:#c9b8a6;       /* dusty khaki */
  --shadow:0 10px 24px rgba(0,0,0,.35), inset 0 0 0 1px rgba(227,143,43,.14);
  --radius:14px;
  --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  --sans:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
}
/* layout.css */
/* let page grow, always fill background */
html,body{min-height:100%}

body {
  margin:0;
  background:
    radial-gradient(1200px 800px at 30% -10%, #3b2b21 0%, var(--bg) 52%) no-repeat,
    radial-gradient(900px 700px at 110% 120%, #2a211b 0%, transparent 60%) no-repeat,
    linear-gradient(180deg, #1b1714, #16120f);
  background-attachment:fixed;
  background-color:var(--bg);
  font-family:var(--sans);
  color:var(--text);
  line-height:1.4;
}

/* ======== ORIGINAL LAYOUT (unchanged) ======== */
.wrap{max-width:1200px;margin:32px auto;padding:0 16px;}

header{display:grid;gap:12px;grid-template-columns:1fr;margin-bottom:16px;}

.grid{display:grid;gap:12px;grid-template-columns:330px 1fr;}

/* ======== Theming only (colors), layout preserved ======== */
.card{
  background:linear-gradient(180deg, rgba(227,143,43,.06), rgba(0,0,0,.08));
  border:1px solid rgba(227,143,43,.28);
  box-shadow:var(--shadow);
  border-radius:var(--radius);
  padding:14px;
}

.actions{display:grid;gap:8px}

.actions button{
  all:unset;cursor:pointer;padding:10px 12px;border-radius:10px;
  border:1px solid rgba(227,143,43,.35);
  background:linear-gradient(180deg, rgba(227,143,43,.10), rgba(0,0,0,.25));
  font-family:var(--mono);color:var(--text)
}

.actions button:hover{border-color:var(--accent)}

.actions .group{display:grid;gap:8px}

footer{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}

/* faction pill theming (slugged) */
#faction-pill-wrapper{cursor:pointer;transition:background .2s,color .2s;}

/* ── Faction Menu Enhancements (colors only) ───────────────── */
.faction-header {
  padding: 14px;
  border-radius: var(--radius);
  margin-bottom: 12px;
  background: rgba(0,0,0,.3);
  border: 1px solid rgba(227,143,43,.35);
}

.faction-header.settlers       { border-color:#c48b40; }

.faction-header.rangers        { border-color:#3a8f6b; }

.faction-header.scribes        { border-color:#8a78c4; }

.faction-header.dust_marauders { border-color:#e38f2b; }

/* Header */
  #wl-combat-end .wl-hdr{
    padding:16px 18px!important;
    border-bottom:1px solid rgba(227,143,43,.28)!important;
    background:linear-gradient(180deg, rgba(26,21,18,1), rgba(26,21,18,.86))!important;
    display:flex!important; gap:12px; align-items:center;
  }

/* Body */
  #wl-combat-end .wl-body{ padding:22px 22px 8px!important }

#wl-combat-end .wl-grid{ display:grid; grid-template-columns:1fr 1fr; gap:16px }

/* Actions (match .actions/.choice look) */
  #wl-combat-end .wl-actions{
    display:flex!important; justify-content:flex-end; gap:10px;
    padding:16px 22px 22px;
  }
/* components.css */
.pill{
  border:1px solid rgba(227,143,43,.35);
  padding:6px 10px;border-radius:999px;
  font-family:var(--mono);
  background:linear-gradient(180deg, rgba(227,143,43,.08), rgba(0,0,0,.25));
}

.bar{height:12px;border-radius:8px;background:rgba(227,143,43,.12);overflow:hidden;border:1px solid rgba(227,143,43,.32)}

.bar>i{display:block;height:100%;background:var(--accent);box-shadow:inset 0 0 12px rgba(0,0,0,.4)}

.bar.warn>i{background:var(--warn)}

.bar.danger>i{background:var(--danger)}

.entry{
  padding:10px 12px;border-left:3px solid rgba(227,143,43,.35);
  background:rgba(0,0,0,.22);border-radius:10px;margin:8px 0
}

.entry p{margin:0}

.choices{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}

.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;place-items:center;z-index:10;}

.modal{width:min(880px,92vw);max-height:80vh;overflow:auto}

.modal .title{
  position:sticky;top:0;
  background:linear-gradient(180deg, rgba(26,21,18,1), rgba(26,21,18,.86));
  padding:14px;border-bottom:1px solid rgba(227,143,43,.28);z-index:1
}

/* Solid background for modals only */
.modal.card { background: var(--panel); }
/* game.css */
.topbar{display:grid;gap:12px;grid-template-columns:1.1fr 1fr;}

@media(max-width:1000px){.topbar{grid-template-columns:1fr}}

@media(max-width:1000px){.grid{grid-template-columns:1fr}}

.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}

.title{
  font-family:var(--mono);
  color:var(--accent);
  letter-spacing:.5px;
  display:flex;align-items:center;gap:10px;
  font-size:18px;margin:0 0 6px;
  text-shadow:0 1px 0 rgba(0,0,0,.35);
}

.stat{margin:8px 0}

.stat-label{display:flex;justify-content:space-between;font-size:12px;color:var(--muted);font-family:var(--mono)}

.log{height:540px;overflow:auto;padding-right:6px}

.choice{all:unset;cursor:pointer;padding:8px 10px;border-radius:8px;border:1px solid rgba(227,143,43,.35);font-family:var(--mono)}

.choice:hover{border-color:var(--accent)}

.muted{color:var(--muted)}

.hr{height:1px;background:rgba(227,143,43,.28);margin:10px 0}

.linklike{all:unset;cursor:pointer;color:var(--accent);font-family:var(--mono)}

.dangerous{color:var(--danger)}

.center{text-align:center}

.kv{display:grid;grid-template-columns:160px 1fr;gap:8px;margin:10px 0;font-family:var(--mono)}

.small{font-size:12px}

.hidden{display:none!important}

.faction-settlers{background:#efe6d4;color:#4b3a20;}

/* adobe tan */
.faction-rangers{background:#d9e8e0;color:#204535;}

/* ranger green */
.faction-scribes{background:#e8e1f2;color:#352a55;}

/* archivist violet */
.faction-dust_marauders{background:#f0e0cc;color:#5a2b14;}

/* dusty leather */
.faction-none{background:#ddd;color:#333;}

/* fixed slug */

.rep-bar {
  height: 12px;
  border-radius: 8px;
  background: rgba(227,143,43,.12);
  border: 1px solid rgba(227,143,43,.32);
  overflow: hidden;
  margin: 4px 0;
}

.rep-bar > i { display:block; height:100%; background:var(--accent); }

.faction-action {
  background: rgba(0,0,0,.2);
  border: 1px solid rgba(227,143,43,.28);
  border-radius: var(--radius);
  padding: 10px;
  margin: 8px 0;
}

.faction-action .label {
  font-family: var(--mono);
  color: var(--accent);
  margin-bottom: 6px;
}

/* --- End-of-Battle Overlay — themed to Wastelife globals --- */
  /* Uses your existing :root vars:
     --bg --panel --accent --accent-dim --danger --warn --ok --text --muted --shadow --radius --mono --sans */

  /* Overlay + centering (hardened) */
  #wl-combat-end{
    position:fixed!important; inset:0!important;
    display:none; align-items:center; justify-content:center;
    z-index:2147483647!important;
    background:rgba(0,0,0,.6); /* match .modal-backdrop */
    font-family:var(--sans); color:var(--text);
  }

#wl-combat-end.wl-show{ display:flex!important }

#wl-combat-end *{ box-sizing:border-box }

/* Modal — larger */
  #wl-combat-end .wl-modal{
    display:block!important;
    width:min(900px,98vw)!important; max-width:98vw; min-height:420px!important;
    background:var(--panel)!important;
    border:1px solid rgba(227,143,43,.28)!important; /* accent border */
    border-radius:var(--radius)!important;
    box-shadow:var(--shadow)!important;
    color:var(--text);
    overflow:hidden;
  }

#wl-combat-end .wl-icon{
    width:44px; height:44px; border-radius:12px;
    display:grid; place-items:center; font-weight:800;
    background:linear-gradient(180deg, rgba(227,143,43,.08), rgba(0,0,0,.25));
    border:1px solid rgba(227,143,43,.28);
    color:var(--accent);
    font-family:var(--mono);
    text-shadow:0 1px 0 rgba(0,0,0,.35);
  }

#wl-combat-end .wl-ttl{
    margin:0; font-size:20px;
    font-family:var(--mono);
    color:var(--accent);
    letter-spacing:.5px;
    text-shadow:0 1px 0 rgba(0,0,0,.35);
  }

#wl-combat-end .wl-sub{ margin:4px 0 0; color:var(--muted); font-size:13px }

/* Cards */
  #wl-combat-end .wl-card{
    background:linear-gradient(180deg, rgba(227,143,43,.06), rgba(0,0,0,.08));
    border:1px solid rgba(227,143,43,.28);
    border-radius:var(--radius);
    padding:14px;
  }

#wl-combat-end .wl-card h4{
    margin:0 0 6px; font-size:12px; color:var(--muted); font-family:var(--mono)
  }

#wl-combat-end .wl-big{ font-size:32px; font-weight:900; color:var(--text) }

#wl-combat-end .wl-badge{
    padding:3px 8px; font-size:11px; border-radius:999px;
    background:linear-gradient(180deg, rgba(227,143,43,.08), rgba(0,0,0,.25));
    border:1px solid rgba(227,143,43,.28);
    color:var(--muted);
    font-family:var(--mono);
  }

/* Loot chips */
  #wl-combat-end .wl-loot{ display:flex; gap:8px; flex-wrap:wrap }

#wl-combat-end .wl-loot .wl-chip{
    font-size:12px; padding:6px 10px; border-radius:999px;
    background:linear-gradient(180deg, rgba(227,143,43,.08), rgba(0,0,0,.25));
    border:1px solid rgba(227,143,43,.35);
    color:var(--text);
    font-family:var(--mono);
  }

#wl-combat-end .wl-note{ margin-top:10px; font-size:12px; color:var(--muted) }

#wl-combat-end .wl-btn{
    all:unset; cursor:pointer; padding:10px 14px; border-radius:10px;
    border:1px solid rgba(227,143,43,.35);
    background:linear-gradient(180deg, rgba(227,143,43,.10), rgba(0,0,0,.25));
    color:var(--text);
    font-family:var(--mono);
  }

#wl-combat-end .wl-btn:hover{ border-color:var(--accent) }

#wl-combat-end .wl-btn.wl-primary{
    background:linear-gradient(180deg, rgba(227,143,43,.14), rgba(0,0,0,.28));
    border-color:rgba(227,143,43,.45);
  }

/* Outcome icon tints */
  #wl-combat-end.wl-win .wl-icon{
    color:var(--ok);
    box-shadow: inset 0 0 0 1px rgba(121,179,123,.35);
  }

#wl-combat-end.wl-lose .wl-icon{
    color:var(--danger);
    box-shadow: inset 0 0 0 1px rgba(198,69,58,.35);
  }

#wl-combat-end.wl-flee .wl-icon{
    color:var(--warn);
    box-shadow: inset 0 0 0 1px rgba(242,193,78,.35);
  }

@media(max-width:560px){
    #wl-combat-end .wl-grid{ grid-template-columns:1fr }
  }</style>
</head>
<body>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wastelife: A Post-Apocalyptic Life Sim</title>
<link rel="stylesheet" href="layout/variables/variables.css">
<link rel="stylesheet" href="layout/layout/layout.css">
<link rel="stylesheet" href="layout/components/components.css">
<link rel="stylesheet" href="layout/game/game.css">
</head>
<body>
<div class="wrap">
<header class="card">
<h1 class="title">WASTELIFE ▸ <span class="muted" id="header-status">new run</span></h1>
<div class="topbar">
<div class="card">
<div class="row">
<div class="pill">Name: <b id="name">—</b></div>
<!-- Stat pills row -->
<div class="pills">
<div class="pill">Age: <b id="age">18</b></div>
<div class="pill">HP: <b id="hp">100/100</b></div>
<div class="pill">Caps: <b id="caps">0</b></div>
<div class="pill">Karma: <b id="karma">0</b></div>
<div class="pill">Level: <b id="level">1</b> (<span id="xp">0</span> XP)</div>
<div class="pill">RAD: <b id="rad">0</b></div>
<!-- Unified clickable Faction pill -->
<div class="pill" id="faction-pill-wrapper">
    Faction: <b id="faction-pill">Unaffiliated</b>
</div>
</div>
<div class="row" id="special" style="margin-top:8px; flex-wrap:wrap"></div>
</div>
<div class="card">
<div class="row">
<div class="pill">Origin: <b id="origin">—</b></div>
<div class="pill">Job: <b id="job">—</b></div>
<div class="pill">Location: <b id="location">—</b></div>
<div class="pill">Year: <b id="year">2165</b></div>
</div>
<div class="hr"></div>
<div class="row small">
<span class="muted">Tip: Hit “Age Up” yearly. Choices affect S.P.E.C.I.A.L., caps, karma, and survival.</span>
</div>
</div>
</div>
</div></header>
<main class="grid">
<aside class="card">
<div class="title">Actions</div>
<div class="actions">
<div class="group">
<button id="btn-age">▸ Age Up (1 year)</button>
<button id="btn-explore">Explore the Wasteland</button>
<button id="btn-work">Work / Scavenge</button>
<button id="btn-heal">Treat Wounds / AntiRad (Cost: 12 Caps)</button>
</div>
<div class="hr"></div>
<div class="group">
<button id="btn-inventory">Inventory</button>
<button id="btn-trade">Visit Trader</button>
<button id="btn-join-faction">Join a Faction</button>
<button id="btn-perks">Perks</button>
        <!-- New Job Board button for NPC tasks -->
        <button id="btn-jobboard">Job Board</button>

        <!-- New Settlement button for base management -->
        <button id="btn-settlement">Your Settlement</button>
</div>
<div class="hr"></div>
<div class="group">
<button id="btn-save">Save</button>
<button id="btn-load">Load</button>
<button class="dangerous" id="btn-reset">New Run</button>
</div>
</div>
</aside>
<section class="card">
<div class="title">Life Log</div>
<div class="log" id="log"></div>
<footer>
<span class="muted small">Wastelife is an original, fan-made life sim. Survive, thrive, and make choices. No two runs are the same.</span>
</footer>
</section>
</main>
</div>
 Modals 
<div class="modal-backdrop" id="modal-backdrop">
<div aria-modal="true" class="card modal" role="dialog">
<h2 class="title" id="modal-title">Modal</h2>
<div id="modal-content"></div>
<div class="hr"></div>
<div class="row" style="padding:0 14px 14px">
<button class="linklike" id="modal-close">Close</button>
</div>
</div>
</div>


<div aria-describedby="wl-desc" aria-labelledby="wl-title" aria-modal="true" class="wl-overlay" id="wl-combat-end" role="dialog">
<div class="wl-modal" role="document">
<div class="wl-hdr">
<div class="wl-icon" id="wl-icon">★</div>
<div>
<h2 class="wl-ttl" id="wl-title">Battle Result</h2>
<div class="wl-sub" id="wl-desc">You win!</div>
</div>
</div>
<div class="wl-body">
<div class="wl-grid">
<div class="wl-card">
<h4>Rewards</h4>
<div class="wl-big"><span id="wl-xp">+0</span> <span class="wl-badge">XP</span></div>
<div class="wl-sub">Caps: <b id="wl-caps">0</b></div>
</div>
<div class="wl-card">
<h4>Loot</h4>
<div class="wl-loot" id="wl-loot"><span class="wl-sub">None</span></div>
</div>
</div>
<div class="wl-note" id="wl-note"></div>
</div>
<div class="wl-actions">
<button class="wl-btn" id="wl-close">Close</button>
<button class="wl-btn wl-primary" id="wl-again">Continue</button>
</div>
</div>
</div>

 ============== Hard-wired Faction NPCs + Faction chips + Modal faction line ============== 


<!-- Inline scripts -->
<script>// main.js
// ========= Utility =========
// NOTE: These helpers ( $, el, rnd, sample, clamp ) are general-purpose.
// Add new helper functions here if you want them available everywhere.

const $ = sel => document.querySelector(sel);
const el = (t, cls, txt) => {
  const n = document.createElement(t);
  if (cls) n.className = cls;
  if (txt != null) n.textContent = txt;
  return n;
};
const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const sample = arr => arr[Math.floor(Math.random()*arr.length)];
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));


// Common reward applier
function grantBattleRewards(rew){
  let cap = rew.caps || 0, xp = rew.xp || 0;
  if (state.perks.includes("scrounger")) cap = Math.round(cap * 1.15);
  if (cap) { state.caps += cap; }
  if (xp)  { gainXP(xp); }
  if (rew.rad) rad(rew.rad);
  if (rew.items){
    for (const [id, q] of Object.entries(rew.items)) addItem(id, q);
  }
}

// Hook to spin up combat with probability; returns true if combat started
function maybeStartCombat(prob=0.3, tier="wastes", source="explore"){
  if (state.buffs?.fleeBoost > 0) prob *= 0.55; // stealth reduces chance
  if (!state.alive) return false;
  if (!chance(prob)) return false;
  const enemy = generateEnemy(tier);
  openCombat(enemy, { source });
  return true;
}



/* ========= Items & Inventory Helpers ========= */
// NOTE: Add new items to ITEMS
// NOTE: Add new crafting recipes to RECIPES

const ITEMS = {
  canteen: { 
    name:"Canteen",
    desc:"Refillable water bottle. Restores a bit of health or reduces radiation.",
    use:()=>{ 
      if(state.rad > 0){ 
        derad(5); 
        log("You sip clean water. RAD -5."); 
      } else { 
        heal(2); 
        log("You sip water. HP +2."); 
      }
      return true; 
    }
  },

 // ==== Ammo (stackable resources) ====
  ammo_38:      { name: ".38 Rounds",       desc:"Pistol cartridges for revolvers." },
  ammo_308:     { name: ".308 Rounds",      desc:"High-power rifle ammunition." },
  shells_12g:   { name: "12g Shells",       desc:"Shotgun shells." },
  carbine_round:{ name: "Carbine Rounds",   desc:"Intermediate carbine cartridges." },
  ammo_9mm:      { name:"9mm Rounds",        desc:"Common pistol/SMG cartridge." },
  ammo_556:      { name:"5.56 Rounds",       desc:"Intermediate rifle cartridge." },
  ammo_762:      { name:"7.62 Rounds",       desc:"Full-power rifle cartridge." },
  ammo_44:       { name:".44 Magnum",        desc:"Big-bore lever/handgun round." },
  energy_cell:   { name:"Energy Cell",       desc:"Standard energy weapon cell." },

//// SETTLER MAIN CAMPAIGN ITEMS /////
    settlers_coat: {
    name:"Union Field Coat",
    desc:"Sturdy Settlers issue. +5 DEF, +1 AGI.",
    slot:"chest", bonus:{ def:5, agi:1 }
  },
  settlers_carbine: {
    name:"Settlers Carbine",
    desc:"Reliable union carbine. +11 ATK, +2% crit.",
    slot:"weapon", bonus:{ atk:11, crit:0.02 },
    ammo:{ id:"carbine_round", perShot:1 }
  },
  diplomats_coat: {
    name:"Diplomat’s Coat",
    desc:"Worn by peacemakers. +4 DEF, +2 AGI.",
    slot:"chest", bonus:{ def:4, agi:2 }
  },

////////////////////////////////////////////////////////

  helmet: { name:"Makeshift Helmet", desc:"Protects your head. +2 defense.", slot:"head", bonus:{def:2} },
  armor:  { name:"Leather Armor",   desc:"Light chest armor. +3 defense.",   slot:"chest", bonus:{def:3} },
  boots:  { name:"Sturdy Boots",    desc:"Protect your legs. +1 defense.",   slot:"legs",  bonus:{def:1} },
  knife:  { name:"Combat Knife",    desc:"Reliable melee weapon. +6 attack.",slot:"weapon",bonus:{atk:6} },

  junk:       { name:"Junk",        desc:"Assorted scrap. Useful for crafting or selling." },
  duct_tape:  { name:"Duct Tape",   desc:"Binds the world together. Often used in crafting." },

  rad_purge: {
    name: "Rad Purge",
    desc: "Flushes radiation from your system. -25 RAD.",
    use:()=>{ derad(25); log("You flush radiation. RAD -25."); return true; }
  },

  rad_shield: {
    name: "Rad Shield",
    desc: "Halves radiation intake for 5 actions.",
    use:()=>{ state.buffs.radShield.turns = Math.max(state.buffs.radShield.turns, 5);
              log("You take Rad Shield. Radiation intake reduced for a while."); return true; }
  },

  battle_tonic: {
    name: "Battle Tonic",
    desc: "Adrenal surge. +4 ATK for the next 3 combats.",
    use:()=>{ state.buffs.atkBoost = Math.max(state.buffs.atkBoost, 3);
              log("You feel a rush of aggression. ATK boosted for a few fights."); return true; }
  },

  bulk_tonic: {
    name: "Bulk Tonic",
    desc: "+2 STR & +2 END for the next 3 actions.",
    use:()=>{ state.buffs.strEnd = Math.max(state.buffs.strEnd, 3);
              log("Your muscles bulge. STR/END up briefly."); return true; }
  },

  focus_pills: {
    name: "Focus Pills",
    desc: "+3 PER & +3 INT for the next 3 actions.",
    use:()=>{ state.buffs.percInt = Math.max(state.buffs.percInt, 3);
              log("Your thoughts sharpen. PER/INT up briefly."); return true; }
  },

  stealth_field: {
    name: "Stealth Field",
    desc: "Cloaks you for 3 actions. Easier to flee; fewer encounters.",
    use:()=>{ state.buffs.fleeBoost = Math.max(state.buffs.fleeBoost, 3);
              log("A shimmer trails your steps. Flee chance up; encounters rarer."); return true; }
  },

/// === FireArms ===
  revolver: {
    name:"Revolver",
    desc:"+8 attack. Slightly better crits.",
    slot:"weapon", bonus:{ atk:8, crit:0.03 },
    ammo:{ id:"ammo_38", perShot:1 }
  },

  hunting_rifle: {
    name:"Hunting Rifle",
    desc:"+10 attack. Keen sights (+5% crit).",
    slot:"weapon", bonus:{ atk:10, crit:0.05 },
    ammo:{ id:"ammo_308", perShot:1 }
  },

  shotgun: {
    name:"Shotgun",
    desc:"+9 attack. Packs a punch at close range.",
    slot:"weapon", bonus:{ atk:9 },
    ammo:{ id:"shells_12g", perShot:1 }
  },

  pipe_pistol: {
    name:"Pipe Pistol",
    desc:"Crude but serviceable. +5 ATK. Uses .38 rounds.",
    slot:"weapon", bonus:{ atk:5 },
    ammo:{ id:"ammo_38", perShot:1 }
  },

  smg_9mm: {
    name:"9mm SMG",
    desc:"Compact spray. +7 ATK, +2% crit. Uses 9mm.",
    slot:"weapon", bonus:{ atk:7, crit:0.02 },
    ammo:{ id:"ammo_9mm", perShot:1 }
  },

  assault_rifle_556: {
    name:"5.56 Assault Rifle",
    desc:"Service rifle. +12 ATK, +1% crit. Uses 5.56.",
    slot:"weapon", bonus:{ atk:12, crit:0.01 },
    ammo:{ id:"ammo_556", perShot:1 }
  },

  battle_rifle_762: {
    name:"7.62 Battle Rifle",
    desc:"Full-power thumper. +13 ATK, +1.5% crit. Uses 7.62.",
    slot:"weapon", bonus:{ atk:13, crit:0.015 },
    ammo:{ id:"ammo_762", perShot:1 }
  },

  marksman_rifle: {
    name:"Marksman Rifle",
    desc:"Scoped precision. +12 ATK, +7% crit. Uses .308.",
    slot:"weapon", bonus:{ atk:12, crit:0.07 },
    ammo:{ id:"ammo_308", perShot:1 }
  },

  lever_action_44: {
    name:"Lever-Action .44",
    desc:"Classic punch. +11 ATK, +4% crit. Uses .44 Magnum.",
    slot:"weapon", bonus:{ atk:11, crit:0.04 },
    ammo:{ id:"ammo_44", perShot:1 }
  },

  machine_pistol_38: {
    name:"Machine Pistol",
    desc:"Snappy sidearm. +6 ATK, +2% crit. Uses .38.",
    slot:"weapon", bonus:{ atk:6, crit:0.02 },
    ammo:{ id:"ammo_38", perShot:1 }
  },

  laser_pistol: {
    name:"Laser Pistol",
    desc:"Clean shots, no drop. +9 ATK, +3% crit. Uses Energy Cells.",
    slot:"weapon", bonus:{ atk:9, crit:0.03 },
    ammo:{ id:"energy_cell", perShot:1 }
  },

  laser_rifle: {
    name:"Laser Rifle",
    desc:"Beam-line precision. +11 ATK, +4% crit. Uses Energy Cells.",
    slot:"weapon", bonus:{ atk:11, crit:0.04 },
    ammo:{ id:"energy_cell", perShot:1 }
  },

  med_patch: { 
    name:"Med Patch", desc:"Heals 15 HP.", 
    use:()=>{ heal(15); log("You apply a Med Patch. HP +15."); return true; }
  },

  antirad: { 
    name:"AntiRad", desc:"Reduces RAD by 12.", 
    use:()=>{ derad(12); log("You take AntiRad. RAD -12."); return true; }
  },

  food: { 
    name:"Canned Food", desc:"Heals 4 HP or can be consumed before travel.", 
    use:()=>{ heal(4); log("You eat canned food. HP +4."); return true; }
  },

  holotape: { name:"Ancient Holotape", desc:"Collectors pay well. Can be sold to traders." },

  water_filter:{ 
    name:"Water Filter", 
    desc:"Allows safe refilling of a canteen at events.",
    use:()=>{ 
      if(countItem("canteen") > 0){ 
        heal(5); 
        log("You purify and drink water. HP +5."); 
        return true; 
      } 
      log("You need a canteen to use the Water Filter."); 
      return false;
    }
  },

//////// === Melee weappons 

  scrap_blade: {
    name:"Scrap Blade",
    desc:"A crude melee weapon. Increases combat effectiveness.",
    slot:"weapon",
    bonus:{ atk:5 },
    use:()=>{ equipItem("scrap_blade"); return false; }
  },

machete: {
    name:"Machete",
    desc:"Chopped and ready. +7 ATK.",
    slot:"weapon", bonus:{ atk:7 }
  },
  sledgehammer: {
    name:"Sledgehammer",
    desc:"Hefty bruiser. +12 ATK, -1 AGI.",
    slot:"weapon", bonus:{ atk:12, agi:-1 }
  },
};


// simple recipes: requires → produces
const RECIPES = [
  {id:"repair_kit", name:"Repair Kit", 
   requires:{junk:1, duct_tape:1}, 
   produces:{med_patch:1},
   desc:"1 Junk + 1 Duct Tape → 1 Med Patch"},
  
  {id:"sell_junk", name:"Sell Junk Bundle", 
   requires:{junk:3}, 
   produces:{caps:12},
   desc:"Trade 3 Junk for 12 caps."},

  {id:"craft_blade", name:"Craft Scrap Blade", 
   requires:{junk:2, duct_tape:1}, 
   produces:{scrap_blade:1},
   desc:"2 Junk + 1 Duct Tape → 1 Scrap Blade"}
];

// ========= Equipment System =========
// Tracks equipped gear and bonuses

// expand state on new runs
function initEquipment(){
  if(!state.equipment){
    state.equipment = { head:null, chest:null, legs:null, weapon:null };
  }
}

function equipItem(id){
  const meta = ITEMS[id];
  if(!meta || !meta.slot){ log("That item can’t be equipped."); return false; }

  // unequip existing
  if(state.equipment[meta.slot]){
    addItem(state.equipment[meta.slot], 1);
  }

  // equip new
  state.equipment[meta.slot] = id;
  removeItem(id,1);
  log(`You equipped ${meta.name} in ${meta.slot} slot.`);
  updateUI();
  return true;
}

function unequip(slot){
  if(!state.equipment[slot]){ log("Nothing equipped there."); return false; }
  addItem(state.equipment[slot],1);
  log(`You unequipped ${ITEMS[state.equipment[slot]].name}.`);
  state.equipment[slot] = null;
  updateUI();
  return true;
}

function calcStats(){
  let atk = 0, def = 0, crit = 0, agi = 0;
  for (const slot of Object.keys(state.equipment)){
    const id = state.equipment[slot];
    if(id && ITEMS[id].bonus){
      const b = ITEMS[id].bonus;
      atk += b.atk || 0;
      def += b.def || 0;
      crit += b.crit || 0;
      agi  += b.agi  || 0;
    }
  }
  return {atk, def, crit, agi};
}


function showEquipment(){
  let txt = "Equipped Gear:<br>";
  for(const slot of ["head","chest","legs","weapon"]){
    const id = state.equipment[slot];
    txt += `${slot}: ${id ? ITEMS[id].name : "None"}<br>`;
  }
  return txt;
}


// ========= Inventory Functions (hardened) =========
function inv(){
  if (!Array.isArray(state.inventory)) state.inventory = [];
  sanitizeInventory();                  // ensure invariant every time we read
  return state.inventory;
}

function objectIdToKey(obj){
  // Try to resolve an object to an ITEMS key
  for (const [key, meta] of Object.entries(ITEMS)){
    if (meta === obj) return key;                     // identity match
    if (obj && typeof obj === "object" && obj.name && meta.name === obj.name) return key; // name match
  }
  return null;
}

function pushStackSafe(normalized, id, qty=1){
  // id must be string; qty becomes integer >=1
  if (typeof id !== "string" || !id) return;
  id = slugify(id);
  qty = Math.max(1, Number(qty) || 1);
  const existing = normalized.find(s => s.id === id);
  if (existing) existing.qty += qty;
  else normalized.push({ id, qty });
}

function sanitizeInventory(){
  const src = state.inventory;
  const normalized = [];

  for (const s of src){
    // 1) Simple string: ["junk","duct_tape"]
    if (typeof s === "string"){
      pushStackSafe(normalized, s, 1);
      continue;
    }

    // 2) Proper stack: [{ id:"junk", qty:2 }]
    if (s && typeof s === "object" && "id" in s){
      let id = s.id;
      // rescue if id is an object (e.g., ITEMS.junk)
      if (typeof id !== "string"){
        const rescued = objectIdToKey(id);
        if (!rescued) continue; // skip unrescuable garbage
        id = rescued;
      }
      pushStackSafe(normalized, id, s.qty);
      continue;
    }

    // 3) Meta object itself was pushed (e.g., ITEMS.junk)
    if (s && typeof s === "object" && !Array.isArray(s) && ("name" in s || "desc" in s)){
      const rescued = objectIdToKey(s);
      if (rescued) pushStackSafe(normalized, rescued, 1);
      // if not rescued, drop it silently
      continue;
    }

    // 4) Dictionary shape: [{ junk:2, duct_tape:1 }]
    if (s && typeof s === "object" && !Array.isArray(s)){
      let treated = false;
      for (const [k,v] of Object.entries(s)){
        if (typeof k === "string"){
          pushStackSafe(normalized, k, v);
          treated = true;
        }
      }
      if (treated) continue;
    }

    // Anything else → ignore
  }

  state.inventory = normalized;
}

function findStack(id){
  id = slugify(id);
  return inv().find(s => s.id === id);
}

// for adding items from quests and actions etc
function addItem(id, qty = 1){
  // Coerce various shapes
  if (id && typeof id === "object"){
    // Stack shape
    if ("id" in id && "qty" in id) return addItem(id.id, Number(id.qty) || 1);

    // Meta object (ITEMS.*)
    const rescued = objectIdToKey(id);
    if (rescued) return addItem(rescued, qty);

    // Dictionary: { junk:2, duct_tape:1 }
    const entries = Object.entries(id);
    if (entries.length && entries.every(([k]) => typeof k === "string")){
      for (const [k,v] of entries) addItem(k, Number(v) || 1);
      return;
    }

    console.warn("addItem: unsupported object ignored", id);
    return;
  }

  if (typeof id !== "string" || !id) return;
  id = slugify(id);
  qty = Math.max(1, Number(qty) || 1);

  const it = findStack(id);
  if (it) it.qty += qty;
  else state.inventory.push({ id, qty });
}

function countItem(id){
  const s = findStack(id);
  return s ? s.qty : 0;
}

function removeItem(id, qty = 1){
  id = slugify(id);
  qty = Math.max(1, Number(qty) || 1);

  // Get current stack (this call is fine; it sanitizes once up front)
  const it = findStack(id);
  if (!it) return false;

  it.qty -= qty;

  if (it.qty > 0) return true;

  // Remove the stack entirely by id (no inv() call here)
  state.inventory = Array.isArray(state.inventory)
    ? state.inventory.filter(s => !(s && typeof s === "object" && s.id === id))
    : [];

  return true;
}


// req shape: { itemId: quantity, caps?: number }
function hasItems(req){
  return Object.entries(req).every(([id, n]) =>
    (id === "caps" ? state.caps : countItem(id)) >= n
  );
}

// sign -1 to consume req, +1 to grant req
function applyDelta(req, sign){
  for (const [id, n] of Object.entries(req)){
    if (id === "caps"){ state.caps += sign * n; continue; }
    if (sign < 0) removeItem(id, n); else addItem(id, n);
  }
}

function useItem(id){
  id = slugify(id);
  const meta = ITEMS[id];
  if (!meta || !meta.use){
    log("You can’t use that.");
    return false;
  }
  const ok = meta.use();         // meta.use returns true if consumed
  if (ok) removeItem(id, 1);
  updateUI();
  return ok;
}

function craft(recipeId){
  const r = RECIPES.find(x => x.id === recipeId);
  if (!r){ log("No such recipe."); return; }
  if (!hasItems(r.requires)){ log("Missing ingredients."); return; }

  applyDelta(r.requires, -1);    // consume

  if (r.produces.caps) state.caps += r.produces.caps;
  for (const [id, n] of Object.entries(r.produces)){
    if (id !== "caps") addItem(id, n);
  }

  log(`Crafted: ${r.name}.`);
  updateUI();
}

// ====== Ammo / Weapon helpers ======
function equippedWeaponId(){
  return state?.equipment?.weapon || null;
}
function equippedWeaponMeta(){
  const w = equippedWeaponId();
  return w ? ITEMS[w] : null;
}
function weaponUsesAmmo(meta){
  return !!(meta && meta.ammo && meta.ammo.id);
}
function ammoCount(ammoId){
  return countItem(ammoId);
}
function consumeAmmo(ammoId, n=1){
  n = Math.max(1, Number(n) || 1);
  if (countItem(ammoId) < n) return false; // don't partially consume
  removeItem(ammoId, n);
  return true;
}

/**
 * Returns {atk, def, crit, agi} like calcStats(), but with weapon bonus excluded.
 * Useful when a firearm is out of ammo (melee buttstroke / bash).
 */
function calcStatsWithoutWeapon(){
  let atk = 0, def = 0, crit = 0, agi = 0;
  for (const slot of Object.keys(state.equipment)){
    const id = state.equipment[slot];
    if(!id) continue;
    if (slot === "weapon") continue; // skip weapon bonuses
    const b = ITEMS[id]?.bonus;
    if(!b) continue;
    atk += b.atk || 0;
    def += b.def || 0;
    crit += b.crit || 0;
    agi  += b.agi  || 0;
  }
  return { atk, def, crit, agi };
}

/**
 * Convenience: compute temporary "current attack + crit" applying melee fallback
 * if the equipped weapon is a gun with no ammo.
 * Relies on global calcStats() you already have.
 */
function currentAttackAndCritWithAmmoGate(){
  const base = calcStats(); // includes weapon bonus if any
  const wMeta = equippedWeaponMeta();
  if (!weaponUsesAmmo(wMeta)) {
    return { atk: base.atk, crit: base.crit, usedAmmo:false, out:false, ammoName:null, perShot:0 };
  }
  const ammoId = wMeta.ammo.id;
  const per = Math.max(1, Number(wMeta.ammo.perShot) || 1);
  const have = ammoCount(ammoId);

  if (have >= per){
    // We will consume ammo; caller should actually remove it on successful attack
    return { atk: base.atk, crit: base.crit, usedAmmo:true, out:false, ammoName:ITEMS[ammoId]?.name||ammoId, perShot:per, ammoId };
  } else {
    // Out of ammo → melee fallback (strip weapon's bonus)
    const wAtk  = (wMeta.bonus?.atk || 0);
    const wCrit = (wMeta.bonus?.crit || 0);
    const fallbackAtk  = Math.max(0, base.atk - wAtk);
    const fallbackCrit = Math.max(0, base.crit - wCrit);
    return { atk: fallbackAtk, crit: fallbackCrit, usedAmmo:false, out:true, ammoName:ITEMS[ammoId]?.name||ammoId, perShot:per, ammoId };
  }
}





/* ========= Game Data ========= */
// NOTE: All static game data: names, origins, locations, jobs, factions, perks
// - Add new jobs in JOBS[]
// - Add new factions in FACTIONS[]
// - Add new perks in PERKS[]

const NAMES = ["Ash","Rae","Piper","Vale","Rook","Nova","Jax","Morgan","Quinn","Alex","Harper","Rowan","Kit","Dak","Remy","Skye","Indy","Jet","Mack","Sable","Rune","Tess","Wren","Zed"];
const ORIGINS = ["Wastelander","Settlement Kid","Dust-towner"];
const LOCATIONS = ["Dustown","Ironwood", "Wasteland Dunes", "Cracked Ruins", "Salt Flats", "Red Canyons", "Irrad. Swamp",];
const JOBS = [
  { id:"none",   name:"Unemployed",       minAge:0,  base: 0,              req: ()=>true },

  // Always available at 18+
  { id:"scav",   name:"Scavenger",        minAge:18, base: rnd(10,25),     req: ()=>true },
  { id:"trader", name:"Caravan Trader",   minAge:18, base: rnd(20,40),     req: ()=>true },
  { id:"guard",  name:"Settlement Guard", minAge:18, base: rnd(25,55),     req: ()=>true },
  { id:"scribe", name:"Scribe",           minAge:18, base: rnd(35,70),     req: ()=>true },

  // Only locked job
  { id:"med",    name:"Field Medic",      minAge:18, base: rnd(40,80),     req: s => s.I >= 8 }
];


const FACTIONS = [
  { id:"none", name:"Unaffiliated", req: s=>true, blurb:"You walk your own road." },
  { id:"settlers", name:"Settlers Union", req: s=>s.C>=4, blurb:"Builders and traders striving for stability." },
  { id:"rangers", name:"Desert Rangers", req: s=>s.A>=5 && s.P>=5, blurb:"Lean, disciplined scouts of the wastes." },
  { id:"scribes", name:"Scribes of the Old World", req: s=>s.I>=6, blurb:"Archivists preserving tech and knowledge." },
  { id:"dust_marauders", name:"Dust Marauders", req: s=>s.S>=6 || s.L>=7, blurb:"Lawless plunderers—high risk, high reward." }
];

const PERKS = [
  { id:"toughness", name:"Toughness", desc:"+10 max HP", req:(state)=> state.level>=3 },
  { id:"silverTongue", name:"Silver Tongue", desc:"+15% job pay & trade", req:(state)=> state.special.C>=6 },
  { id:"scrounger", name:"Scrounger", desc:"Better loot on Explore", req:(state)=> state.special.L>=6 },
  { id:"medic", name:"Medic", desc:"Heal more; reduce RAD", req:(state)=> state.special.I>=6 },
  { id:"swift", name:"Swift", desc:"+10% escape chances", req:(state)=> state.special.A>=6 },
];

/* ========= Enemies ========= */
// tier: "wastes" | "work" | "Dust_Marauders" | "rangers" etc.
const ENEMIES = [
  { id:"molerat",    name:"Molerat",    tier:"wastes",  hp:28, atk:6,  def:2,  spd:9,  reward:{ xp:10, caps: rnd(3,7) } },
  { id:"wild_dogs",  name:"Wild Dogs",  tier:"wastes",  hp:34, atk:7,  def:3,  spd:11, reward:{ xp:12, caps: rnd(4,9) } },
  { id:"feral",      name:"Feral Ghoul",tier:"wastes",  hp:40, atk:8,  def:4,  spd:12, reward:{ xp:14, caps: rnd(6,12) } },
  { id:"scav_band",  name:"Scav Bandit",tier:"work",    hp:36, atk:8,  def:4,  spd:10, reward:{ xp:14, caps: rnd(7,13) } },
  { id:"mutant_verm",name:"Mutant Vermin", tier:"wastes", hp:30, atk:7, def:3, spd:13, reward:{ xp:12, caps: rnd(5,10) } },
  { id:"waste_stalker", name:"Wasteland Stalker", tier:"rangers", hp:46, atk:10, def:5, spd:14, reward:{ xp:18, caps: rnd(9,18) } },

// ========= Dust Marauders (Texas Raiders) =========
  { id:"dust_pistolero", name:"Dust Pistolero", tier:"dust_marauders", hp:46, atk:10, def:4, spd:13, reward:{ xp:18, caps: rnd(10,18) } },
  { id:"rust_rider", name:"Rust Rider", tier:"dust_marauders", hp:54, atk:12, def:5, spd:12, reward:{ xp:22, caps: rnd(12,22) } },
  { id:"buckshot_bandit", name:"Buckshot Bandit", tier:"dust_marauders", hp:58, atk:13, def:5, spd:11, reward:{ xp:24, caps: rnd(15,26) } },
  { id:"oilfield_raider", name:"Oilfield Outlaw", tier:"dust_marauders", hp:62, atk:12, def:6, spd:12, reward:{ xp:28, caps: rnd(18,30) } },
  { id:"dust_warlord", name:"Dust Warlord", tier:"dust_marauders", hp:72, atk:14, def:7, spd:13, reward:{ xp:34, caps: rnd(20,36) } },
];

// Simple generator that picks by tier (falls back to wastes)
function generateEnemy(tier="wastes"){
  const pool = ENEMIES.filter(e=>e.tier===tier);
  const base = (pool.length? pool : ENEMIES.filter(e=>e.tier==="wastes"));
  const e = sample(base);
  // Copy with fresh HP so we don’t mutate base definition
  return { ...e, curHP: e.hp };
}


const SPECIAL_KEYS = ["S","P","E","C","I","A","L"];

/* ========= Game State ========= */
let state = null;

function newRun() {
  const name = sample(NAMES);
  const origin = sample(ORIGINS);
  const location = sample(LOCATIONS);
  const S = Object.fromEntries(SPECIAL_KEYS.map(k=>[k, rnd(1,10)]));
  let pool = 5; while (pool--) { const k = sample(SPECIAL_KEYS); S[k] = clamp(S[k]+1,1,10); }

  state = {
    alive: true,
    year: 2165,
    age: 18,
    name, origin, location,
    special: S,
    hp: 100, hpMax: 100,
    rad: 0,
    caps: rnd(5,25),
    karma: 0,
    level: 1, xp: 0,
    job: "none",
    faction: "none",
    inventory: ["Canteen","Junk","Duct Tape","Knife",],
    perks: [],
    pendingChoice: null,
    log: [],
    factionRep: 0,
    factionActionUsed: false,
    equipment: { head:null, chest:null, legs:null, weapon:null },
    battlesWon: 0,
    battlesLost: 0,
    buffs: { radShield:{turns:0}, fleeBoost:0, atkBoost:0, strEnd:0, percInt:0 },
  };

  // Initialize per-faction growth state when starting a new run
  initFactionState();
  // Initialize settlement/base state for this run
  if (typeof initSettlement === "function") initSettlement();

  log(`You begin at age 18...`);
  log(`Your S.P.E.C.I.A.L.: ${SPECIAL_KEYS.map(k => k + ":" + state.special[k]).join(" ")}`, "muted");
  updateUI();
}







// === Save & Load (top level) ===
function saveGame() {
  try {
    // (Optional) Skinny the log so saves stay small:
    // const trimmed = { ...state, log: state.log.slice(0, 200) };
    localStorage.setItem("wastelifeSave", JSON.stringify(state));
    log("Game saved.");
    return true;
  } catch (e) {
    console.error("Save failed:", e);
    log("Save failed.");
    return false;
  }
}

function loadGame() {
  try {
    const raw = localStorage.getItem("wastelifeSave");
    if (!raw) return false;
    state = JSON.parse(raw);
    updateUI();
    log("Game loaded.");
    return true;
  } catch (e) {
    console.error("Load failed:", e);
    log("Load failed.");
    return false;
  }
}

// === Boot once DOM is ready ===
document.addEventListener("DOMContentLoaded", () => {
  // Wire button handlers ONCE
  $("#btn-save").onclick  = () => saveGame();
  $("#btn-load").onclick  = () => loadGame() || log("No saved game found.");
  $("#btn-reset").onclick = () => { newRun(); saveGame(); };

  // Try to restore; otherwise start fresh
  if (!loadGame()) newRun();

  // iOS-friendly autosave
  window.addEventListener("pagehide", () => { try { saveGame(); } catch(e){} }, { passive:true });
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden") { try { saveGame(); } catch(e){} }
  });
});

function storageOK(){
  try {
    localStorage.setItem("__wl_test","1");
    localStorage.removeItem("__wl_test");
    return true;
  } catch { return false; }
}

document.addEventListener("DOMContentLoaded", () => {
  if (!storageOK()) {
    log("Saving is blocked on this browser (private mode / file:// / iframe).");
  }
  // ... your existing boot code ...
});





/* ========= UI ========= */
function updateUI() {
  $("#name").textContent = state.name;
  $("#age").textContent = state.age;
  $("#caps").textContent = state.caps;
  $("#karma").textContent = state.karma;
  $("#level").textContent = state.level;
  $("#xp").textContent = state.xp;
  $("#hp").textContent = `${state.hp}/${state.hpMax}`;
  $("#rad").textContent = state.rad;
  $("#origin").textContent = state.origin;
  $("#job").textContent = getJob().name;
  $("#location").textContent = state.location;
  $("#year").textContent = state.year;
  $("#header-status").textContent = state.alive ? "alive" : "deceased";

  // Update the sidebar button label based on faction status
  const joinBtn = $("#btn-join-faction");
  if (joinBtn) {
    joinBtn.textContent = (state.faction === "none")
      ? "Join a Faction"
      : "View Faction";
  }


  // --- Faction pill update ---
  const f = getFaction();
  const pillWrap = $("#faction-pill-wrapper");

  if (state.faction === "none") {
    $("#faction-pill").textContent = "Unaffiliated";
  } else {
    $("#faction-pill").textContent = `${f.name} (Rep ${state.factionRep})`;
  }

  // reset + apply faction color class
  pillWrap.classList.remove(
    "faction-settlers","faction-rangers","faction-scribes","faction-Dust_Marauders","faction-none"
  );
  pillWrap.classList.add("faction-" + state.faction);

  // --- S.P.E.C.I.A.L. bars ---
  const wrap = $("#special");
  wrap.innerHTML = "";
  SPECIAL_KEYS.forEach(k => {
    const v = state.special[k];
    const s = el("div", "stat");
    const lbl = el("div","stat-label");
    lbl.append(el("span", null,
      k==="S"?"Strength":k==="P"?"Perception":k==="E"?"Endurance":
      k==="C"?"Charisma":k==="I"?"Intelligence":k==="A"?"Agility":"Luck"
    ));
    lbl.append(el("span", null, v + "/10"));
    const bar = el("div","bar" + (v<=3?" danger": v<=5?" warn":""));
    const fill = el("i"); fill.style.width = (v*10) + "%";
    bar.append(fill);
    s.append(lbl, bar);
    wrap.append(s);
  });

  // disable actions if pending choice or dead
  const disable = !!state.pendingChoice || !state.alive;
  ["#btn-age","#btn-explore","#btn-work","#btn-heal", "#btn-inventory","#btn-join-faction","#btn-perks"]
    .forEach(sel => { $(sel).disabled = disable; $(sel).style.opacity = disable? .6 : 1; });

  // death checks
  if (state.alive && (state.hp<=0 || state.rad>=100 || state.age>=120)) {
    die();
  }
}


function log(text, cls) {
  const entry = el("div","entry"+(cls? " "+cls:""));
  const p = el("p", null, text);
  entry.append(p);
  $("#log").prepend(entry);
  state.log.push(text);
}

function info(text){ log(text,"muted") }

function getJob(){ return JOBS.find(j=>j.id===state.job) || JOBS[0]; }
function getFaction(){ return FACTIONS.find(f=>f.id===state.faction) || FACTIONS[0]; }

/* ========= Mechanics (leveled combat power) ========= */
function gainXP(n) {
  state.xp += n;
  while (state.xp >= needXP(state.level)) {
    state.xp -= needXP(state.level);
    state.level++;

    // Core survivability bump each level
    const hpGain = 6;                 // was +5
    state.hpMax += hpGain;
    state.hp = Math.min(state.hpMax, state.hp + Math.ceil(hpGain / 2));

    // Combat power: SPECIAL growth (feeds into ATK/DEF/SPD/CRIT)
    applyLevelBonuses(state.level);

    log(`Level up! You are now level ${state.level}. Max HP +${hpGain}.`);
  }
  updateUI();
}

// Slightly steeper XP curve to pace the extra power
function needXP(level){ return 50 + level * 30; }  // was 25/level

function changeKarma(n){
  state.karma = clamp(state.karma + n, -100, 100);
}

/* ---- Level-up helpers ---- */

// Job-flavoured stat growth + milestone bumps.
// Keeps numbers small, capped at 10, but makes you meaningfully stronger over time.
function applyLevelBonuses(level){
  const job = (getJob()?.id) || "none";

  // Primary/secondary per job (affects playerBattleStats downstream)
  const primary = job === "guard"  ? "S" :
                  job === "scav"   ? "P" :
                  job === "trader" ? "C" :
                  job === "scribe" ? "I" :
                  job === "med"    ? "I" : "A";

  const secondary = job === "guard"  ? "E" :
                    job === "scav"   ? "A" :
                    job === "trader" ? "L" :
                    job === "scribe" ? "P" :
                    job === "med"    ? "P" : "S";

  // Always +1 to your primary each level
  bumpSPECIAL(primary, +1, `+1 ${fullName(primary)}`);

  // Every 3 levels: +1 to your secondary
  if (level % 3 === 0) bumpSPECIAL(secondary, +1, `+1 ${fullName(secondary)}`);

  // Every 5 levels: +1 Luck (nudges crit & events)
  if (level % 5 === 0) bumpSPECIAL("L", +1, "+1 Luck");

  // Gentle pacing boost: every even level +1 Agility (helps SPD/flee)
  if (level % 2 === 0) bumpSPECIAL("A", +1, "+1 Agility");
}

function bumpSPECIAL(k, delta, note){
  if (!SPECIAL_KEYS.includes(k)) return;
  const before = state.special[k];
  state.special[k] = clamp(state.special[k] + delta, 1, 10);
  if (state.special[k] !== before) {
    info(`Level bonus: ${note}`);
  }
}

function fullName(k){
  return k==="S"?"Strength" :
         k==="P"?"Perception" :
         k==="E"?"Endurance" :
         k==="C"?"Charisma" :
         k==="I"?"Intelligence" :
         k==="A"?"Agility" : "Luck";
}


  // ========= Yearly Event Pool =========
  // NOTE: Events are chosen from this pool each year
  // - Add new events into pool.push() based on age or faction

function yearlyEvent() {
  const a = state.age;
  const pool = [];

  // universal
  pool.push(evt_findStash, evt_radStorm, evt_tradeOffer, evt_bandits, evt_sick, evt_helpStranger, evt_mysteriousStranger);

  if (a <= 12) {
    pool.push(evt_schoolyard, evt_vaultDrill);
  } else if (a <= 18) {
    pool.push(evt_sneakOut, evt_training, evt_firstJob);
  } else {
    pool.push(evt_workAccident, evt_factionScout, evt_repairOldTech);
  }
  // faction flavored
  if (state.faction==="rangers") pool.push(evt_rangerPatrol);
  if (state.faction==="scribes") pool.push(evt_lostArchive);
  if (state.faction==="Dust_Marauders") pool.push(evt_shakedown);

  const e = sample(pool);
  return e();
}

function setChoice(prompt, choices) {
  state.pendingChoice = { prompt, choices };
  renderChoice();
  updateUI();
}

function renderChoice() {
  const c = state.pendingChoice;
  if (!c) return;

  const entry = el("div","entry");
  entry.append(el("p",null, c.prompt));
  const box = el("div","choices");

  c.choices.forEach(choice => {
    const b = el("button","choice", choice.label);
    b.onclick = () => {
      // guard against double clicks
      if (entry.dataset.resolved === "1") return;
      entry.dataset.resolved = "1";
      entry.classList.add("resolved");

      // immediately disable all buttons in this choice block
      box.querySelectorAll("button").forEach(btn => { btn.disabled = true; });

      try { choice.run(); }
      catch(e){ console.error(e); log("Something went wrong with that choice.","muted"); }

      state.pendingChoice = null;
      updateUI();
    };
    box.append(b);
  });

  entry.append(box);
  $("#log").prepend(entry);
}


/* ========= Events ========= */
function skillCheck(key, diff){
  const roll = rnd(1,10) + (state.perks.includes("swift") && key==="A" ? 1 : 0);
  const total = state.special[key] + roll;
  return total >= diff;
}

function money(mult=1){
  let base = rnd(5, 25);
  if (state.perks.includes("silverTongue")) base = Math.round(base * 1.15);
  if (state.perks.includes("scrounger")) base = Math.round(base * 1.25);
  return Math.round(base * mult);
}

function damage(n){
  state.hp = clamp(state.hp - n, 0, state.hpMax);
  updateUI();
}
function heal(n){
  state.hp = clamp(state.hp + n, 0, state.hpMax);
  updateUI();
}
function rad(n){
  let amt = n;
  if (state.buffs?.radShield?.turns > 0) amt = Math.ceil(n * 0.5);
  state.rad = clamp(state.rad + amt, 0, 100);
  updateUI();
}
function derad(n){
  state.rad = clamp(state.rad - n, 0, 100);
  updateUI();
}
function addCaps(amount){
  state.caps += amount;
  updateUI();
}



// NOTE: Each evt_* function defines one scenario with choices
// - Add new events here
// - Use setChoice() to present options

function evt_findStash(){
  const amt = money(1 + (state.special.L/20));
  setChoice(
    "You discover a hidden cache behind a cracked wall.",
    [
      { label:`Loot it (+${amt} caps, +XP)`, run:()=>{ state.caps+=amt; gainXP(12); log(`You pocket ${amt} caps and a few trinkets.`);} },
      { label:"Leave it (Karma +3)", run:()=>{ changeKarma(+3); log("You leave it for someone in greater need."); gainXP(5);} }
    ]
  );
}

function evt_radStorm(){
  setChoice("A radiation storm rolls over the wastes.", [
    { label:"Find shelter (P+E check)", run:()=>{
      if (skillCheck("P",12) && skillCheck("E",12)){ log("You hunker down safely. XP +10."); gainXP(10); }
      else { log("You fail to find proper cover. RAD +12, HP -5."); rad(12); damage(5); }
    }},
    { label:"Push through (-HP, +XP)", run:()=>{ damage(10); rad(6); gainXP(15); log("You brave the storm and make progress."); } }
  ]);
}

function evt_tradeOffer(){
  const price = rnd(12,28);
  setChoice("A caravan offers a water filter.", [
    { label:`Buy (${price} caps)`, run:()=>{
      if (state.caps>=price){ state.caps-=price; addItem("water_filter",1); log("You buy the filter. Hydration secured."); changeKarma(+1); }
      else { log("Not enough caps."); }
    }},
    { label:"Haggle (C check)", run:()=>{
      if (skillCheck("C", 12)){ const p = Math.max(4, price-8); log(`You talk them down to ${p} caps.`); state.caps = Math.max(0, state.caps - p); changeKarma(+1); }
      else { log("Your haggling backfires. Price goes up 5 caps."); const p=price+5; if (state.caps>=p){ state.caps-=p; log("You begrudgingly pay."); } else log("You walk away."); }
    }},
    { label:"Pass", run:()=>{ log("You pass on the offer."); } }
  ]);
}

function evt_bandits(){
  setChoice("Bandits block your path and demand caps.", [
    { label:"Fight (S+A check)", run:()=>{
      const ok = skillCheck("S",12) && skillCheck("A",12);
      if (ok){ log("You outmaneuver them. XP +20, caps +"+money(1.2)); state.caps+=money(1.2); gainXP(20); changeKarma(+1);}
      else { log("They rough you up. HP -15, caps -10."); damage(15); state.caps=Math.max(0, state.caps-10); changeKarma(-1); }
    }},
    { label:"Flee (A check)", run:()=>{
      const ok = skillCheck("A", 13 - (state.perks.includes("swift")?1:0));
      if (ok){ log("You slip away into the ruins. XP +12."); gainXP(12); }
      else { log("You stumble. HP -8, caps -6."); damage(8); state.caps=Math.max(0, state.caps-6); }
    }},
    { label:"Pay 12 caps", run:()=>{
      const cost=12; if (state.caps>=cost){ state.caps-=cost; log("They let you pass."); changeKarma(-1);}
      else log("You don't have enough. They laugh and shove you.");
    }},
  ]);
}

function evt_sick(){
  setChoice("You fall ill after drinking questionable water.", [
    { label:"Rest (-work this year, +HP)", run:()=>{ heal(8); log("You rest and recover a bit. XP +5."); gainXP(5); } },
    { label:"Self-medicate (I check)", run:()=>{
      if (skillCheck("I",12)){ heal(10); derad(5); log("You successfully treat yourself."); gainXP(10); }
      else { damage(8); rad(6); log("Treatment goes poorly."); }
    }},
  ]);
}

function evt_helpStranger(){
  setChoice("A wounded stranger begs for help.", [
    { label:"Help (Karma +5, -time)", run:()=>{ changeKarma(+5); gainXP(10); heal(5); log("They thank you and hand you a trinket (+5 caps)."); state.caps+=5; } },
    { label:"Ignore (Karma -5)", run:()=>{ changeKarma(-5); log("You move on."); } }
  ]);
}

function evt_mysteriousStranger(){
  if (rnd(1,100) <= (5 + state.special.L)) {
    const amt = money(2.0);
    setChoice("A mysterious figure nods and vanishes.", [
      { label:`Check your pocket (+${amt} caps)`, run:()=>{ state.caps+=amt; log("A note reads: “Make your own luck.”"); } }
    ]);
  } else {
    return evt_findStash();
  }
}

function evt_schoolyard(){
  setChoice("At the settlement school, a radroach skitters by.", [
    { label:"Stomp it (S check)", run:()=>{ if (skillCheck("S",10)){ gainXP(6); log("Splat. The class cheers."); } else { damage(2); log("It nips you. Ouch."); } } },
    { label:"Observe (I +1)", run:()=>{ state.special.I = clamp(state.special.I+1,1,10); gainXP(4); log("You study its behavior. +1 INT."); } },
    { label:"Run (A +1)", run:()=>{ state.special.A = clamp(state.special.A+1,1,10); log("You’re quick on your feet. +1 AGI."); } },
  ]);
}

function evt_vaultDrill(){
  setChoice("Vault safety drill time.", [
    { label:"Lead classmates (C +1)", run:()=>{ state.special.C = clamp(state.special.C+1,1,10); log("You take charge. +1 CHA."); } },
    { label:"Carry supplies (S +1)", run:()=>{ state.special.S = clamp(state.special.S+1,1,10); log("Heavy lifting builds muscle. +1 STR."); } },
  ]);
}

function evt_sneakOut(){
  setChoice("Friends want to sneak out after curfew.", [
    { label:"Go (A check)", run:()=>{ if (skillCheck("A",12)){ gainXP(8); log("You make it back unseen."); } else { damage(6); log("You trip over debris and get scraped."); } } },
    { label:"Decline (Karma +2)", run:()=>{ changeKarma(+2); log("You decide against it."); } },
  ]);
}

function evt_training(){
  setChoice("A mentor offers combat drills.", [
    { label:"Train (S +1 or A +1)", run:()=>{ if (Math.random()<.5) { state.special.S=clamp(state.special.S+1,1,10); log("+1 STR."); } else { state.special.A=clamp(state.special.A+1,1,10); log("+1 AGI."); } gainXP(10); } },
    { label:"Study tactics (I +1)", run:()=>{ state.special.I=clamp(state.special.I+1,1,10); gainXP(8); log("+1 INT."); } },
  ]);
}

function evt_firstJob(){
  if (state.age>=14 && state.job==="none"){
    setChoice("You’re old enough to work. Pick a path?", [
      ...JOBS.filter(j=>j.id!=="none" && j.minAge<=state.age && j.req(state.special))
        .map(j=>({label:j.name, run:()=>{ state.job = j.id; log(`You start as a ${j.name}.`); gainXP(10);} })),
      {label:"Not now", run:()=>{ log("You put it off."); }}
    ]);
  } else {
    return evt_training();
  }
}

function evt_workAccident(){
  setChoice("A workplace mishap occurs.", [
    { label:"React fast (A check)", run:()=>{ if (skillCheck("A",12)){ log("You prevent injury. XP +10."); gainXP(10);} else { damage(10); log("You get hurt. HP -10."); } } },
    { label:"Shield others (Karma +3)", run:()=>{ changeKarma(+3); damage(6); gainXP(8); log("You protect coworkers."); } }
  ]);
}

function evt_factionScout(){
  if (state.faction==="none"){
    setChoice("A faction scout sizes you up.", [
      { label:"Hear them out", run:()=>{ openJoinFaction(); } },
      { label:"Ignore", run:()=>{ log("Maybe another time."); } }
    ]);
  } else {
    return evt_repairOldTech();
  }
}

function evt_repairOldTech(){
  setChoice("You find a busted pre-war device.", [
    { label:"Tinker (I check)", run:()=>{ if (skillCheck("I",13)){ gainXP(16); state.caps+=money(1.3); log("It whirs to life. You sell parts for caps."); } else { damage(4); log("It sparks and bites you."); } } },
    { label:"Salvage (+caps, +RAD)", run:()=>{ state.caps+=money(1.1); rad(6); log("Profitable, but dirty work."); } },
  ]);
}

function evt_rangerPatrol(){
  setChoice("On patrol, you spot movement.", [
    { label:"Investigate (P check)", run:()=>{ if (skillCheck("P",12)){ gainXP(12); log("It’s a harmless critter. All clear."); } else { damage(6); log("Ambush! You’re grazed."); } } },
    { label:"Radio in (+Karma)", run:()=>{ changeKarma(+2); gainXP(8); log("Teamwork keeps people safe."); } }
  ]);
}

function evt_lostArchive(){
  setChoice("A rumor about a hidden archive spreads among Scribes.", [
    { label:"Research (I +1)", run:()=>{ state.special.I=clamp(state.special.I+1,1,10); gainXP(14); log("Clues emerge. +1 INT."); } },
    { label:"Field search (E check)", run:()=>{ if (skillCheck("E",12)){ gainXP(16); addItem("holotape",1); log("You recover an old holotape."); } else { rad(8); log("The trail leads through hot zones. RAD +8."); } } },
  ]);
}

function evt_shakedown(){
  setChoice("Your crew eyes a shakedown opportunity.", [
    { label:"Intimidate (C check)", run:()=>{ 
        if (skillCheck("C",12)){ state.caps+=money(1.4); changeKarma(-5); log("You score loot, but word spreads. Karma -5."); } 
        else { log("They weren’t impressed. Awkward."); } 
      } 
    },
    { label:"Pass (Karma +2)", run:()=>{ changeKarma(+2); log("You keep the peace—for now."); } }
  ]);
} // <-- this closing brace was missing

// One-click actions for each faction (shown in the Faction menu after you join)
// ========= Faction Actions =========
// NOTE: Each faction has repeatable actions here
// - Add new actions inside settlers/rangers/scribes/Dust_Marauders arrays
// - Use changeRep() and changeKarma() for outcomes

const FACTION_ACTIONS = {
  settlers: [
    {
      label: "Escort a trade caravan",
      run: () => {
        // 30% chance the escort turns into a fight (wastes-tier enemy)
        if (maybeStartCombat(0.30, "wastes", "faction")) return;

        const ambush = rnd(1,100) < 35;
        const pay = money(1.1) + 5;
        state.caps += pay;
        changeRep(+3);
        changeKarma(+1);
        gainXP(10);
        log(`You escort a caravan. +${pay} caps, +rep, +karma.`);
        if (ambush) {
          if (skillCheck("A",12)) {
            log("Bandit ambush avoided.");
            gainXP(6);
          } else {
            damage(6);
            log("Ambushed on the road. HP -6.");
          }
        }
      }
    },
    {
      label: "Help build defenses (cost 8 caps)",
      run: () => {
         // Small chance a Dust Marauder scout pokes the line
        if (maybeStartCombat(0.15, "Dust_Marauders", "faction")) return;
        if (state.caps < 8) { log("Not enough caps for materials."); return; }
        state.caps -= 8;
        changeRep(+4);
        gainXP(12);
        log("You reinforce palisades and set traps. +rep, +XP.");
      }
    },
    {
      label: "Work the fields",
      run: () => {
           // Vermin encounter, low chance
        if (maybeStartCombat(0.12, "wastes", "faction")) return;
        const harvest = rnd(2,5);
        state.caps += harvest;
        changeRep(+2);
        changeKarma(+1);
        gainXP(8);
        log(`You toil in the fields. Earned ${harvest} caps, gained trust and karma.`);
      }
    },
    {
      label: "Teach survival skills",
      run: () => {
        changeRep(+3);
        changeKarma(+2);
        gainXP(15);
        log("You show settlers how to purify water and forage safely. +rep, +karma, +XP.");
      }
    }
  ],

  rangers: [
    {
      label: "Perimeter patrol",
      run: () => {
         // Patrols should fight sometimes
        if (maybeStartCombat(0.25, "rangers", "faction")) return;
        if (skillCheck("P",12)) {
          gainXP(12);
          changeRep(+3);
          log("Quiet patrol. You spot tracks and report in. +rep, +XP.");
        } else {
          damage(4);
          gainXP(8);
          log("You spring a snare. HP -4, +XP.");
        }
      }
    },
    {
      label: "Track Dust Marauders",
      run: () => {
          // High chance of Dust_Marauders combat
        if (maybeStartCombat(0.50, "Dust_Marauders", "faction")) return;
        const tough = !skillCheck("A",13) || !skillCheck("S",12);
        if (tough) {
          damage(10);
          log("Skirmish turns nasty. HP -10.");
        } else {
          const bounty = money(1.3);
          state.caps += bounty;
          changeRep(+5);
          gainXP(16);
          log(`Successful interdiction. +${bounty} caps, +rep, +XP.`);
        }
      }
    },
    {
      label: "Scout dangerous territory",
      run: () => {
         // Chance of hostile wildlife
        if (maybeStartCombat(0.30, "wastes", "faction")) return;
        const find = rnd(1,100) < 40;
        if (find) {
          const loot = money(1.0) + 3;
          state.caps += loot;
          gainXP(10);
          changeRep(+2);
          log(`You map new ground and recover salvage. +${loot} caps, +rep, +XP.`);
        } else {
          damage(5);
          gainXP(6);
          log("You blunder into a mutant nest. HP -5, +XP.");
        }
      }
    },
    {
      label: "Train recruits",
      run: () => {
        changeRep(+4);
        gainXP(14);
        log("You drill fresh recruits in marksmanship and survival. +rep, +XP.");
      }
    }
  ],

  scribes: [
    {
      label: "Research pre-war schematics",
      run: () => {
        if (skillCheck("I",12)) {
          gainXP(16);
          changeRep(+3);
          log("Breakthrough! +rep, +XP.");
        } else {
          log("You hit a dead end in the archives.");
        }
      }
    },
    {
      label: "Field retrieval (hot zone)",
      run: () => {
         // Retrievals can pull a fight (ghouls/vermin)
        if (maybeStartCombat(0.35, "wastes", "faction")) return;
        if (skillCheck("E",12)) {
          addItem("holotape",1);
          gainXP(14);
          changeRep(+4);
          log("Recovered an intact holotape. +rep, +XP.");
        } else {
          rad(8);
          log("Radiation pockets slow you. RAD +8.");
        }
      }
    },
    {
      label: "Repair salvaged tech",
      run: () => {
        if (skillCheck("I",13)) {
          const reward = money(1.2) + 4;
          state.caps += reward;
          gainXP(12);
          changeRep(+2);
          log(`You restore a working device. +${reward} caps, +rep, +XP.`);
        } else {
          log("Your repair attempt fails — components fried.");
        }
      }
    },
    {
      label: "Teach wastelanders literacy",
      run: () => {
        gainXP(10);
        changeRep(+5);
        changeKarma(+2);
        log("You hold lessons in reading and history. +rep, +karma, +XP.");
      }
    }
  ],

  dust_marauders: [
    {
      label: "Shakedown a toll post",
      run: () => {
          // Sometimes enforcers show up to stop you
        if (maybeStartCombat(0.25, "rangers", "faction")) return;
        const haul = money(1.4);
        state.caps += haul;
        changeRep(+4);
        changeKarma(-6);
        log(`Your cut from the tolls: +${haul} caps. Karma -6, +rep.`);
      }
    },
    {
      label: "Raid a convoy",
      run: () => {
          // Often becomes a battle
        if (maybeStartCombat(0.60, "Dust_Marauders", "faction")) return;
        const fail = !skillCheck("S",12) || !skillCheck("A",12);
        if (fail) {
          damage(12);
          log("The guards were ready. HP -12.");
          changeRep(-1);
        } else {
          const loot = money(1.8);
          state.caps += loot;
          gainXP(16);
          changeRep(+6);
          changeKarma(-8);
          log(`Convoy cracked. +${loot} caps, +rep, Karma -8, +XP.`);
        }
      }
    },
    {
      label: "Extort a settlement",
      run: () => {
         // Sometimes defenders push back
        if (maybeStartCombat(0.30, "settlers", "faction")) return;
        const payout = money(1.2) + 8;
        state.caps += payout;
        changeRep(+5);
        changeKarma(-10);
        gainXP(12);
        log(`The settlers pay up. +${payout} caps, +rep, Karma -10, +XP.`);
      }
    },
    {
      label: "Pit fight",
      run: () => {
          // Rarely, a rival champion steps in (treated as Dust_Marauders tier)
        if (maybeStartCombat(0.20, "Dust_Marauders", "faction")) return;
        const win = skillCheck("S",13) || skillCheck("A",13);
        if (win) {
          const prize = money(1.5) + 5;
          state.caps += prize;
          changeRep(+3);
          gainXP(14);
          changeKarma(-4);
          log(`You win the brawl. +${prize} caps, +rep, Karma -4, +XP.`);
        } else {
          damage(10);
          log("You get beaten bloody in the pit. HP -10.");
        }
      }
    }
  ]
}; // <-- end FACTION_ACTIONS

/*
 * Extra faction actions that unlock as factions grow
 * Each entry contains a required minimum level and an action definition.
 * The getFactionActions() helper (defined later) will append these actions
 * when the corresponding faction’s level meets or exceeds the threshold.
 */
const FACTION_EXTRA_ACTIONS = {
  settlers: [
    { level: 3, action: {
        label: "Establish trade route",
        run: () => {
          // Help open a new trade corridor. Small chance of bandit attack.
          if (maybeStartCombat(0.20, "Dust_Marauders", "faction")) return;
          const earn = money(1.3) + 8;
          state.caps += earn;
          changeRep(+4);
          changeKarma(+1);
          gainXP(12);
          log(`You negotiate and protect a new trade route. +${earn} caps, +rep, +karma, +XP.`);
        }
      }
    },
    { level: 5, action: {
        label: "Fortify remote outpost",
        run: () => {
          if (state.caps < 10) { log("You need 10 caps to help fortify the outpost."); return; }
          // Chance of Dust Marauder scouts interrupting the work
          if (maybeStartCombat(0.25, "Dust_Marauders", "faction")) return;
          state.caps -= 10;
          changeRep(+6);
          gainXP(16);
          // Grow Settlers territory when fortifying an outpost
          if (state.factions && state.factions.settlers) {
            state.factions.settlers.territory = (state.factions.settlers.territory || 1) + 1;
          }
          log("You strengthen a far-flung outpost. The Settlers gain territory. +rep, +XP.");
        }
      }
    },
    { level: 7, action: {
        label: "Organize alliance",
        run: () => {
          changeRep(+8);
          changeKarma(+3);
          gainXP(20);
          log("You broker an alliance between settlements. The Union's influence soars. +rep, +karma, +XP.");
        }
      }
    }
  ],
  rangers: [
    { level: 3, action: {
        label: "Coordinate patrol sweep",
        run: () => {
          // Slightly higher chance of a patrol encounter
          if (maybeStartCombat(0.30, "rangers", "faction")) return;
          if (skillCheck("P", 13)) {
            changeRep(+4);
            gainXP(14);
            log("You lead a coordinated sweep, spotting threats early. +rep, +XP.");
          } else {
            damage(5);
            gainXP(8);
            log("Your sweep hits a trap. HP -5, +XP.");
          }
        }
      }
    },
    { level: 5, action: {
        label: "Major anti-raider operation",
        run: () => {
          // Large scale operation against raider bands
          if (maybeStartCombat(0.65, "Dust_Marauders", "faction")) return;
          const haul = money(1.5) + 10;
          state.caps += haul;
          changeRep(+6);
          changeKarma(+2);
          gainXP(18);
          log(`You spearhead a major operation against raiders. +${haul} caps, +rep, +karma, +XP.`);
        }
      }
    },
    { level: 7, action: {
        label: "Secure wastes region",
        run: () => {
          // Pacify a dangerous area; occasional wildlife attack
          if (maybeStartCombat(0.40, "wastes", "faction")) return;
          changeRep(+10);
          changeKarma(+3);
          gainXP(22);
          if (state.factions && state.factions.rangers) {
            state.factions.rangers.territory = (state.factions.rangers.territory || 1) + 1;
          }
          log("You lead an expedition to pacify a large swath of the wastes. The Rangers expand their patrol zones. +rep, +karma, +XP.");
        }
      }
    }
  ],
  scribes: [
    { level: 3, action: {
        label: "Restore old archive",
        run: () => {
          // Costs a bit of funding to restore tech
          if (state.caps < 8) { log("You need 8 caps to purchase tools for the restoration."); return; }
          if (maybeStartCombat(0.10, "wastes", "faction")) return;
          state.caps -= 8;
          changeRep(+5);
          gainXP(16);
          if (typeof addItem === "function") addItem("holotape", 1);
          log("You help restore an archive, uncovering lost data. +rep, +XP, found a holotape.");
        }
      }
    },
    { level: 5, action: {
        label: "Prototype testing",
        run: () => {
          if (state.caps < 10) { log("You need 10 caps for materials for the prototype test."); return; }
          state.caps -= 10;
          if (maybeStartCombat(0.20, "wastes", "faction")) return;
          if (skillCheck("I", 13)) {
            changeRep(+6);
            gainXP(18);
            if (typeof addItem === "function") addItem("laser_pistol", 1);
            log("The prototype works! You secure a laser pistol. +rep, +XP.");
          } else {
            rad(6);
            log("The prototype sputters and leaks radiation. RAD +6.");
          }
        }
      }
    },
    { level: 7, action: {
        label: "Major research breakthrough",
        run: () => {
          if (state.caps < 14) { log("You need 14 caps to fund the breakthrough."); return; }
          state.caps -= 14;
          if (maybeStartCombat(0.20, "wastes", "faction")) return;
          changeRep(+8);
          changeKarma(+3);
          gainXP(24);
          if (typeof addItem === "function") addItem("laser_rifle", 1);
          log("Your research unlocks a pre-war weapon: a laser rifle! +rep, +karma, +XP.");
        }
      }
    }
  ],
  dust_marauders: [
    { level: 3, action: {
        label: "Territory expansion raid",
        run: () => {
          // High risk raid to seize land
          if (maybeStartCombat(0.50, "Dust_Marauders", "faction")) return;
          const loot = money(1.6) + 7;
          state.caps += loot;
          changeRep(+5);
          changeKarma(-6);
          gainXP(14);
          if (state.factions) {
            // Expand Marauders territory and shrink Settlers territory
            if (state.factions.dust_marauders) {
              state.factions.dust_marauders.territory = (state.factions.dust_marauders.territory || 1) + 1;
            }
            if (state.factions.settlers) {
              state.factions.settlers.territory = Math.max(1, (state.factions.settlers.territory || 1) - 1);
            }
          }
          log(`You raid new lands. +${loot} caps, +rep, Karma -6, +XP. Dust Marauders expand their territory.`);
        }
      }
    },
    { level: 5, action: {
        label: "Council of War",
        run: () => {
          if (state.caps < 8) { log("You need 8 caps to fund the council's bribes."); return; }
          state.caps -= 8;
          // Some ranger patrols may interfere
          if (maybeStartCombat(0.30, "rangers", "faction")) return;
          changeRep(+6);
          changeKarma(-8);
          gainXP(18);
          if (state.factions && state.factions.dust_marauders) {
            state.factions.dust_marauders.power = (state.factions.dust_marauders.power || 10) + 5;
          }
          log("You broker deals and secure resources. The war council swells your faction's power. +rep, +karma, +XP.");
        }
      }
    },
    { level: 7, action: {
        label: "Launch war campaign",
        run: () => {
          // Near certain battle; measure success by skill
          if (maybeStartCombat(0.80, "Dust_Marauders", "faction")) return;
          const success = skillCheck("S", 14) || skillCheck("A", 14);
          if (success) {
            const loot = money(2.0) + 15;
            state.caps += loot;
            changeRep(+8);
            changeKarma(-12);
            gainXP(22);
            if (state.factions && state.factions.dust_marauders) {
              state.factions.dust_marauders.power = (state.factions.dust_marauders.power || 10) + 8;
            }
            log(`Your war campaign conquers towns. +${loot} caps, +rep, Karma -12, +XP. Power surge.`);
          } else {
            damage(12);
            changeRep(-2);
            log("The campaign stalls; your wounds slow you. HP -12.");
          }
        }
      }
    }
  ]
};

/*
 * Initialize faction state at the start of a new game or when loading an old save.
 * Each faction gets default values for level, power, territory, and resources.
 */
function initFactionState() {
  if (!state) return;
  state.factions = state.factions || {};
  // Create entries for each faction except "none"
  FACTIONS.filter(f => f.id !== "none").forEach(f => {
    const fid = f.id;
    if (!state.factions[fid]) state.factions[fid] = {};
    const fs = state.factions[fid];
    if (typeof fs.level !== "number") fs.level = 1;
    if (typeof fs.power !== "number") fs.power = 10;
    if (typeof fs.territory !== "number") fs.territory = 1;
    if (typeof fs.resources !== "number") fs.resources = 10;
  });
}

/*
 * Update factions once per year. This function is called from ageUp().
 * Factions gain levels, power, territory, and resources over time. The
 * player’s reputation with their faction improves slightly when their
 * faction levels up. Growth events are logged for immersion.
 */
function updateFactions() {
  if (!state || !state.factions) return;
  for (const fid in state.factions) {
    if (fid === "none") continue;
    const fs = state.factions[fid];
    const prevLevel = fs.level || 1;
    const prevTerr = fs.territory || 1;
    // Simple linear growth each year
    fs.level = (fs.level || 1) + 1;
    // Power grows modestly with random factor
    fs.power = (fs.power || 10) + rnd(1, 2);
    // Resources accumulate over time
    fs.resources = (fs.resources || 10) + rnd(2, 4);
    // Territory may expand (30%) or contract (10%); remains at least 1
    const roll = rnd(1, 100);
    if (roll <= 30) {
      fs.territory = (fs.territory || 1) + 1;
    } else if (roll <= 40) {
      fs.territory = Math.max(1, (fs.territory || 1) - 1);
    }
    // If the player's current faction levels up, bump their rep slightly
    if (state.faction === fid && fs.level > prevLevel) {
      state.factionRep = clamp((state.factionRep || 0) + 2, -100, 100);
    }
    // Log major changes
    const name = (FACTIONS.find(f => f.id === fid) || {}).name || fid;
    if (fs.level > prevLevel) {
      log(`${name} grows in influence. Level ${fs.level}.`, "muted");
    }
    if (fs.territory > prevTerr) {
      log(`${name} expands its territory. Total areas: ${fs.territory}.`, "muted");
    } else if (fs.territory < prevTerr) {
      log(`${name} loses some ground. Territory shrinks to ${fs.territory}.`, "muted");
    }
    // Warn when Dust Marauders become particularly strong
    if (fid === "dust_marauders" && fs.power >= 30 && fs.power > (fs._warnedPower || 0)) {
      log("The Dust Marauders grow emboldened. You sense more raider bands in the wastes.", "muted");
      fs._warnedPower = fs.power;
    }
  }
}

/*
 * Compute available actions for a faction based on its current level.
 * Combines the base FACTION_ACTIONS with extra actions unlocked at
 * certain levels as defined in FACTION_EXTRA_ACTIONS.
 */
function getFactionActions(fid) {
  const base = (FACTION_ACTIONS[fid] || []).slice();
  const extras = FACTION_EXTRA_ACTIONS[fid] || [];
  const fs = state?.factions?.[fid];
  const lvl = fs?.level || 1;
  extras.forEach(x => {
    if (lvl >= x.level) base.push(x.action);
  });
  return base;
}


// ── Faction Ranks ───────────────────────────────
const FACTION_RANKS = [
  { min: 0,  name: "Outsider" },
  { min: 20, name: "Associate" },
  { min: 50, name: "Member" },
  { min: 80, name: "Trusted" },
  { min: 100,name: "Champion" }
];

function factionRank(rep){
  let r = "Outsider";
  for (const tier of FACTION_RANKS){
    if (rep >= tier.min) r = tier.name;
  }
  return r;
}


  // NOTE: Right now factionRep is a single number
  // To implement tiers: check thresholds here and log tier-up messages
function changeRep(n){
  if (typeof state.factionRep !== "number") state.factionRep = 0;
  state.factionRep = clamp(state.factionRep + n, -100, 100);
}





/* ========= Actions ========= */
// NOTE: Core buttons (Age Up, Explore, Work, Heal)
// - Add new player action functions here

function ageUp(){
  if (!state.alive) return;
  state.age += 1; state.year += 1;

  // yearly upkeep: job pay; hunger/rad decay
  const job = getJob();
  if (job.id!=="none"){
    let pay = (typeof job.base === "number" ? job.base : job.base()) + Math.round(state.special.C * 1.5);
    if (state.perks.includes("silverTongue")) pay = Math.round(pay*1.15);
    state.caps += pay;
    log(`Your ${job.name} income: +${pay} caps.`);
  }
  derad(3);
  heal(3);

  // birthday note
  log(`You turned ${state.age}.`, "muted");

  yearlyEvent();
  gainXP(10);
  // Factions evolve over the course of a year
  updateFactions();
  tickBuffs("action");
}



function work(){
  if (!state.alive) return;

  /* ── Local helpers/data (scoped to this function) ───────────────── */

  // Risk + encounter profile per job
  const JOB_RISK = {
    scav:   { label: "Medium",       chance: 0.28, tier: "wastes"  },
    trader: { label: "Medium",       chance: 0.18, tier: "Dust_Marauders" },
    guard:  { label: "High",         chance: 0.45, tier: "Dust_Marauders" },
    scribe: { label: "Low",          chance: 0.08, tier: "wastes"  },
    med:    { label: "Medium-High",  chance: 0.22, tier: "work"    },
    none:   { label: "—",            chance: 0.00, tier: "wastes"  }
  };

  // Pay hint bands just for display on the board
  const PAY_HINTS = {
    scav:   [10, 10],
    trader: [20, 20],
    guard:  [30, 30],
    scribe: [20, 20],
    med:    [40, 40]
  };

  const jobRiskInfo = (jobId)=>
    JOB_RISK[jobId] || { label:"Medium", chance:0.20, tier:"work" };

  // Inline Job Board modal (only used from here)
  function openJobBoard(){
    const m = openModal("Job Board");
    m.content.append(
      el("p","small muted",
        "Higher pay usually means higher risk. Some jobs require certain S.P.E.C.I.A.L. scores."),
      el("div","hr")
    );

    const eligible = j => j.minAge <= state.age && j.req(state.special);

    JOBS
      .filter(j => j.id !== "none")
      .sort((a,b)=> (PAY_HINTS[b.id]?.[1]||0) - (PAY_HINTS[a.id]?.[1]||0))
      .forEach(j=>{
        const risk = jobRiskInfo(j.id);
        const pay  = PAY_HINTS[j.id] || [5,15];

        const row = el("div","kv");
        row.append(el("div", null, j.name));

        const right = el("div");
        right.append(
          el("div","small muted", `Pay: ~${pay[0]}–${pay[1]} caps/shift`),
          el("div","small muted", `Risk: ${risk.label} • Encounters ~${Math.round(risk.chance*100)}% • Tier: ${risk.tier}`)
        );

        const b = el("button","choice", eligible(j) ? "Take job" : "Locked (requirements not met)");
        b.disabled = !eligible(j);
        b.onclick = ()=>{
          state.job = j.id;
          log(`You take a position as ${j.name}.`);
          updateUI();
          closeModal();
        };

        right.append(b);
        row.append(right);
        m.content.append(row, el("div","hr"));
      });

    const closeRow = el("div","kv");
    closeRow.append(el("div", null, ""));
    const closeBox = el("div");
    const later = el("button","choice","Not now");
    later.onclick = closeModal;
    closeBox.append(later);
    closeRow.append(closeBox);
    m.content.append(closeRow);
  }

  /* ── Main flow ──────────────────────────────────────────────────── */

  const job = getJob();

  // If jobless, show the inline Job Board and return
  if (!job || job.id === "none"){
    openJobBoard();
    return;
  }

  // Use risk profile to gate encounters (higher pay → more danger)
  const risk = jobRiskInfo(job.id);
  if (maybeStartCombat(risk.chance, risk.tier, job.id)) return;

  // Base pay (handles number or function)
  let basePay = 5;
  try {
    if (typeof job.base === "number") basePay = job.base;
    else if (typeof job.base === "function") basePay = job.base();
  } catch(e){ console.warn("Job base pay missing:", job, e); }

// No CHA or perk bonus
// basePay stays as job.base

  addCaps(basePay);

  // Performance by job
  const prod = rnd(0,100)
             + (state.special.E || 0)
             + (state.special.C || 0)
             + (state.perks?.includes("silverTongue") ? 10 : 0);

  try {
    switch(job.id){
      case "guard": {
        if (prod > 80){
          const bonus = rnd(3,6);
          addCaps(bonus); gainXP(12);
          log(`Steady duty on the wall. Pay +${basePay}, hazard bonus +${bonus}. XP +12.`);
        } else if (prod > 50){
          gainXP(8);
          log(`Uneventful watch. Pay +${basePay}. XP +8.`);
        } else {
          damage(10); gainXP(5);
          log(`Skirmish at the gate. Pay +${basePay}, HP -10. XP +5.`);
        }
        break;
      }
      case "scav": {
        if (prod > 85){
          const find = rnd(0,100) < 50 ? "duct_tape" : "junk";
          addItem(find, 1); gainXP(10);
          log(`Scav run pays +${basePay}. You also find a ${ITEMS[find].name}! XP +10.`);
        } else {
          rad(5); gainXP(6);
          log(`Dirty work. Pay +${basePay}, RAD +5. XP +6.`);
        }
        break;
      }
      case "trader": {
        if (prod > 75){
          const tip = rnd(2,5);
          addCaps(tip); gainXP(10);
          log(`Good trading day. Pay +${basePay}, tips +${tip}. XP +10.`);
        } else {
          gainXP(6);
          log(`Slow market day. Pay +${basePay}. XP +6.`);
        }
        break;
      }
      case "scribe": {
        if (prod > 75){
          gainXP(12);
          log(`Repairing and cataloging yields insights. Pay +${basePay}. XP +12.`);
        } else {
          gainXP(6);
          log(`Archive grind. Pay +${basePay}. XP +6.`);
        }
        break;
      }
      case "med": {
        if (prod > 80){
          gainXP(14);
          log(`You handle a tough case. Pay +${basePay}. XP +14.`);
        } else {
          gainXP(8);
          log(`Routine field care. Pay +${basePay}. XP +8.`);
        }
        break;
      }
      default: {
        if (prod > 80){ gainXP(8); log(`Steady shift as ${job.name}. Pay +${basePay}. XP +8.`); }
        else { gainXP(5); log(`Long shift as ${job.name}. Pay +${basePay}. XP +5.`); }
      }
    }
  } catch(err){
    console.error("Error inside job branch:", err, job);
  }

  // Small chance to find scrap (adds to settlement)
  if (rnd(1,100) > 95){
    if (state.settlement) state.settlement.scrap = (state.settlement.scrap || 0) + 1;
    log("On your break, you salvage some scrap. +1 scrap.");
  }

  tickBuffs("action");
  updateUI();
}


function healAction(){
  if (!state.alive) return;
  const cost = 12;
  if (state.caps < cost){
    log("Not enough caps for supplies. You improvise. HP +3, RAD -1.");
    heal(3); derad(1);
    return;
  }
  state.caps -= cost;
  let h = 15, r = 8;
  if (state.perks.includes("medic")){ h += 5; r += 4; }
  heal(h); derad(r);
  log(`You patch up and detox. HP +${h}, RAD -${r}.`);
}


function explore(){
  if (!state.alive) return;
  // 35% chance to get a combat encounter while exploring
  if (maybeStartCombat(0.35, "wastes", "explore")) { return; }


  const roll = rnd(1,100) + state.special.L;

  // rare weapon find
  if (roll > 98){
    addItem("knife", 1);
    log("Jackpot! You find a serviceable combat knife.");
    gainXP(12);
  }
  // uncommon duct tape find
  else if (roll > 92){
    addItem("duct_tape", 1);
    log("Score! You salvage a roll of duct tape.");
    gainXP(8);
  }
  // common junk find
    else if (roll > 75){
    const n = rnd(1, 3); // make sure rnd is inclusive
    // If your rnd is exclusive, use: Math.floor(Math.random()*3)+1
    addItem("junk", n);
    log(`You scavenge useful junk. +${n} junk.`);
    gainXP(6);
   }
  // barter scrap for caps (no items)
  else if (roll > 55){
    const amt = money(0.8);
    state.caps += amt;
    log(`You find scrap and barter it. +${amt} caps.`);
    gainXP(6);
  }
  else if (roll > 35){
    log("Quiet day. You map some ruins. XP +6.");
    gainXP(6);
  }
  else if (roll > 20){
    rad(5);
    log("Irradiated puddles slow you. RAD +5.");
  }
  else {
    damage(10);
    log("Wild dogs attack. HP -10.");
  }
  updateUI;
}

function openInventory(){
  migrateInventoryShape();
  const m = openModal("Inventory");

  // ── Equipment panel ───────────────────────────────────────────────
  const eqTitle = el("div","title"); 
  eqTitle.textContent = "Equipment";
  m.content.append(eqTitle);

  // Show total bonuses from equipped gear
  const { atk=0, def=0 } = calcStats();
  const statRow = el("div","kv");
  statRow.append(el("div", null, "Bonuses"));
  statRow.append(el("div", "small", `ATK +${atk} / DEF +${def}`));
  m.content.append(statRow, el("div","hr"));

  // Per-slot rows
  ["head","chest","legs","weapon"].forEach(slot=>{
    const row = el("div","kv");
    const label = slot[0].toUpperCase() + slot.slice(1);
    row.append(el("div", null, label));

    const d = el("div");
    const id = state.equipment[slot];
    if (id){
      const meta = ITEMS[id] || { name:id };
      d.append(el("div", null, meta.name || id));
      if (meta.desc) d.append(el("div","small muted", meta.desc));

      const u = el("button","choice");
      u.textContent = "Unequip";
      u.onclick = ()=>{ unequip(slot); openInventory(); };
      d.append(u);
    } else {
      d.append(el("div","small muted","(empty)"));
    }

    m.content.append(row, d, el("div","hr"));
  });

  // ── Inventory list ────────────────────────────────────────────────
  const invTitle = el("div","title"); 
  invTitle.textContent = "Inventory";
  m.content.append(invTitle);

  if (!inv().length){
    m.content.append(el("p","muted","(empty)"));
  } else {
    inv().forEach(s => {
      const meta = ITEMS[s.id] || { name: s.id };
      const row = el("div","kv");
      row.append(el("div", null, `${meta.name || s.id} ×${s.qty}`));
      const actions = el("div");

      if (meta.desc) actions.append(el("div","small muted", meta.desc));

      // Use (if usable)
      if (meta.use){
        const b = el("button","choice","Use");
        b.onclick = () => { useItem(s.id); openInventory(); };
        actions.append(b);
      }

      // Equip (if equippable)
      if (meta.slot){
        const eqBtn = el("button","choice","Equip");
        eqBtn.onclick = () => { equipItem(s.id); openInventory(); };
        actions.append(eqBtn);
      }

      // Simple sell example
      if (s.id === "holotape"){
        const sell = el("button","choice","Sell (20 caps)");
        sell.onclick = () => {
          removeItem("holotape",1);
          state.caps += 20;
          log("Sold an Ancient Holotape for 20 caps.");
          updateUI();
          openInventory();
        };
        actions.append(sell);
      }

      // Drop
      const drop = el("button","choice","Drop");
      drop.onclick = () => { removeItem(s.id,1); log(`Dropped 1 ${meta.name || s.id}.`); updateUI(); openInventory(); };
      actions.append(drop);

      m.content.append(row, actions, el("div","hr"));
    });
  }

  // ── Crafting section ──────────────────────────────────────────────
  const craftTitle = el("div","title"); 
  craftTitle.textContent = "Crafting";
  m.content.append(craftTitle);

  let any = false;
  RECIPES.forEach(r => {
    const can = hasItems(r.requires);
    const row = el("div","kv");
    row.append(el("div", null, r.name));
    const d = el("div");
    d.append(el("div","small muted", r.desc));
    const b = el("button","choice"); 
    b.textContent = can ? "Craft" : "Missing reqs";
    b.disabled = !can;
    b.onclick = () => { craft(r.id); openInventory(); };
    d.append(b);
    m.content.append(row, d, el("div","hr"));
    any = true;
  });

  if (!any) m.content.append(el("p","muted","No recipes known."));
}



// ========= Faction Menu =========
// If no faction → list joinable ones.
// If in a faction → show actions, reputation, rank (and allow leaving).
function openJoinFaction(){
  // Not in a faction yet: show join list
  if (state.faction === "none") {
    const m = openModal("Factions");
    const canJoin = FACTIONS.filter(f => f.id !== "none" && f.req(state.special));
    if (!canJoin.length){
      m.content.append(el("p", null, "No one’s recruiting you right now. Train up!"));
      return;
    }
    canJoin.forEach(f => {
      const row = el("div", "kv");
      row.append(el("div", null, f.name));
      const d = el("div");
      d.append(el("div","small muted", f.blurb));
      const b = el("button","choice","Join");
      b.onclick = () => {
        state.faction = f.id;
        state.factionRep = 0;
        log(`You joined ${f.name}.`);
        updateUI();
        closeModal();
      };
      d.append(b);
      m.content.append(row, d, el("div","hr"));
    });
    return;
  }

  // Already in a faction: show personalized actions
  const f = getFaction();
  const m = openModal(`${f.name}`);

  // ── Header block
  const header = el("div","faction-header " + f.id);
  header.innerHTML = `
    <div class="title">${f.name}</div>
    <div class="small muted">${f.blurb}</div>
  `;
  m.content.append(header);

  // ── Reputation bar + rank
  const infoRow = el("div","kv");
  infoRow.append(el("div", null, "Reputation"));
  const bar = el("div","rep-bar");
  const fill = el("i");
  fill.style.width = clamp(state.factionRep, 0, 100) + "%";
  bar.append(fill);
  infoRow.append(bar);
  m.content.append(infoRow);

  const rankRow = el("div","kv");
  rankRow.append(el("div", null, "Rank"));
  rankRow.append(el("div","small muted", factionRank(state.factionRep)));
  m.content.append(rankRow, el("div","hr"));

  // Display faction growth status (level, territory, power)
  const fsInfo = state.factions && state.factions[state.faction];
  if (fsInfo) {
    const statRow = el("div","kv");
    statRow.append(el("div", null, "Status"));
    statRow.append(el("div","small muted", `Level ${fsInfo.level || 1}, Territory ${fsInfo.territory || 1}, Power ${fsInfo.power || 10}`));
    m.content.append(statRow, el("div","hr"));
  }

  // ── Actions (base + extra unlocked by faction growth)
  const actions = getFactionActions(state.faction);
  if (!actions.length) {
    m.content.append(el("p","muted","No special actions available right now."));
  } else {
    actions.forEach(a => {
      const box = el("div","faction-action");
      box.append(el("div","label", a.label));
      const b = el("button","choice","Do it");
      b.onclick = () => {
        try { a.run(); } catch(e){ console.error(e); log("Action failed.","muted"); }
        updateUI();
        closeModal();
      };
      box.append(b);
      m.content.append(box);
    });
  }

  // --- Campaign (Settlers only) ---
  if (state.faction === "settlers") {
    const box = el("div","faction-action");
    box.append(el("div","label", "Settlers Campaign"));
    const b = el("button","choice","Open Campaign");
    b.onclick = openSettlersCampaign;
    box.append(b);
    m.content.append(box);
  }

  // ── Leave faction (danger zone) at bottom
  m.content.append(el("div","hr"));
  const leaveRow = el("div","kv");
  leaveRow.append(el("div", null, "Leave faction"));
  const leaveBox = el("div");
  const leaveBtn = el("button","choice dangerous","Leave");
  leaveBtn.onclick = () => {
    const name = f.name;
    if (confirm(`Leave ${name}? You’ll lose your reputation with them.`)) {
      state.faction = "none";
      state.factionRep = 0;
      log(`You left ${name}.`);
      updateUI();     // updates pill and changes sidebar text to "Join a Faction"
      closeModal();
    }
  };
  leaveBox.append(leaveBtn);
  leaveRow.append(leaveBox);
  m.content.append(leaveRow);
}


 // ========= Perks Menu =========
  // NOTE: Unlock perks here
  // Add new perks in PERKS array above

function openPerks(){
  const m = openModal("Perks");
  const owned = el("p","small muted","Owned: "+(state.perks.map(p=>PERKS.find(x=>x.id===p)?.name).filter(Boolean).join(", ") || "none"));
  m.content.append(owned, el("div","hr"));
  PERKS.forEach(p=>{
    const ok = p.req(state);
    const row = el("div","kv");
    row.append(el("div",null,p.name));
    const d = el("div");
    d.append(el("div","small muted", p.desc));
    const b = el("button","choice"); b.textContent = state.perks.includes(p.id) ? "Owned" : (ok ? "Unlock (1 perk point)" : "Locked");
    b.disabled = state.perks.includes(p.id) || !ok || (perkPoints()<=0);
    b.onclick=()=>{ if (perkPoints()>0){ state.perks.push(p.id); log(`Perk unlocked: ${p.name}.`); updateUI(); openPerks(); } };
    d.append(b);
    m.content.append(row,d,el("div","hr"));
  });
  const footer = el("p","small muted", `Perk Points: ${perkPoints()}`);
  m.content.append(footer);
}

function perkPoints(){ return Math.floor(state.level/3) - state.perks.length; }

/* ===================== Settlers Campaign (branching) ===================== */
function ensureCampaignState(){
  if (!state.campaign) state.campaign = {};
  if (!state.campaign.settlers)
    state.campaign.settlers = { chapter: 0, flags:{}, ending: null, title: "Dustford Rising" };
}

function openSettlersCampaign(){
  ensureCampaignState();
  const c = state.campaign.settlers;
  const m = openModal(`Settlers Campaign — ${c.title}`);

  // Header / status
  const head = el("div","kv");
  head.append(el("div",null,"Status"));
  head.append(el("div","small muted",
    c.ending ? `Completed: ${c.ending}` : `Chapter ${c.chapter+1}/5`));
  m.content.append(head, el("div","hr"));

  // If finished, show summary only (no replay/reset)
  if (c.ending){
    const doneRow = el("div","kv");
    doneRow.append(el("div", null, "Campaign"));
    const note = el("div");
    note.append(el("div","small muted","Completed — not replayable."));
    doneRow.append(note);
    m.content.append(doneRow);

    if (Object.keys(c.flags).length){
      m.content.append(el("div","hr"));
      const flags = el("p","small muted", "Your key choices: " +
        Object.keys(c.flags).map(k=>`${k}=${c.flags[k]}`).join(", "));
      m.content.append(flags);
    }
    return; // no start/continue button when completed
  }

  // Start / continue button (only if not completed)
  const startRow = el("div","kv");
  startRow.append(el("div",null,"Continue"));
  const startBox = el("div");
  const startBtn = el("button","choice", `Begin Chapter ${c.chapter+1}`);
  startBtn.onclick = ()=>{ closeModal(); runSettlersChapter(); };
  startBox.append(startBtn);
  startRow.append(startBox);
  m.content.append(startRow);

  // Small log of key flags (optional)
  if (Object.keys(c.flags).length){
    m.content.append(el("div","hr"));
    const flags = el("p","small muted", "Choices so far: " +
      Object.keys(c.flags).map(k=>`${k}=${c.flags[k]}`).join(", "));
    m.content.append(flags);
  }
}

function runSettlersChapter(){
  ensureCampaignState();
  const c = state.campaign.settlers;
  const ch = c.chapter;

  // Guard: must be in the Settlers faction
  if (state.faction !== "settlers"){
    setChoice("You must be a Settlers Union member to undertake this campaign.", [
      { label:"Okay", run:()=>{} }
    ]);
    return;
  }

  // Guard: campaign is one-time only
  if (c.ending){
    setChoice("The Settlers campaign is already complete and cannot be replayed.", [
      { label:"OK", run:()=>{} }
    ]);
    return;
  }

  // CHAPTERS 0..4 then Ending
  if (ch === 0){
    setChoice("Ch.1 — Caravan Contract: A Dustford caravan needs an escort. Which route do you choose?", [
      { label:"Direct through the salt flats (E check, faster, riskier)",
        run:()=>{
          const ok = skillCheck("E",12);
          c.flags.route = "direct";
          if (ok){ changeRep(+3); gainXP(12); state.caps += money(1.0); log("Efficient run. You dodge the worst of it. +rep, +XP, +caps."); }
          else { damage(6); rad(6); changeRep(+2); gainXP(8); log("Rough crossing. You still deliver. HP -6, RAD +6, +rep."); }
          c.chapter++; updateUI();
        } },
      { label:"Back roads (safer, slower, lower payout)",
        run:()=>{
          c.flags.route = "back";
          changeRep(+3); gainXP(10); state.caps += money(0.6);
          log("Long way round. Fewer scrapes, lighter purse. +rep, modest caps.");
          c.chapter++; updateUI();
        } },
      { label:"Decline the job (Karma +2, but Union takes note)",
        run:()=>{
          c.flags.route = "decline";
          changeKarma(+2); changeRep(-2); log("You pass. The caravan finds other guards. Karma up; reputation dips.");
          c.chapter++; updateUI();
        } },
    ]);
    return;
  }

  if (ch === 1){
    setChoice("Ch.2 — Where to Invest: Dustford needs funds. Where do you push resources?", [
      { label:"Fortify the palisade (-10 caps, +rep)",
        run:()=>{
          if (state.caps < 10){ log("Not enough caps to fund the wall."); return; }
          state.caps -= 10; c.flags.walls = 1; changeRep(+4); gainXP(10);
          log("You organize lumber and braces. The wall stiffens. +rep.");
          c.chapter++; updateUI();
        } },
      { label:"Repair the water plant (-10 caps, +rep, better recovery)",
        run:()=>{
          if (state.caps < 10){ log("Not enough caps to fix the plant."); return; }
          state.caps -= 10; c.flags.water = 1; changeRep(+3); gainXP(10);
          log("Clean water flows steadier. Spirits rise. +rep.");
          c.chapter++; updateUI();
        } },
      { label:"Split resources (-16 caps total, modest both)",
        run:()=>{
          if (state.caps < 16){ log("You need 16 caps to split effectively."); return; }
          state.caps -= 16; c.flags.walls = 1; c.flags.water = 1; changeRep(+4); gainXP(12);
          log("Tight budget, but both projects improve. +rep.");
          c.chapter++; updateUI();
        } },
    ]);
    return;
  }

  if (ch === 2){
    setChoice("Ch.3 — A Knife in the Dark: Dust Marauder scouts probe the outskirts. Your approach?", [
      { label:"Ambush them (A check)",
        run:()=>{
          const ok = skillCheck("A",12);
          c.flags.ambush = ok ? "clean" : "messy";
          if (ok){ changeRep(+4); gainXP(12); log("Swift and clean. They scatter. +rep."); }
          else { damage(8); changeRep(+2); gainXP(8); log("You win, but not without cuts. HP -8, +rep."); }
          c.chapter++; updateUI();
        } },
      { label:"Shadow and warn the town (P check, +karma)",
        run:()=>{
          const ok = skillCheck("P",12);
          c.flags.warned = !!ok;
          changeKarma(+2);
          if (ok){ changeRep(+3); gainXP(12); log("You track them and alert the watch. +rep, +karma."); }
          else { changeRep(+1); gainXP(8); log("You lose the trail, but the warning helps a little. +rep."); }
          c.chapter++; updateUI();
        } },
      { label:"Attempt a parley (C check, big swing)",
        run:()=>{
          const ok = skillCheck("C",13);
          c.flags.truce = !!ok;
          if (ok){ changeRep(+2); changeKarma(+5); gainXP(14); log("A fragile understanding—no blood tonight. +karma."); }
          else { changeRep(-2); damage(6); log("Talks sour. Word spreads you were duped. HP -6, rep down."); }
          c.chapter++; updateUI();
        } },
    ]);
    return;
  }

  if (ch === 3){
    setChoice("Ch.4 — The Eve: The town prepares. How do you spend the day?", [
      { label:"Train militia (+rep, +XP)",
        run:()=>{
          c.flags.militia = 1; changeRep(+3); gainXP(14);
          log("You drill townsfolk until sundown. +rep, +XP.");
          c.chapter++; updateUI();
        } },
      { label:"Lay traps (cost: 2 Junk + 1 Duct Tape)",
        run:()=>{
          if (countItem("junk")>=2 && countItem("duct_tape")>=1){
            removeItem("junk",2); removeItem("duct_tape",1);
            c.flags.traps = 1; changeRep(+3); gainXP(12);
            log("Wire and pits along likely routes. +rep, +XP.");
            c.chapter++; updateUI();
          } else {
            log("You need 2× Junk and 1× Duct Tape.");
          }
        } },
      { label:"Stock granary (-10 caps, improves endurance)",
        run:()=>{
          if (state.caps < 10){ log("Not enough caps for supplies."); return; }
          state.caps -= 10; c.flags.stock = 1; gainXP(10); changeRep(+2);
          log("You shore up food stores and medicine. +rep.");
          c.chapter++; updateUI();
        } },
    ]);
    return;
  }

  if (ch === 4){
    // Finale — compute ending
    const end = settlersFinale();
    setChoice(`Ch.5 — The Dustford Crisis: ${end.title}`, [
      { label:"Acknowledge outcome", run:()=>{
        // rewards already granted in settlersFinale
        state.campaign.settlers.ending = end.key;
        c.chapter++; updateUI();
      } }
    ]);
    return;
  }

  // Safety: if somehow called again after completion
  setChoice("The Settlers campaign is complete.", [
    { label:"OK", run:()=>{} }
  ]);
}

function settlersFinale(){
  const f = state.campaign.settlers.flags || {};
  // Score prep
  let score = 0;
  if (f.walls) score += 1;
  if (f.water) score += 1;
  if (f.traps) score += 1;
  if (f.militia) score += 1;
  if (f.stock) score += 1;
  if (f.warned) score += 1;
  if (f.route === "direct") score += 1;      // bold earlier choice helps
  if (f.route === "decline") score -= 1;
  if (f.ambush === "clean") score += 1;
  if (f.ambush === "messy") score -= 1;
  if (f.truce) score += 2;                   // strong alternate path

  // Branches / endings
  // 1) Pacifist accord (truce true) — special coat
  if (f.truce){
    changeRep(+12); changeKarma(+6); gainXP(30);
    addItem("diplomats_coat", 1);
    log("Ending: The Accord — A fragile ceasefire routes Dust Marauders away from Dustford.");
    log("Reward: Diplomat’s Coat (+4 DEF, +2 AGI), big reputation, XP.", "muted");
    updateUI();
    return { key:"Accord", title:"A fragile ceasefire holds." };
  }

  // 2) Strong defense — clear victory
  if (score >= 6){
    changeRep(+15); gainXP(40); state.caps += money(1.6);
    addItem("settlers_carbine", 1); addItem("settlers_coat", 1);
    log("Ending: Secure Settlement — The traps spring, militia holds, walls stand.");
    log("Rewards: Settlers Carbine & Union Field Coat, +rep, +caps, +XP.", "muted");
    updateUI();
    return { key:"Secure Settlement", title:"Dustford stands strong." };
  }

  // 3) Narrow win — pyrrhic
  if (score >= 3){
    changeRep(+8); gainXP(25); state.caps += money(1.0);
    damage(8); // cost of victory
    log("Ending: Pyrrhic Victory — The town survives, but it hurts. HP -8.", "muted");
    updateUI();
    return { key:"Pyrrhic", title:"The town survives at a cost." };
  }

  // 4) Evacuation — fallback ending
  changeRep(+5); gainXP(18);
  addItem("food", 2); addItem("med_patch", 1);
  log("Ending: Caravan Exodus — You organize a retreat to fight another day. Supplies gained.");
  updateUI();
  return { key:"Exodus", title:"Orderly retreat under your lead." };
}



/* ========= Modal ========= */
function openModal(title){
  $("#modal-title").textContent = title;
  $("#modal-content").innerHTML = "";
  $("#modal-backdrop").style.display = "grid";
  return { content: $("#modal-content") };
}
function closeModal(){ $("#modal-backdrop").style.display="none"; }
$("#modal-close").onclick = closeModal;
$("#modal-backdrop").addEventListener("click", e=>{
  if (e.target.id==="modal-backdrop") closeModal();
});

/* ========= Combat Helpers ========= */

// e.g. chance(0.3) or chance(30)
function chance(p){ if (p > 1) p = p / 100; return Math.random() < p; }

function maybeStartCombat(prob = 0.3, tier = "wastes", source = "misc"){
  if (Math.random() < prob){
    const enemy = generateEnemy(tier || "wastes");
    openCombat(enemy, { source });
    return true;
  }
  return false;
}

function playerBattleStats(){
  const S  = state.special || {S:5,P:5,E:5,C:5,I:5,A:5,L:5};
  const eq = calcStats();

  let atk  = 2 + Math.floor(S.S/2) + Math.floor(S.P/4) + Math.floor(state.level/2);
  let def  = Math.floor(S.E/2) + Math.floor(S.A/4) + (eq.def || 0);
  let spd  = 8 + S.A + Math.floor(state.level/3) + (eq.agi || 0);
  let crit = clamp(0.03 + (S.L * 0.005) + (eq.crit || 0), 0, 0.5);

  const turns = v => (typeof v === "object" ? (v?.turns||0) : (v||0));
  if (turns(state.buffs?.strEnd)  > 0) { atk += 1; def += 1; }
  if (turns(state.buffs?.percInt) > 0) { crit += 0.01; }

  return { atk, def, spd, crit };
}




function migrateInventoryShape(){
  if (!Array.isArray(state.inventory)) state.inventory = [];

  const normalized = [];

  const pushStack = (id, qty=1) => {
    id = slugify(id);
    qty = Number(qty) || 1;
    const existing = normalized.find(s => s.id === id);
    if (existing) existing.qty += qty;
    else normalized.push({ id, qty });
  };

  // Old saves: array of strings
  if (state.inventory.some(x => typeof x === "string")) {
    const counts = {};
    state.inventory.forEach(x => {
      const id = slugify(x);
      counts[id] = (counts[id] || 0) + 1;
    });
    Object.entries(counts).forEach(([id,qty]) => pushStack(id, qty));
  } else {
    // Mixed / malformed shapes
    state.inventory.forEach(s => {
      if (typeof s === "string") pushStack(s, 1);
      else if (s && typeof s === "object") {
        if ("id" in s && "qty" in s) pushStack(s.id, s.qty);
        else {
          // objects like {junk:2, duct_tape:1}
          Object.entries(s).forEach(([k,v]) => pushStack(k, v));
        }
      }
    });
  }

  state.inventory = normalized;
}


function slugify(x){
  return String(x)
    .toLowerCase()
    .replace(/\[object\s*object\]/g, "object_object") // optional – before stripping
    .replace(/[^a-z0-9\s_]/g, "")                     // remove non-word chars
    .trim()
    .replace(/\s+/g, "_");
}

function reset(){
  if (confirm("Start a new run? Current progress will be lost unless saved.")) {
    newRun();
    $("#log").innerHTML = "";
  }
}

/* ========= Death ========= */
// NOTE: Called when player dies (HP 0, RAD 100, age 120)
// - You can expand death causes or add permadeath logs here

function die(){
  state.alive = false;
  const cause = state.hp<=0 ? "your injuries" : state.rad>=100 ? "radiation sickness" : "old age";
  log(`You died at age ${state.age} from ${cause}. Final caps: ${state.caps}. Karma: ${state.karma}.`, "muted");
  updateUI();
}

/* ========= Trade / Barter ========= */
// Base buy prices (caps) — tweak freely
// Base buy prices (caps) — tweak freely
const TRADE_BASE = {
  // Consumables & misc
  food: 6,
  med_patch: 18,
  antirad: 24,
  water_filter: 28,
  duct_tape: 7,
  junk: 4,
  canteen: 12,
  holotape: 20,
  rad_purge: 30,
  rad_shield: 26,
  battle_tonic: 22,
  bulk_tonic: 24,
  focus_pills: 20,
  stealth_field: 34,

  // Armor / clothing
  helmet: 30,
  armor: 60,
  boots: 24,
  settlers_coat: 80,
  diplomats_coat: 70,

  // Melee
  knife: 45,
  scrap_blade: 28,
  machete: 28,
  sledgehammer: 60,

  // Firearms (existing)
  revolver: 60,
  shotgun: 75,
  hunting_rifle: 85,

  // Firearms (new)
  pipe_pistol: 30,
  smg_9mm: 75,
  assault_rifle_556: 100,
  battle_rifle_762: 120,
  marksman_rifle: 110,
  lever_action_44: 95,
  machine_pistol_38: 55,
  laser_pistol: 95,
  laser_rifle: 135,
  settlers_carbine: 90,

  // Ammo
  ammo_38: 4,
  ammo_9mm: 5,
  shells_12g: 6,
  ammo_308: 10,
  ammo_556: 8,
  ammo_762: 9,
  ammo_44: 12,
  carbine_round: 7,
  energy_cell: 14
};


// Vendor stock generator (called per visit)
function genVendorStock(kind="Trader"){
  // id -> qty
  const stock = {};
  const put = (id, q)=>{ stock[slugify(id)] = (stock[slugify(id)]||0) + q; };
  const roll = (pct)=> rnd(1,100) <= pct;

  // ===== Core consumables (always some)
  put("food",        rnd(2,6));
  put("med_patch",   rnd(1,3));
  put("antirad",     rnd(1,2));
  put("duct_tape",   rnd(1,4));
  put("junk",        rnd(2,6));
  if (roll(35)) put("rad_purge",    rnd(1,2));
  if (roll(30)) put("rad_shield",   1);
  if (roll(35)) put("battle_tonic", rnd(1,2));
  if (roll(35)) put("bulk_tonic",   rnd(1,2));
  if (roll(35)) put("focus_pills",  rnd(1,2));
  if (roll(25)) put("stealth_field",1);
  if (roll(35)) put("water_filter", 1);
  if (roll(40)) put("canteen",      1);

  // ===== Armor / clothing (sometimes)
  if (roll(45)) put("helmet", 1);
  if (roll(35)) put("boots",  1);
  if (roll(30)) put("armor",  1);

  // Faction gear (rare)
  if (roll(10)) put("settlers_coat",   1);
  if (roll(10)) put("diplomats_coat",  1);

  // ===== Melee (common-ish)
  if (roll(55)) put("knife",        1);
  if (roll(45)) put("scrap_blade",  1);
  if (roll(40)) put("machete",      1);
  if (roll(30)) put("sledgehammer", 1);

  // ===== Firearms (rarity tiers)
  // basic
  if (roll(45)) put("pipe_pistol", 1);
  if (roll(35)) put("revolver",    1);
  if (roll(30)) put("shotgun",     1);
  if (roll(28)) put("hunting_rifle", 1);

  // mid
  if (roll(25)) put("machine_pistol_38", 1);
  if (roll(22)) put("smg_9mm",           1);
  if (roll(20)) put("assault_rifle_556", 1);
  if (roll(18)) put("marksman_rifle",    1);
  if (roll(16)) put("settlers_carbine",  1);

  // high-end
  if (roll(14)) put("battle_rifle_762",  1);
  if (roll(14)) put("lever_action_44",   1);
  if (roll(12)) put("laser_pistol",      1);
  if (roll(10)) put("laser_rifle",       1);

  // ===== Ammo (more plentiful)
  const ammoLots = [
    ["ammo_38",      [6,18]],
    ["ammo_9mm",     [6,18]],
    ["shells_12g",   [4,12]],
    ["ammo_308",     [4,10]],
    ["ammo_556",     [6,16]],
    ["ammo_762",     [5,14]],
    ["ammo_44",      [3,10]],
    ["carbine_round",[6,16]],
    ["energy_cell",  [3,9]]
  ];
  ammoLots.forEach(([id, [a,b]])=>{
    if (roll(75)) put(id, rnd(a,b));
  });

  // Occasional curios
  if (roll(25)) put("holotape", rnd(1,2));

  return { kind, stock, haggleCut: 0, visitedYear: state.year, sessionId: rnd(10000,99999) };
}


// Price calculator with Charisma/perk/faction/haggle
function tradePrice(id, mode, vendor){
  // mode: "buy" or "sell"
  const base = TRADE_BASE[id] || 10;
  // vendors buy cheaper than they sell
  let price = mode === "buy" ? base : Math.max(1, Math.round(base * 0.5));

  // charisma effect (~3% per point from 5)
  const cha = state.special?.C || 5;
  const chaAdj = 1 - ((cha - 5) * 0.03);
  price = Math.max(1, Math.round(price * chaAdj));

  // perk: Silver Tongue ~15% better
  if (state.perks?.includes("silverTongue")){
    price = Math.round(mode === "buy" ? price * 0.85 : price * 1.15);
  }

  // Settlers faction small discount with their caravans
  if (state.faction === "settlers" && vendor?.kind === "Caravan"){
    price = Math.round(mode === "buy" ? price * 0.95 : price * 1.05);
  }

  // one-time haggle cut for this vendor session (applies to buy only)
  if (mode === "buy" && (vendor?.haggleCut||0) > 0){
    price = Math.round(price * (1 - vendor.haggleCut));
  }

  return Math.max(1, price);
}

function openTrade(kind="Trader"){
  const vendor = genVendorStock(kind);

  const m = openModal(vendor.kind === "Caravan" ? "Caravan Trader" : "Trader");
  const head = el("div","kv");
  head.append(el("div", null, "Your Caps"));
  head.append(el("div", null, `${state.caps}`));
  m.content.append(head, el("div","hr"));

  // HAGGLE (once per visit, CHA check)
  const hagRow = el("div","kv");
  hagRow.append(el("div", null, "Haggle"));
  const hagBox = el("div");
  const hagBtn = el("button","choice","Try to Haggle");
  const hagNote = el("span","small muted","  (better buy prices this visit)");
  hagBtn.onclick = ()=>{
    // modest charisma check; Swift doesn't help here
    const ok = skillCheck("C", 12);
    if (ok){
      vendor.haggleCut = 0.10 + (state.perks.includes("silverTongue") ? 0.05 : 0);
      log("Your pitch lands. Prices down this visit.");
    } else {
      vendor.haggleCut = 0; // no penalty
      log("Trader shrugs. No deal.");
    }
    openTrade(kind); // re-render with new prices
  };
  // disable if already haggled
  if (vendor.haggleCut>0) { hagBtn.textContent = "Haggled ✓"; hagBtn.disabled = true; }
  hagBox.append(hagBtn, hagNote);
  hagRow.append(hagBox);
  m.content.append(hagRow, el("div","hr"));

  // Tabs: Buy / Sell
  let tab = state._tradeTab || "buy";
  const tabs = el("div","kv");
  tabs.append(el("div", null, "Mode"));
  const tbox = el("div");
  const buyBtn = el("button","choice", tab==="buy" ? "Buy ✓" : "Buy");
  const sellBtn = el("button","choice", tab==="sell" ? "Sell ✓" : "Sell");
  buyBtn.onclick = ()=>{ state._tradeTab="buy"; openTrade(kind); };
  sellBtn.onclick = ()=>{ state._tradeTab="sell"; openTrade(kind); };
  tbox.append(buyBtn, sellBtn);
  tabs.append(tbox);
  m.content.append(tabs, el("div","hr"));

  if (tab === "buy"){
    // BUY LIST
    const ids = Object.keys(vendor.stock).filter(id=>vendor.stock[id]>0);
    if (!ids.length){
      m.content.append(el("p","muted","(Trader is out of stock)"));
    } else {
      ids.sort();
      ids.forEach(id=>{
        const qty = vendor.stock[id];
        const meta = ITEMS[id] || { name:id };
        const row = el("div","kv");
        row.append(el("div",null, `${meta.name || id} ×${qty}`));
        const d = el("div");

        if (meta.desc) d.append(el("div","small muted", meta.desc));

        const p = tradePrice(id, "buy", vendor);
        const buy1 = el("button","choice", `Buy (${p} caps)`);
        buy1.onclick = ()=>{
          if (vendor.stock[id] <= 0){ log("Sold out."); return; }
          if (state.caps < p){ log("Not enough caps."); return; }
          state.caps -= p;
          vendor.stock[id]--;
          addItem(id, 1);
          log(`Bought 1 ${meta.name || id} for ${p} caps.`);
          updateUI(); openTrade(kind);
        };
        d.append(buy1);
        row.append(d);
        m.content.append(row, el("div","hr"));
      });
    }
  } else {
    // SELL LIST (your inventory, anything with a base price)
    migrateInventoryShape();
    const sellables = inv().filter(s => TRADE_BASE.hasOwnProperty(s.id) && s.qty>0);
    if (!sellables.length){
      m.content.append(el("p","muted","(You have nothing the trader wants.)"));
    } else {
      sellables.sort((a,b)=> (ITEMS[a.id]?.name||a.id).localeCompare(ITEMS[b.id]?.name||b.id));
      sellables.forEach(s=>{
        const meta = ITEMS[s.id] || { name:s.id };
        const row = el("div","kv");
        row.append(el("div",null, `${meta.name || s.id} ×${s.qty}`));
        const d = el("div");

        if (meta.desc) d.append(el("div","small muted", meta.desc));

        const p = tradePrice(s.id, "sell", vendor);
        const sell1 = el("button","choice", `Sell (+${p} caps)`);
        sell1.onclick = ()=>{
          if (countItem(s.id) <= 0) return;
          removeItem(s.id, 1);
          state.caps += p;
          // vendor gains it (optional)
          vendor.stock[s.id] = (vendor.stock[s.id]||0) + 1;
          log(`Sold 1 ${meta.name || s.id} for ${p} caps.`);
          updateUI(); openTrade(kind);
        };
        d.append(sell1);
        row.append(d);
        m.content.append(row, el("div","hr"));
      });
    }
  }

  // Footer tip
  m.content.append(el("p","small muted",
    vendor.haggleCut>0 ? "Haggled prices active for this visit." :
    "Tip: Charisma and Silver Tongue improve deals.")
  );
}

/* ========= Event Wiring ========= */
// NOTE: Buttons in HTML are connected to functions here
// - Add new button handlers if you add new buttons in HTML
$("#btn-age").onclick = ()=>{ if (!state.pendingChoice) ageUp(); };
$("#faction-pill-wrapper").onclick = () => {
  openJoinFaction();
};
$("#btn-explore").onclick = ()=>{ if (!state.pendingChoice) explore(); updateUI(); };
$("#btn-work").onclick = ()=>{ if (!state.pendingChoice) work(); updateUI(); };
$("#btn-heal").onclick = ()=>{ if (!state.pendingChoice) healAction(); updateUI(); };
$("#btn-trade").onclick = ()=> openTrade("Caravan");
$("#btn-inventory").onclick = ()=> openInventory();
$("#btn-join-faction").onclick = ()=> openJoinFaction();
$("#btn-perks").onclick = ()=> openPerks();



// --- Boot & wiring ---
window.addEventListener("DOMContentLoaded", () => {

  // Main action buttons
  $("#btn-age").onclick = ageUp;
  $("#btn-explore").onclick = explore;
  $("#btn-work").onclick = work;
  $("#btn-heal").onclick = healAction;

  // Menus / modals
  $("#btn-inventory").onclick = openInventory;
  $("#btn-trade").onclick = () => openTrade("Trader");
  $("#btn-join-faction").onclick = openJoinFaction;
  $("#btn-perks").onclick = openPerks;


  // Make the faction pill open the faction menu
  $("#faction-pill-wrapper").onclick = openJoinFaction;
});



/* ====== TEXT MAP + Wilderness Integration (fixed) ======================= */
(function(){
  if (window.WL_TextMap) return; // keep only one copy

  /* --- Data --- */
  const WORLD = [
    { id:"dustford", name:"Dustford",        type:"town", desc:"Hardy town around a recycler." },
    { id:"ironwood", name:"Ironwood",        type:"town", desc:"Frontier town by foundry + pines." },
    { id:"dunes",    name:"Wasteland Dunes", type:"wild", desc:"Scrub dunes. Storms hit." },
    { id:"ruins",    name:"Cracked Ruins",   type:"wild", desc:"Collapsed towers, salvage, rads." },
    { id:"flats",    name:"Salt Flats",      type:"wild", desc:"White wastes, smugglers run." },
    { id:"canyon",   name:"Red Canyons",     type:"wild", desc:"Tight passes, raiders." },
    { id:"swamp",    name:"Irrad. Swamp",    type:"wild", desc:"Glowing mire, vicious biters." },
  ];
  const TOWNS = { dustford:[], ironwood:[] }; // stub buildings

  /* Wilderness config */
  const WILD = {
    dunes:  { rad:0, ch:0.32, loot:[["junk",6],["duct_tape",3],["canteen",1],["food",2]], enemies:["sand_stalker","burrower_beetle","dune_scorpion"] },
    ruins:  { rad:2, ch:0.38, loot:[["junk",5],["duct_tape",4],["holotape",1],["energy_cell",2]], enemies:["feral","rebar_scavver","auto_turret_mk1"] },
    flats:  { rad:1, ch:0.28, loot:[["junk",4],["water_filter",1],["caps",2],["food",2]], enemies:["brine_tortoise","flat_wraith","smuggler_skiff"] },
    canyon: { rad:0, ch:0.35, loot:[["junk",3],["ammo_38",2],["shells_12g",1]], enemies:["cliff_raptor","rock_viper","marauder_lookout"] },
    swamp:  { rad:3, ch:0.40, loot:[["junk",3],["food",2],["antirad",2]], enemies:["bog_snapper","glow_mireling","skeeter_swarm"] },
  };

  /* --- Sidebar button --- */
  function $(s){ return document.querySelector(s); }
  function ensureMapBtn(){
    if ($("#btn-map")) return;
    const b = document.createElement("button");
    b.id = "btn-map";
    b.textContent = "Travel / Map";
    b.onclick = openWorld;
    (document.querySelector(".actions .group") || $(".actions") || document.body).appendChild(b);
  }

function openWorld(){
  const m = openModal("World Travel"), c = m.content;
  const here = state.location || "Unknown";

  // clear + header
  c.innerHTML = "";
  c.append(pSmall("You are at: " + here), hr());

  // towns
  c.append(section("Towns"));
  WORLD.filter(n => n.type === "town").forEach(n => c.append(worldRow(n)));

  // wilderness
  c.append(section("Wilderness"));
  WORLD.filter(n => n.type !== "town").forEach(n => c.append(worldRow(n)));
}

// ADD this tiny helper anywhere near your other helpers:
function section(titleText){
  const d = document.createElement("div");
  d.className = "title";
  d.textContent = titleText;
  return d;
}
  function worldRow(n){
    const r = kv();
    r.left.textContent = n.name;
    r.right.append(pSmall(n.desc));
    if (state.location === n.name) r.left.appendChild(tag("here"));
    const go = choice(state.location === n.name ? "—" : "Travel");
    go.disabled = (state.location === n.name);
    go.onclick = () => travelTo(n.id);
    r.right.append(go);
    return r.wrap;
  }

  /* --- Travel + region set --- */
  function travelTo(id){
    const n = WORLD.find(x => x.id === id); if (!n) return;
    if (typeof maybeStartCombat === "function" && maybeStartCombat(n.type==="town" ? 0.15 : 0.30, "wastes", "travel")) {
      closeModal(); return;
    }
    state.location = n.name;
    state.region   = (n.type === "wild") ? n.id : null;
    log("You travel to " + n.name + ".");
    updateUI();
    closeModal();
  }

  /* --- Explore override for wilderness --- */
  window.exploreCurrentRegion = function(){
    const id = state.region, r = WILD[id];
    if (!r){ log("Nothing special to explore here."); return; }
    if (r.rad) rad(r.rad);
    if (Math.random() < r.ch){ openCombat(genEnemy(id)); return; }
    const l = roll(r.loot); if (!l){ log("Nothing found."); return; }
    if (l === "caps"){ const amt = rnd(3,12); addCaps(amt); log("Found "+amt+" caps."); }
    else { addItem(l,1); log("Scavenged " + (ITEMS[l]?.name || l)); }
  };

  /* --- Helpers --- */
  function roll(tab){ if(!tab) return null; let tot=tab.reduce((s,[,w])=>s+w,0), r=Math.random()*tot; for(const [id,w] of tab){ if((r-=w)<=0) return id; } return null; }
  function genEnemy(region){
    const pool = WILD[region]?.enemies || [];
    const id   = pool[rnd(0, pool.length-1)];
    const e    = ENEMIES.find(x => x.id === id) || ENEMIES[0];
    return { ...e, curHP: e.hp }; // <-- fixed from `{.e,...}` bug
  }

  function kv(){ const w=document.createElement("div"); w.className="kv"; const a=document.createElement("div"), b=document.createElement("div"); w.append(a,b); return {wrap:w,left:a,right:b}; }
  function choice(t){ const b=document.createElement("button"); b.className="choice"; b.textContent=t; return b; }
  function hr(){ const d=document.createElement("div"); d.className="hr"; return d; }
  function pSmall(t){ const p=document.createElement("p"); p.className="small muted"; p.textContent=t; return p; }
  function tag(t){ const s=document.createElement("span"); s.className="pill"; s.textContent=t; return s; }

  ensureMapBtn();
  const _update = window.updateUI;
  window.updateUI = function(){ _update && _update(); ensureMapBtn(); };

  window.WL_TextMap = { world:WORLD, towns:TOWNS, openWorld, travelTo };
})();</script>
<script>// end_screen_helper.js
/* ---- end-screen helper ---- */
(function(){
  const $=id=>document.getElementById(id);
  const overlay=$("wl-combat-end"), ttl=$("wl-title"), desc=$("wl-desc"), icon=$("wl-icon");
  const xp=$("wl-xp"), caps=$("wl-caps"), loot=$("wl-loot"), note=$("wl-note");
  const btnClose=$("wl-close"), btnAgain=$("wl-again");
  const defaults={win:{t:"Victory!",d:"You overcame the threat.",i:"🏆"},
                  lose:{t:"Defeat",d:"You were overwhelmed...",i:"💀"},
                  flee:{t:"Retreat",d:"You escaped safely.",i:"🏃"}};
  function setLoot(items){
    loot.innerHTML=""; if(!items||!items.length){const s=document.createElement("span");s.className="wl-sub";s.textContent="None";loot.appendChild(s);return;}
    items.forEach(n=>{const c=document.createElement("span");c.className="wl-chip";c.textContent=n;loot.appendChild(c);});
  }
  function open(opts={}){
    const mode=(opts.outcome||"win").toLowerCase();
    overlay.classList.remove("wl-win","wl-lose","wl-flee"); overlay.classList.add("wl-"+mode);
    const d=defaults[mode]||defaults.win;
    ttl.textContent=opts.title||d.t; desc.textContent=opts.message||d.d; icon.textContent=opts.icon||d.i;
    xp.textContent="+"+(opts.xp??0); caps.textContent=(opts.caps??0); setLoot(opts.items||[]); note.textContent=opts.note||"";
    overlay.classList.add("wl-show"); setTimeout(()=>btnAgain.focus(),0);
    const onEsc=e=>{if(e.key==="Escape") close("close");}; document.addEventListener("keydown",onEsc);
    function close(result){ overlay.classList.remove("wl-show"); document.removeEventListener("keydown",onEsc);
      if(typeof opts.onClose==="function") opts.onClose(result);
      if(result==="again" && typeof opts.onAgain==="function") opts.onAgain(); }
    btnClose.onclick=()=>close("close"); btnAgain.onclick=()=>close("again");
    overlay.onclick=e=>{ if(e.target===overlay) close("close"); };
  }
  window.WLCombatEnd={open};
})();

/* ---- openCombat HARD OVERRIDE (with safe shims) ---- */
(function(){
  const safe = (name, ...args) => { try { const fn = window[name]; if (typeof fn === "function") return fn(...args); } catch(_){} };
  const has   = name => typeof window[name] === "function";

  window.openCombat = function(enemy, ctx = {}) {
    const m = openModal("Encounter");
    let logBox, enemyHPFill, playerHPFill;

    const pstats = () => playerBattleStats();
    const enemyStats = { atk: enemy.atk, def: enemy.def, spd: enemy.spd };

    const hud = el("div","kv");
    hud.append(el("div",null,"Enemy"));
    hud.append(el("div","small",`${enemy.name} (Lv ?)`));
    m.content.append(hud);

    const eRow = el("div","kv");
    eRow.append(el("div",null,enemy.name));
    const eBar = el("div","bar"); enemyHPFill = el("i"); eBar.append(enemyHPFill); eRow.append(eBar); m.content.append(eRow);

    const pRow = el("div","kv");
    pRow.append(el("div",null,state.name));
    const pBar = el("div","bar"); playerHPFill = el("i"); pBar.append(playerHPFill); pRow.append(pBar);
    m.content.append(pRow, el("div","hr"));

    logBox = el("div"); m.content.append(logBox);

    const actionRow = el("div","kv"); actionRow.append(el("div",null,"Actions"));
    const buttonsBox = el("div");
    const btnAttack = el("button","choice","Attack");
    const btnItem   = el("button","choice","Item");
    const btnFlee   = el("button","choice","Flee");
    buttonsBox.append(btnAttack, btnItem, btnFlee); actionRow.append(buttonsBox); m.content.append(actionRow);
    const itemBox = el("div"); m.content.append(itemBox);

    function uiLog(t){ const p = el("p",null,t); logBox.append(p); logBox.scrollTop = logBox.scrollHeight; }
    function refreshBars(){
      const ePct = Math.max(0, Math.round((enemy.curHP / enemy.hp) * 100)); enemyHPFill.style.width = ePct + "%";
      const pPct = Math.max(0, Math.round((state.hp / state.hpMax) * 100));  playerHPFill.style.width = pPct + "%";
    }
    function dmgCalc(attackerAtk, defenderDef, critChance = 0.05){
      let raw = attackerAtk + rnd(1,6) - 3;
      const K = 25, mult = 1 - (defenderDef / (defenderDef + K));
      let amount = Math.max(1, Math.round(raw * mult)); let crit=false;
      if (Math.random() < critChance){ amount = Math.round(amount * 1.5); crit = true; }
      return { amount, crit };
    }

    function endCombat(victory){
      [btnAttack, btnItem, btnFlee].forEach(b=>b.disabled=true);

      if (victory){
        state.battlesWon++;
        const reward = { ...enemy.reward };
        if (has("chance") ? chance(0.10) : Math.random() < 0.10) reward.items = { ...(reward.items||{}), food: 1 };
        if (has("chance") ? chance(0.08)  : Math.random() < 0.08) reward.items = { ...(reward.items||{}), duct_tape: (reward.items?.duct_tape||0) + 1 };
        safe("grantBattleRewards", reward);

        uiLog(`Victory! +${reward.xp||0} XP, +${reward.caps||0} caps${reward.items ? " (loot gained)" : ""}.`);
        safe("log", `Defeated ${enemy.name}.`); safe("updateUI"); safe("tickBuffs","combat");

        closeModal();
        WLCombatEnd.open({
          outcome:"win",
          xp: reward.xp||0,
          caps: reward.caps||0,
          items: reward.items ? Object.keys(reward.items) : [],
          note:`You defeated ${enemy.name}.`
        });
      } else {
        state.battlesLost++; safe("log",`You were overwhelmed by ${enemy.name}.`); safe("updateUI");
        if (state.hp <= 0) safe("die"); safe("tickBuffs","combat");
        closeModal();
        WLCombatEnd.open({ outcome:"lose", xp:0, caps:0, items:[], note:`You were defeated by ${enemy.name}.` });
      }
    }

    function enemyTurn(){
      if (enemy.curHP <= 0) return;
      const { def } = pstats();
      const result = dmgCalc(enemyStats.atk, def, 0.05);
      safe("damage", result.amount);
      uiLog(`${enemy.name} hits you for ${result.amount}${result.crit ? " (CRIT!)" : ""}.`);
      refreshBars();
      if (state.hp <= 0){ uiLog("You collapse!"); endCombat(false); return true; }
      return false;
    }
    function playerTurn(){ [btnAttack, btnItem, btnFlee].forEach(b=>b.disabled=false); }

    // Attack
    btnAttack.onclick = () => {
      [btnAttack, btnItem, btnFlee].forEach(b=>b.disabled=true);
      const gate = safe("currentAttackAndCritWithAmmoGate") || {};

      if (gate.usedAmmo && gate.perShot > 0 && gate.ammoId){
        const ok = safe("consumeAmmo", gate.ammoId, gate.perShot);
        uiLog(ok ? `[${gate.ammoName} -${gate.perShot}]` : `*Click.* Out of ammo (${gate.ammoName}). You swing your weapon!`);
      }
      if (gate.out) uiLog(`*Click.* Out of ammo (${gate.ammoName}). You strike with a melee bash!`);

      const ps = playerBattleStats();
      const atkBoostActive = (state.buffs?.atkBoost && (state.buffs.atkBoost.turns || state.buffs.atkBoost) > 0);
      const baseAtk  = (typeof gate.atk  === "number" && gate.atk  > 0) ? gate.atk  : ps.atk;
      const baseCrit = (typeof gate.crit === "number" && gate.crit > 0) ? gate.crit : ps.crit;
      const totalAtk  = Math.max(1, baseAtk + (atkBoostActive ? 4 : 0));
      const totalCrit = clamp(baseCrit, 0, 0.5);

      const result = dmgCalc(totalAtk, enemyStats.def, totalCrit);
      enemy.curHP = Math.max(0, enemy.curHP - result.amount);
      uiLog(`You hit ${enemy.name} for ${result.amount}${result.crit ? " (CRIT!)" : ""}.`);
      refreshBars();

      if (enemy.curHP <= 0){ uiLog(`${enemy.name} collapses!`); endCombat(true); return; }

      setTimeout(()=>{ const ended = enemyTurn(); if (!ended) playerTurn(); },150);
    };

    // Item
    btnItem.onclick = () => {
      itemBox.innerHTML = "";
      safe("migrateInventoryShape");
      const all = safe("inv") || [];
      const usable = all.filter(s => (window.ITEMS||{})[s.id]?.use);
      if (!usable.length){ itemBox.append(el("p","small muted","(No usable items)")); return; }
      usable.forEach(s=>{
        const meta = (window.ITEMS||{})[s.id] || {name:s.id};
        const b = el("button","choice",`${meta.name} ×${s.qty}`);
        b.onclick = () => {
          safe("useItem", s.id);
          uiLog(`You use ${meta.name}.`); refreshBars(); itemBox.innerHTML = "";
          setTimeout(()=>{ const ended = enemyTurn(); if (!ended) playerTurn(); },150);
        };
        itemBox.append(b, el("span","small muted"," "));
      });
    };

    // Flee
    btnFlee.onclick = () => {
      [btnAttack, btnItem, btnFlee].forEach(b=>b.disabled=true);
      const ps = pstats(); const pSpd = Number(ps?.spd ?? 0); const eSpd = Number(enemyStats?.spd ?? 0);
      let base = 0.35 + ((pSpd - eSpd) * 0.03);
      if (Array.isArray(state?.perks) && state.perks.includes("swift")) base += 0.10;
      if ((state?.buffs?.fleeBoost ?? 0) > 0) base += 0.15;
      const fleeChance = clamp(isFinite(base) ? base : 0.35, 0.10, 0.90);

      if (Math.random() < fleeChance){
        uiLog("You slip away!"); safe("log",`You fled from ${enemy.name}.`); safe("updateUI"); safe("tickBuffs","combat");
        closeModal();
        WLCombatEnd.open({ outcome:"flee", xp:0, caps:0, items:[], note:`You escaped from ${enemy.name}.` });
        return;
      }
      uiLog("You fail to escape!");
      setTimeout(()=>{ const ended = enemyTurn(); if (!ended) playerTurn(); safe("tickBuffs","combat"); },150);
    };

    enemy.curHP = enemy.curHP ?? enemy.hp;
    refreshBars(); playerTurn();
  };

  /* ensure node is under <body> even if something moved it */
  (function(){ const n=document.getElementById('wl-combat-end'); if(n && n.parentNode!==document.body){ document.body.appendChild(n); }})();
})();


















	
/* Wastelife — Living World v0.5 (consolidated, no conflicts)
   - Social button
   - NPCs with Chat / Rumors / Trade / Hire / Lore / Request
   - Travel-to-them if far (uses your Text Map travel)
*/
(function(){
  "use strict";
  const W = window;
  const ST = () => (W.state || (W.state = {}));  // TDZ-safe: never touch bare `state`

  // Modal helper (uses your existing modal markup)
  function showModalSimple(title, html){
    const mb=document.getElementById("modal-backdrop"),
          mt=document.getElementById("modal-title"),
          mc=document.getElementById("modal-content");
    if(!mb||!mt||!mc) return alert(title+"\n\n"+String(html||"").replace(/<[^>]+>/g,""));
    mt.textContent=title; mc.innerHTML=html; mb.style.display="grid";
  }
  const logSafe = s => { try{ W.log(s); } catch { console.log("[WORLD]", s); } };

  // Canonical locations (scoped here only) with aliases to match your WORLD ids
  const LOC = {
    CANON: {
      dustown:    { name:"Dustown",        worldId:"dustford" }, // Dustford↔Dustown
      ironwood:   { name:"Ironwood",       worldId:"ironwood" },
      dunes:      { name:"Wasteland Dunes",worldId:"dunes" },
      ruins_zone: { name:"Cracked Ruins",  worldId:"ruins" },
      flats_zone: { name:"Salt Flats",     worldId:"flats" },
      canyon:     { name:"Red Canyons",    worldId:"canyon" },
      swamp:      { name:"Irrad. Swamp",   worldId:"swamp" },
    },
    ALIASES: {
      "dustown":"dustown", "dustford":"dustown", "ironwood":"ironwood",
      "wasteland dunes":"dunes", "cracked ruins":"ruins_zone", "salt flats":"flats_zone",
      "red canyons":"canyon", "irrad. swamp":"swamp", "swamp":"swamp"
    },
    slug(s){ return String(s||"").toLowerCase().replace(/[^\w]+/g," ").trim(); },
    idFromAny(x){ if(!x) return null; if(this.CANON[x]) return x; const id=this.ALIASES[this.slug(x)]; return id||null; },
    name(id){ return this.CANON[id]?.name || String(id||"Unknown"); },
    worldId(id){ return this.CANON[id]?.worldId || null; }
  };

  // Make sure the player has a canonical id alongside the display name
  (function bootstrapPlayerLoc(){
    const s = ST();
    if (!s.locationId){
      s.locationId = LOC.idFromAny(s.location) || "ironwood";
      s.location   = LOC.name(s.locationId);
    }
  })();

  // Factions (fallbacks)
  const FACS = (Array.isArray(W.FACTIONS) && W.FACTIONS.length)
    ? W.FACTIONS
    : [
        {id:"none", name:"Unaffiliated"},
        {id:"settlers", name:"Settlers Union"},
        {id:"rangers",  name:"Desert Rangers"},
        {id:"scribes",  name:"Scribes of the Old World"},
        {id:"dust_marauders", name:"Dust Marauders"}
      ];

  // LW state
  const S = {
    tick: 0,
    news: [],
    faction: Object.fromEntries(FACS.map(f => [f.id, { id:f.id, name:f.name, caps:50, land:0, recruits:8 }])),
    npcs: [
      { id:"joe",  name:"Trader Joe", role:"Trader", trust:50, locId:"dustown",  alive:true },
      { id:"sara", name:"Merc Sara",  role:"Merc",   trust:50, locId:"ironwood", alive:true },
      { id:"eli",  name:"Scribe Eli", role:"Scribe", trust:50, locId:"dunes",    alive:true },
    ],
  };
  function pushNews(t){ S.news.push(String(t)); if (S.news.length>40) S.news.shift(); }
  const hereId  = () => ST().locationId;
  const hereStr = () => LOC.name(ST().locationId);

  // NPC wandering (lightweight)
  function moveNPCs(){
    const ring = Object.keys(LOC.CANON);
    S.npcs.forEach(n=>{
      if(!n.alive) return;
      if (Math.random()<0.45){
        const i = Math.max(0, ring.indexOf(n.locId));
        n.locId = ring[(i + (Math.random()<0.5?-1:1) + ring.length) % ring.length];
      }
    });
  }
  function tick(){
    S.tick++; moveNPCs();
    pushNews(`The year ${2165 + S.tick} passes in the wastes.`);
    ensureSocialBtn();
  }

  // Travel helper (prefer your Text Map)
  function travelToId(id){
    const cid = LOC.idFromAny(id); if (!cid) return;
    const wid = LOC.worldId(cid);
    if (typeof W.WL_TextMap?.travelTo === "function"){ W.WL_TextMap.travelTo(wid); return; }
    // fallback if Text Map is missing
    const s = ST(); s.locationId = cid; s.location = LOC.name(cid); logSafe(`You travel to ${s.location}.`); W.updateUI?.();
  }

  // Social button
  function ensureSocialBtn(){
    if (document.getElementById("btn-social")) return;
    const anchor = document.getElementById("btn-inventory")?.closest(".group")
                || document.querySelector(".actions .group")
                || document.querySelector(".actions")
                || document.body;
    const b = document.createElement("button");
    b.id = "btn-social"; b.textContent = "Social / NPCs"; b.onclick = openSocial;
    anchor.appendChild(b);
  }

  function openSocial(){
    const rowsF = FACS.map(f=>{
      const F=S.faction[f.id]; if(!F) return "";
      return `<tr><td>${F.name}</td><td>${F.caps}</td><td>${F.recruits}</td></tr>`;
    }).join("");

    const all    = S.npcs.filter(n => n.alive);
    const nearby = all.filter(n => n.locId === hereId());
    const other  = all.filter(n => n.locId !== hereId());

    const rows = (list) => list.map(n => `
      <tr>
        <td><button class="choice" onclick="LW.openNPC('${n.id}')">${n.name}</button></td>
        <td>${n.role}</td>
        <td>${LOC.name(n.locId)}</td>
      </tr>`).join("") || `<tr><td colspan="3">—</td></tr>`;

    const news = S.news.slice(-7).map(s=>`<li>${s}</li>`).join("") || "<li>(quiet)</li>";

    showModalSimple("Social — NPCs", `
      <div class="title">Factions</div>
      <table style="width:100%;font-family:var(--mono);font-size:12px;border-collapse:collapse">
        <tr><th align="left">Name</th><th>Caps</th><th>Recruits</th></tr>${rowsF}
      </table>
      <div class="title" style="margin-top:8px">Here in ${hereStr()}</div>
      <table style="width:100%;font-family:var(--mono);font-size:12px;border-collapse:collapse">
        <tr><th align="left">Name</th><th>Role</th><th align="left">Location</th></tr>${rows(nearby)}
      </table>
      <div class="hr"></div>
      <details><summary class="linklike">Show NPCs elsewhere</summary>
        <table style="width:100%;font-family:var(--mono);font-size:12px;border-collapse:collapse">
          <tr><th align="left">Name</th><th>Role</th><th align="left">Location</th></tr>${rows(other)}
        </table>
      </details>
      <div class="title" style="margin-top:8px">Recent News</div>
      <ul style="margin:6px 0 0 18px">${news}</ul>
    `);
  }

  function openNPC(idOrObj){
    const npc = (typeof idOrObj === "string") ? S.npcs.find(x=>x.id===idOrObj && x.alive) : idOrObj;
    if (!npc) return showModalSimple("NPC not found","");

    const near = (npc.locId === hereId());
    let html = ``;
    // Basic information
    html += `<p><b>${npc.name}</b> (${npc.role})<br>
      Location: ${LOC.name(npc.locId)}${near ? " (nearby)" : ""}<br>
      Trust: ${npc.trust ?? 0}`;
    // Show respect and affection if available
    if (typeof npc.respect === "number") html += `, Respect: ${npc.respect}`;
    if (typeof npc.affection === "number") html += `, Affection: ${npc.affection}`;
    html += `</p>`;
    // Show personality traits
    if (npc.personality) {
      const { attitude, morality, pragmatism } = npc.personality;
      html += `<p><b>Personality:</b> ${attitude || ''}, ${morality || ''}, ${pragmatism || ''}</p>`;
    }
    // Show goals
    if (npc.goals) {
      const sg = npc.goals.short;
      const lg = npc.goals.long;
      if (sg) {
        let sgDesc;
        switch (sg.type) {
          case "raid": sgDesc = `raid ${LOC.name(sg.target)}`; break;
          case "trade": sgDesc = `trade with ${LOC.name(sg.target)}`; break;
          case "research": sgDesc = `study tech at ${LOC.name(sg.target)}`; break;
          case "explore": sgDesc = `explore the area around ${LOC.name(sg.target)}`; break;
          case "patrol": sgDesc = `patrol near ${LOC.name(sg.target)}`; break;
          case "recruit": sgDesc = `recruit in ${LOC.name(sg.target)}`; break;
          default: sgDesc = `${sg.type} at ${LOC.name(sg.target)}`;
        }
        html += `<p><b>Current Mission:</b> ${sgDesc}</p>`;
      }
      if (lg) {
        html += `<p><b>Long-Term Goal:</b> ${lg.desc || lg.type}</p>`;
      }
    }
    // Show mood/state indicators
    if (typeof npc.morale === "number" || typeof npc.health === "number" || typeof npc.wealth === "number" || typeof npc.stress === "number") {
      const parts = [];
      if (typeof npc.morale === "number") parts.push(`Morale: ${npc.morale}`);
      if (typeof npc.health === "number") parts.push(`Health: ${npc.health}`);
      if (typeof npc.wealth === "number") parts.push(`Wealth: ${npc.wealth}`);
      if (typeof npc.stress === "number") parts.push(`Stress: ${npc.stress}`);
      html += `<p><b>Mood:</b> ${parts.join(', ')}</p>`;
    }
    // Show relationships
    if (npc.relationships && Object.keys(npc.relationships).length) {
      const lines = [];
      for (const rid in npc.relationships) {
        const other = S.npcs.find(x => x.id === rid);
        if (!other) continue;
        const relation = npc.relationships[rid];
        lines.push(`${relation === 'ally' ? 'Ally' : 'Rival'}: ${other.name}`);
      }
      if (lines.length) html += `<p><b>Connections:</b> ${lines.join('; ')}</p>`;
    }
    // Buttons
    if (!near){
      html += `<button class="choice" onclick="(function(){ LW.travelToId('${npc.locId}'); LW.openNPC('${npc.id}'); })()">Travel to ${LOC.name(npc.locId)}</button>`;
    } else {
      // Chat and rumors always available nearby
      html += `
        <button class="choice" onclick="LW.talk('${npc.id}','chat')">Chat</button>
        <button class="choice" onclick="LW.talk('${npc.id}','rumor')">Ask for Rumors</button>`;
      // Role-specific actions (case-insensitive)
      const role = (npc.role||"").toLowerCase();
      if (/trader/.test(role)) html += `<button class="choice" onclick="LW.talk('${npc.id}','trade')">Trade</button>`;
      if (/merc|guard|scout|hunter|raider/.test(role)) {
        html += `<button class="choice" onclick="(function(){ if (LW.recruit) LW.recruit('${npc.id}'); })()">Recruit</button>`;
      }
      // Ask for work if tasks exist for this NPC (leveraging generic tasks)
      if (LW.askForWork) {
        html += `<button class="choice" onclick="LW.askForWork('${npc.id}')">Ask for Work</button>`;
      }
      if (/scribe|scientist|tech/.test(role)) {
        html += `
        <button class="choice" onclick="LW.talk('${npc.id}','lore')">Share Knowledge</button>
        <button class="choice" onclick="LW.talk('${npc.id}','request')">Request Research</button>`;
      }
    }
    showModalSimple(npc.name, html);
  }

  function talk(id, action){
    const npc = S.npcs.find(n=>n.id===id && n.alive); if(!npc) return;
    const near = (npc.locId === hereId());
    const s = ST();
    let out="", trust=0;

    if (!near && action!=="rumor"){ showModalSimple(npc.name, `<p>${npc.name} is at ${LOC.name(npc.locId)}. Travel there first.</p>`); return; }

    switch(action){
      case "trade": {
        out = `${npc.name} lays out wares. (Hook: open trader UI)`;
        try{ if (W.openTrade) W.openTrade("Trader"); }catch{}
        trust = 1;
        break;
      }
      case "rumor": {
        // Generate a situational rumor. Could involve factions, raids, or gossip about rivals.
        const rumorLines = [];
        // Include gossip about relationships
        if (npc.relationships && Object.keys(npc.relationships).length) {
          const relId = Object.keys(npc.relationships)[Math.floor(Math.random()*Object.keys(npc.relationships).length)];
          const other = S.npcs.find(n => n.id === relId);
          if (other) {
            if (npc.relationships[relId] === 'ally') rumorLines.push(`"${other.name} is making waves lately. Keep an eye on them."`);
            if (npc.relationships[relId] === 'rival') rumorLines.push(`"I hear ${other.name} is scheming against me."`);
          }
        }
        // Faction rumor
        if (Array.isArray(W.FACTIONS) && W.FACTIONS.length) {
          const faction = W.FACTIONS[Math.floor(Math.random()*W.FACTIONS.length)];
          rumorLines.push(`"Word is the ${faction.name} are up to something."`);
        }
        // Location-based rumor
        if (Array.isArray(W.PROC_LOCATIONS) && W.PROC_LOCATIONS.length) {
          const loc = W.PROC_LOCATIONS[Math.floor(Math.random()*W.PROC_LOCATIONS.length)];
          rumorLines.push(`"There's talk of treasure buried near ${LOC.name(loc)}."`);
        }
        out = `${npc.name} whispers: ${rumorLines[Math.floor(Math.random()*rumorLines.length)] || '"Nothing much to report right now."'}`;
        trust = 2;
        break;
      }
      case "hire": {
        const cost = 15;
        if ((s.caps||0) >= cost){
          s.caps -= cost;
          out = `${npc.name} agrees to guard you for a while. (Companion stub)`;
          trust = 3;
          if (W.updateUI) W.updateUI();
        } else {
          out = `${npc.name}: "Come back with ${cost} caps."`;
        }
        break;
      }
      case "lore": {
        out = `${npc.name} teaches you pre-war tech insights. (+10 XP)`;
        if (W.gainXP) W.gainXP(10);
        trust = 2;
        break;
      }
      case "request": {
        out = `${npc.name}: "Bring me a Holotape and I'll share a schematic."`;
        trust = 1;
        break;
      }
      default: {
        // Dynamic chat: reference NPC mood, goals, relationships, personality
        const lines = [];
        // Mood-based lines
        if (npc.health < 40) lines.push(`"I'm nursing some wounds from our last encounter."`);
        if (npc.morale < 40) lines.push(`"Our spirits are low. Hard times have taken their toll."`);
        if (npc.morale > 70) lines.push(`"We feel unstoppable after recent successes."`);
        if (npc.wealth > 70) lines.push(`"We're flush with loot after our recent haul."`);
        if (npc.stress > 60) lines.push(`"Tension is high — I can sense the pressure on my crew."`);
        // Goal-based lines
        if (npc.goals && npc.goals.short) {
          const sg = npc.goals.short;
          if (sg.type === 'raid') lines.push(`"We're gearing up to raid ${LOC.name(sg.target)} soon."`);
          if (sg.type === 'trade') lines.push(`"I'm planning a trade run to ${LOC.name(sg.target)}."`);
          if (sg.type === 'research') lines.push(`"There are secrets to uncover at ${LOC.name(sg.target)}."`);
          if (sg.type === 'explore') lines.push(`"I'm itching to explore around ${LOC.name(sg.target)}."`);
          if (sg.type === 'patrol') lines.push(`"I'm due to patrol near ${LOC.name(sg.target)}."`);
          if (sg.type === 'recruit') lines.push(`"I've got to recruit more hands in ${LOC.name(sg.target)}."`);
        }
        // Long-term goal line
        if (npc.goals && npc.goals.long && Math.random() < 0.5) {
          lines.push(`"Someday I'll ${npc.goals.long.desc || npc.goals.long.type}."`);
        }
        // Relationship-based lines
        if (npc.relationships && Object.keys(npc.relationships).length && Math.random() < 0.5) {
          const keys = Object.keys(npc.relationships);
          const rid = keys[Math.floor(Math.random()*keys.length)];
          const rel = npc.relationships[rid];
          const other = S.npcs.find(x=>x.id===rid);
          if (other) {
            if (rel === 'ally') lines.push(`"My ally ${other.name} has my back."`);
            if (rel === 'rival') lines.push(`"I can't stand ${other.name}; they'll get what's coming to them."`);
          }
        }
        // Personality-based lines
        if (npc.personality && Math.random() < 0.5) {
          const { attitude, morality, pragmatism } = npc.personality;
          lines.push(`"I'm the ${attitude} type, some would say."`);
          lines.push(`"I consider myself quite ${morality}."`);
          lines.push(`"I take a ${pragmatism} view of things."`);
        }
        // Fallback line if nothing else
        if (lines.length === 0) {
          lines.push(`"The road never ends out here."`);
        }
        out = `${npc.name}: ${lines[Math.floor(Math.random()*lines.length)]}`;
        // Increase trust slightly for taking time to chat
        trust = 1;
        break;
      }
    }

    npc.trust = Math.min(100, (npc.trust||0) + trust);
    pushNews(out); logSafe(out);
    showModalSimple(npc.name, `<p>${out}</p><p>Trust now: ${npc.trust}</p>`);
  }

  // Wire up
  function patch(){
    ensureSocialBtn();
    const age = document.getElementById("btn-age");
    if (age && !age.dataset._lw){ age.dataset._lw="1"; age.addEventListener("click", ()=> setTimeout(tick,0)); }
    const c = document.getElementById("modal-close");
    if (c && !c.dataset._lw){ c.dataset._lw="1"; c.addEventListener("click", ()=>{ const mb=document.getElementById("modal-backdrop"); if(mb) mb.style.display="none"; }); }
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", patch);
  else patch();

  // Expose for onclicks
  // Merge into existing LW object instead of overwriting it so that other add-ons
  // (e.g. faction_npcs.js) can define additional helpers like openJobBoard and
  // accept/complete NPC tasks.  Without this merge, setting LW here would
  // discard any properties previously attached to LW by other scripts.
  W.LW = Object.assign(W.LW || {}, { state:S, openSocial, openNPC, talk, travelToId });

  /**
   * Ask a specific NPC for work. Displays tasks that can be accepted or completed.
   */
  LW.askForWork = function(npcId) {
    const npc = (LW.state.npcs || []).find(n => n.id === npcId && n.alive);
    if (!npc) return;
    // Ensure tasks exist for this NPC
    if (typeof LW.ensureNPCTasks === 'function') LW.ensureNPCTasks(npc);
    const tasks = npc.tasks || [];
    let content = '';
    tasks.forEach(t => {
      const status = npc.taskStatus && npc.taskStatus[t.id];
      let line = `<b>${t.title}</b><br><span class="small">${t.desc}</span><br>`;
      if (status === 'available') {
        line += `<button class="choice" onclick="LW.acceptNPCTask('${npc.id}','${t.id}'); LW.askForWork('${npc.id}');">Accept</button>`;
      } else if (status === 'accepted') {
        // check if requirements met
        const canComplete = (function(req){ if (!req) return true; const S = W.state || {}; if (req.items && Array.isArray(req.items)) { for (const it of req.items) { const count = (typeof W.countItem === 'function' ? W.countItem(it.id) : 0) || 0; if (count < (it.qty || 1)) return false; } } if (req.caps && (S.caps || 0) < req.caps) return false; return true; })(t.req);
        if (canComplete) {
          line += `<button class="choice" onclick="LW.completeNPCTask('${npc.id}','${t.id}'); LW.askForWork('${npc.id}');">Complete</button>`;
        } else {
          line += `<span class="muted">Missing items</span>`;
        }
      } else if (status === 'completed') {
        line += `<span class="muted">Completed</span>`;
      }
      content += `<div style="margin-bottom:8px">${line}</div>`;
    });
    if (!content) content = '<p>(No tasks available)</p>';
    showModalSimple(`Work for ${npc.name}`, content);
  };

  /**
   * Attempt to recruit an NPC as a companion. Requires high trust.
   */
  LW.recruit = function(npcId) {
    const npc = (LW.state.npcs || []).find(n => n.id === npcId && n.alive);
    if (!npc) return;
    const Sstate = W.state || {};
    Sstate.companions = Sstate.companions || [];
    if (Sstate.companions.find(c => c.id === npcId)) {
      showModalSimple(npc.name, `<p>${npc.name} is already travelling with you.</p>`);
      return;
    }
    const requiredTrust = 70;
    if ((npc.trust || 0) < requiredTrust) {
      showModalSimple(npc.name, `<p>${npc.name}: "We aren't that close. Earn my trust first."</p>`);
      return;
    }
    // Add to companions
    Sstate.companions.push({ id: npc.id, name: npc.name, role: npc.role });
    showModalSimple(npc.name, `<p>${npc.name} agrees to accompany you. They may aid you in combat or other events.</p>`);
    // Slight stat benefit: increase player's max HP or XP as a placeholder
    if (typeof W.gainXP === 'function') W.gainXP(5);
    if (typeof W.updateUI === 'function') W.updateUI();
  };
})();</script>
<script>// faction_npcs.js
(function(){
  if (window.__FACTION_NPCS_BLOCK__) return; window.__FACTION_NPCS_BLOCK__ = true;

  const W = window;
  const S  = W.state  || (W.state = {});
  const LW = W.LW     || (W.LW    = { state:{ npcs:[] } });
  LW.state = LW.state || { npcs:[] };

  // ---- helpers
  const factionName = (fid)=>{
    const list = (W.FACTIONS || []);
    const f = list.find(x=>x.id===fid);
    return f ? f.name : (fid==="none" ? "Independent" : (fid||"Unknown"));
  };

  // ---- 1) Canonical roster (edit freely)
  const ROSTER = [
    { id:"pike",  name:"Trader Pike", role:"Quartermaster", factionId:"settlers",       start:"dustown",
      bio:"Caravan fixer with a ledger for every handshake." },
    { id:"mae",   name:"Doc Mae",     role:"Field Medic",   factionId:"scribes",        start:"ironwood",
      bio:"Gentle voice, steady hands, and a belt of tonics." },
    { id:"colt",  name:"Ranger Colt", role:"Scout Lt.",     factionId:"rangers",        start:"ironwood",
      bio:"Edges sharp as his eyes; smells like dust and gun oil." },
    { id:"sal",   name:"Shady Sal",   role:"Fence",         factionId:"dust_marauders", start:"canyon",
      bio:"A smile like a cracked bottle. ‘No questions’ policy." },
    { id:"ishi",  name:"Tinker Ishi", role:"Scrapwright",   factionId:"none",           start:"dustown",
      bio:"Wires braided like hair; pockets full of miracles." },
    { id:"lark",  name:"Old Man Lark",role:"Wanderer",      factionId:"none",           start:"dunes",
      bio:"Stories older than the dust. Sometimes true." },
  ];

  // ---- 2) Seed them into LW.state.npcs (once per save, but also top-up missing ones)
  function ensureNPCSeed(n){
    LW.state.npcs = LW.state.npcs || [];
    let npc = LW.state.npcs.find(x=>x.id===n.id);
    if (!npc){
      npc = {
        id:n.id, name:n.name, role:n.role, bio:n.bio || "",
        factionId:n.factionId || "none",
        locId:n.start || "ironwood",
        trust:45, alive:true
      };
      LW.state.npcs.push(npc);
    } else {
      npc.alive = (npc.alive !== false);
      npc.factionId = npc.factionId || (n.factionId||"none");
      npc.locId = npc.locId || n.start || "ironwood";
      npc.role = npc.role || n.role;
      npc.name = npc.name || n.name;
      if (n.bio && !npc.bio) npc.bio = n.bio;
    }
  }

  function seedAllIfNeeded(){
    if (!S.__seededFactionRoster__){
      ROSTER.forEach(ensureNPCSeed);
      S.__seededFactionRoster__ = true;
      (W.log||console.log)("Faction NPCs seeded into world.");
    } else {
      // top up in case roster grew between versions
      ROSTER.forEach(ensureNPCSeed);
    }
  }

  seedAllIfNeeded();

  // ---- 3) Augment the Factions screen with “contacts by faction” chips
  function renderFactionChips(){
    let mount = document.getElementById("faction-npc-chips");
    if (!mount){
      const parent =
        document.querySelector("#factions, .factions, [data-factions], section.factions, .card.factions")
        || document.querySelector(".card:has(.title):has(.-factions)")
        || document.body;
      mount = document.createElement("section");
      mount.id = "faction-npc-chips";
      mount.className = "card";
      mount.innerHTML = `
        <div class="title">Faction Contacts</div>
        <p class="small muted">Known NPCs grouped by faction. Click to talk.</p>
        <div id="faction-npc-chips-body"></div>
      `;
      parent.appendChild(mount);
    }

    const byFaction = {};
    (LW.state.npcs||[]).filter(n=>n.alive!==false).forEach(n=>{
      const f = n.factionId || "none";
      (byFaction[f] = byFaction[f] || []).push(n);
    });

    if (!document.getElementById("faction-chip-style")){
      const st = document.createElement("style");
      st.id = "faction-chip-style";
      st.textContent = `
        #faction-npc-chips .chiprow{ display:flex; flex-wrap:wrap; gap:6px; margin:8px 0 16px; }
        #faction-npc-chips .chip { display:inline-flex; align-items:center; gap:6px;
          padding:4px 10px; border:1px solid rgba(255,255,255,0.08);
          border-radius:999px; cursor:pointer; font-size:.9em;
          background:rgba(255,255,255,0.03); }
        #faction-npc-chips .chip .role{ opacity:.65; font-size:.85em }
      `;
      document.head.appendChild(st);
    }

    const myFaction = (S.faction||"none");
    const keys = Object.keys(byFaction).sort((a,b)=>{
      if (a===myFaction && b!==myFaction) return -1;
      if (b===myFaction && a!==myFaction) return 1;
      return a.localeCompare(b);
    });

    const body = document.getElementById("faction-npc-chips-body");
    if (!body) return;
    body.innerHTML = keys.map(fid=>{
      const list = byFaction[fid];
      const chips = list.map(n=>`
        <span class="chip" title="${factionName(n.factionId)}"
              onclick="(window.LW && LW.openNPC) ? LW.openNPC('${n.id}') : null">
          <b>${n.name}</b><span class="role">· ${n.role||"NPC"}</span>
        </span>
      `).join("");
      return `
        <div class="kv">
          <div>${factionName(fid)}</div>
          <div class="chiprow">${chips || '<span class="small muted">No known contacts</span>'}</div>
        </div>
        <div class="hr"></div>
      `;
    }).join("") || `<p class="muted">No contacts yet.</p>`;
  }

  // ---- 4) Patch your NPC modal so it shows the faction explicitly
  // We wrap LW.openNPC, call the original, then inject a “Faction” line into the modal.
  const _openNPC = LW.openNPC;
  LW.openNPC = function(id){
    if (typeof _openNPC === "function") _openNPC(id);
    try {
      // Find the npc in state and render the line
      const npc = (LW.state.npcs||[]).find(n=>n.id===id) || { factionId:"none" };
      const fName = factionName(npc.factionId);

      // Try to locate your modal content area
      const modal = document.querySelector("#modal-content, .modal-content, #npc-modal .content") || document.body;
      if (!modal) return;

      // Avoid dupes
      const existing = document.getElementById("npc-faction-line");
      if (existing) existing.remove();

      // If there’s a kv grid already, add a row. Otherwise add a small block.
      const kv = modal.querySelector(".kv");
      if (kv){
        const label = document.createElement("div"); label.textContent = "Faction";
        const value = document.createElement("div"); value.innerHTML = `<b>${fName}</b>`;
        const marker = document.createElement("div"); marker.id = "npc-faction-line"; marker.style.display="contents";
        marker.appendChild(label); marker.appendChild(value);
        kv.appendChild(marker);
      } else {
        const block = document.createElement("div");
        block.id = "npc-faction-line";
        block.className = "small";
        block.style.margin = "8px 0";
        block.innerHTML = `<span class="muted">Faction:</span> <b>${fName}</b>`;
        modal.prepend(block);
      }
    } catch(e){}
  };

  // ---- 5) Keep everything synced whenever your UI refreshes
  const _updateUI = W.updateUI;
  W.updateUI = function(){
    _updateUI && _updateUI();
    try { seedAllIfNeeded(); renderFactionChips(); } catch(e){}
  };

  // First paint (covers initial load)
  try { renderFactionChips(); } catch(e){}
})();





	/* Wastelife — NPC Factions + Stats + Growth (non-breaking add-on) */
(function () {
  "use strict";
  // Debug: verify this script executes by logging to the Life Log.  This
  // message will appear once when the NPC growth/quest script runs.
  try { (window.log||console.log)("[NPC] growth & quest module loaded"); } catch(_){ }
  // Always set the growth flag but do not bail early.  In previous versions
  // of Wastelife, __WL_NPC_GROWTH__ was set to prevent this script from
  // executing more than once.  However, that caused our upgrades (tasks,
  // job board) to be skipped entirely if the flag was already defined by
  // another script.  To ensure the quest logic always runs, we remove the
  // early return and simply mark the flag here.  If another script has
  // already set this flag, it will be overwritten but still allow this
  // block to execute.
  window.__WL_NPC_GROWTH__ = true;

  const W  = window;
  const LW = W.LW || (W.LW = { state:{ npcs:[] } });
  LW.state = LW.state || { npcs:[] };

  /* -------- Factions (fallback names) -------- */
  const FLIST = (Array.isArray(W.FACTIONS) && W.FACTIONS.length)
    ? W.FACTIONS
    : [
      { id:"none",            name:"Independent" },
      { id:"settlers",        name:"Settlers Union" },
      { id:"rangers",         name:"Desert Rangers" },
      { id:"scribes",         name:"Scribes of the Old World" },
      { id:"dust_marauders",  name:"Dust Marauders" },
    ];
  const FNAME = fid => (FLIST.find(f=>f.id===fid)?.name) || (fid==="none" ? "Independent" : "Unknown");

  /* -------- NPC Tasks & Quests -------- */
  // Define tasks per NPC. Each task has an id, title, description, requirements and rewards.
  // Requirements can include `items` (array of {id, qty}) and `caps`. Rewards can include
  // `items`, `caps`, `xp`, and `trust`. Feel free to expand this list to add more
  // engaging content. Players can accept one task at a time per NPC; once a task is
  // completed it cannot be repeated. New tasks can be added in later updates.
  const NPC_TASKS_DEF = {
    pike: [
      {
        id: "pike_1",
        title: "Restock Supplies",
        desc: "Pike needs more materials for his caravans. Bring him 2× Junk and 1× Duct Tape.",
        req: { items: [{id:"junk", qty:2}, {id:"duct_tape", qty:1}] },
        reward: { caps: 30, xp: 10, trust: 5 }
      },
      {
        id: "pike_2",
        title: "Weapon Tune-Up",
        desc: "Pike wants to upgrade his guards. Bring him 1 Revolver and 10 rounds of .38 Ammo.",
        req: { items: [{id:"revolver", qty:1}, {id:"ammo_38", qty:10}] },
        reward: { caps: 60, xp: 25, trust: 12 }
      }
    ],
    mae: [
      {
        id: "mae_1",
        title: "Medical Emergency",
        desc: "Doc Mae needs medicine. Bring her 1 Rad Purge and 1 Duct Tape.",
        req: { items: [{id:"rad_purge", qty:1}, {id:"duct_tape", qty:1}] },
        reward: { caps: 50, xp: 20, trust: 10 }
      },
      {
        id: "mae_2",
        title: "Radiation Shield",
        desc: "Mae wants extra Rad Shield for her field kit. Bring her 1 Rad Shield.",
        req: { items: [{id:"rad_shield", qty:1}] },
        reward: { caps: 20, xp: 10, trust: 6 }
      }
    ],
    colt: [
      {
        id: "colt_1",
        title: "Scout the Perimeter",
        desc: "Ranger Colt is low on ammunition. Bring him 10 rounds of .308 Ammo.",
        req: { items: [{id:"ammo_308", qty:10}] },
        reward: { xp: 30, trust: 12, caps: 20 }
      },
      {
        id: "colt_2",
        title: "Sharpshooter Trial",
        desc: "Prove your precision. Deliver 1 Hunting Rifle to Colt.",
        req: { items: [{id:"hunting_rifle", qty:1}] },
        reward: { xp: 35, trust: 14 }
      }
    ],
    sal: [
      {
        id: "sal_1",
        title: "Under-the-Table Deal",
        desc: "Shady Sal wants some scrap to fence. Bring him 3 Junk.",
        req: { items: [{id:"junk", qty:3}] },
        reward: { caps: 80, xp: 25, trust: 10 }
      }
    ],
    ishi: [
      {
        id: "ishi_1",
        title: "Prototype Repair",
        desc: "Tinker Ishi needs parts for his prototype. Bring him 3 Duct Tape and 5 Junk.",
        req: { items: [{id:"duct_tape", qty:3}, {id:"junk", qty:5}] },
        reward: { xp: 30, trust: 12, caps: 25 }
      }
    ],
    lark: [
      {
        id: "lark_1",
        title: "Tales of the Past",
        desc: "Old Man Lark is looking for relics. Bring him 1 Ancient Holotape.",
        req: { items: [{id:"holotape", qty:1}] },
        reward: { xp: 20, trust: 10 }
      }
    ]
  };

  /* -------- Generic role-based tasks -------- */
  // These tasks are assigned to procedural NPCs based on their role. They
  // provide simple fetch quests so the player can interact with generated
  // characters. When a procedural NPC with one of these roles is first
  // encountered, ensureTasks will assign these tasks if no explicit task
  // definition exists for the NPC ID.
  const GENERIC_ROLE_TASKS = {
    Trader: [
      {
        id: "gen_trader_1",
        title: "Restock Goods",
        desc: "This trader needs more materials for their caravan. Bring them 2× Junk and 1× Duct Tape.",
        req: { items: [{id:"junk", qty:2}, {id:"duct_tape", qty:1}] },
        reward: { caps: 30, xp: 10, trust: 5 }
      },
      {
        id: "gen_trader_2",
        title: "Special Order",
        desc: "Deliver 1 Revolver and 10 rounds of .38 Ammo to fill a special request.",
        req: { items: [{id:"revolver", qty:1}, {id:"ammo_38", qty:10}] },
        reward: { caps: 60, xp: 25, trust: 10 }
      }
    ],
    Raider: [
      {
        id: "gen_raider_1",
        title: "Arms Deal",
        desc: "This raider wants extra firepower. Bring them 5× .308 Ammo.",
        req: { items: [{id:"ammo_308", qty:5}] },
        reward: { xp: 20, trust: 8, caps: 20 }
      },
      {
        id: "gen_raider_2",
        title: "Salvage Raid",
        desc: "Deliver 1 Hunting Rifle to bolster their crew.",
        req: { items: [{id:"hunting_rifle", qty:1}] },
        reward: { xp: 35, trust: 12 }
      }
    ],
    Scientist: [
      {
        id: "gen_scientist_1",
        title: "Research Materials",
        desc: "This scientist needs chemicals. Bring 1 Rad Purge and 1 Duct Tape.",
        req: { items: [{id:"rad_purge", qty:1}, {id:"duct_tape", qty:1}] },
        reward: { xp: 25, trust: 8, caps: 20 }
      },
      {
        id: "gen_scientist_2",
        title: "Shield Upgrade",
        desc: "Deliver 1 Rad Shield for protective experiments.",
        req: { items: [{id:"rad_shield", qty:1}] },
        reward: { xp: 12, trust: 6, caps: 15 }
      }
    ],
    Wanderer: [
      {
        id: "gen_wanderer_1",
        title: "Stories for the Road",
        desc: "Find and bring 1 Holotape full of old world tales.",
        req: { items: [{id:"holotape", qty:1}] },
        reward: { xp: 20, trust: 10 }
      }
    ]
  };

  // Ensure an NPC has tasks initialized and a status tracker. Called in assure() and when opening NPC.
  function ensureTasks(npc) {
    if (!npc) return;
    if (!npc.tasks) {
      // Use explicit tasks if defined for the NPC ID. Otherwise fall back
      // to generic tasks based on the NPC's role. This allows procedural
      // NPCs to provide simple quests without hard coding every id.
      const explicit = NPC_TASKS_DEF[npc.id] || [];
      const generic = GENERIC_ROLE_TASKS[npc.role] || [];
      const defs = explicit.length ? explicit : generic;
      npc.tasks = defs.map(t => JSON.parse(JSON.stringify(t)));
    }
    if (!npc.taskStatus) {
      npc.taskStatus = {};
      (npc.tasks || []).forEach(t => { npc.taskStatus[t.id] = "available"; });
    }
  }

  /* -------- Ensure every NPC has stats/faction -------- */
  function defaultStats() {
    return { STR:3, PER:3, END:3, CHA:3, INT:3, AGI:3, LCK:3, HP:20, curHP:20 };
  }
  function assure(npc) {
    if (!npc) return npc;
    npc.role       = npc.role || "NPC";
    npc.factionId  = npc.factionId || "none";
    npc.level      = npc.level || 1;
    npc.xp         = npc.xp || 0;
    npc.nextXp     = npc.nextXp || (lvl => 10 + Math.floor(lvl*lvl*5));
    npc.points     = npc.points || 0;
    npc.stats      = npc.stats || defaultStats();
    npc.maxHP      = npc.maxHP || (() => 15 + npc.stats.END*3 + npc.level*2);
    npc.stats.curHP = Math.min(npc.stats.curHP || npc.maxHP(), npc.maxHP());

    // Ensure tasks & task statuses exist
    ensureTasks(npc);
    return npc;
  }
  (LW.state.npcs||[]).forEach(assure);

  /* -------- Per-age growth -------- */
  function autoAllocate(n) {
    const biasByRole = {
      "Merc": ["STR","END","AGI"],
      "Scout": ["PER","AGI","LCK"],
      "Scout Lt.": ["PER","AGI","INT"],
      "Field Medic": ["INT","END","CHA"],
      "Trader": ["CHA","LCK","PER"],
    };
    const keys = ["STR","PER","END","CHA","INT","AGI","LCK"];
    const bias = biasByRole[n.role] || ["CHA","LCK","END"];
    while ((n.points||0) > 0) {
      const k = Math.random() < 0.7 ? bias[(Math.random()*bias.length)|0] : keys[(Math.random()*keys.length)|0];
      n.stats[k] = Math.min(10, (n.stats[k]||1)+1);
      n.points--;
    }
  }
  function grow(n) {
    if (!n || n.alive===false) return;
    n.xp += 1 + Math.floor((n.trust||50)/50);        // passive XP
    if (Math.random() < 0.05) n.trust = Math.min(100, (n.trust||50) + 1);  // warm up a bit
    if (Math.random() < 0.10) {                      // tiny stat drift
      const k = ["STR","PER","END","CHA","INT","AGI","LCK"][(Math.random()*7)|0];
      n.stats[k] = Math.min(10, (n.stats[k]||1)+1);
    }
    while (n.xp >= n.nextXp(n.level)) {
      n.xp -= n.nextXp(n.level);
      n.level += 1;
      n.points = (n.points||0) + 2;
      autoAllocate(n);
      n.stats.curHP = Math.min(n.maxHP(), (n.stats.curHP||n.maxHP()) + 5);
      (W.log||console.log)(`${n.name} reached level ${n.level}`);
    }
  }
  function growAll(){ (LW.state.npcs||[]).forEach((n)=>{ assure(n); grow(n); }); }
  W.WL_NPC_GROWTH = { growAll }; // optional manual use from console

  /* Hook: whenever the user clicks Age Up, grow NPCs too */
  function attachAgeHook() {
    const btn = document.getElementById("btn-age");
    if (!btn || btn.dataset._npcGrowth) return;
    btn.dataset._npcGrowth = "1";
    btn.addEventListener("click", () => setTimeout(growAll, 0));
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", attachAgeHook);
  else attachAgeHook();

  /* -------- NPC modal: inject faction + stats UI -------- */
  // We wrap your LW.openNPC: call your original to open the modal, then replace the content.
  const _openNPC = LW.openNPC;
  function renderNPCPanel(npc, isNearby) {
    // small style once
    if (!document.getElementById("wl-npc-style")) {
      const st = document.createElement("style");
      st.id = "wl-npc-style";
      st.textContent = `
        .wl-npc-panel .chips{ display:grid; grid-template-columns:repeat(7,1fr); gap:6px; margin:8px 0 10px; }
        .wl-npc-panel .chip{ text-align:center; padding:6px 8px; border:1px solid #3a3124; background:#1d1a15; border-radius:8px; }
        .wl-npc-panel .bar{ height:6px; background:#2b2b2b; border-radius:6px; overflow:hidden; margin:4px 0 8px; }
        .wl-npc-panel .bar>i{ display:block; height:6px; background:#a57a2a; }
        .wl-npc-panel .btns{ display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
        .wl-npc-panel .btns .choice{ background:#2b241a; border:1px solid #4b3a22; border-radius:8px; padding:6px 10px; }
      `;
      document.head.appendChild(st);
    }

    const xp = npc.xp|0, need = npc.nextXp(npc.level), pct = Math.max(0, Math.min(100, Math.round((xp/need)*100)));
    const facName = FNAME(npc.factionId);

    let html = `
      <div class="wl-npc-panel">
        <p><b>${npc.name}</b> (${npc.role})<br>
        <span class="muted">Faction:</span> <b>${facName}</b><br>
        Location: ${npc.locName || ""}${isNearby ? " (nearby)" : ""}<br>
        Trust: ${npc.trust ?? 0}</p>
        <div>Level ${npc.level} · XP ${xp}/${need}</div>
        <div class="bar"><i style="width:${pct}%"></i></div>
        <div class="chips">
          ${["STR","PER","END","CHA","INT","AGI","LCK"].map(k=>`<div class="chip">${k} ${npc.stats[k]}</div>`).join("")}
        </div>
    `;

    // Travel button if far away
    if (!isNearby) {
      html += `<button class="choice" onclick="(function(){ LW.travelToId('${npc.locId}'); LW.openNPC('${npc.id}'); })()">Travel to ${npc.locName || ""}</button>`;
    }
    // Always show action buttons when near (or allow chat & rumor when far)
    html += `<div class="btns">
      <button class="choice" onclick="LW.talk('${npc.id}','chat')">Chat</button>
      <button class="choice" onclick="LW.talk('${npc.id}','rumor')">Ask for Rumors</button>
      ${npc.role==="Trader" ? `<button class="choice" onclick="LW.talk('${npc.id}','trade')">Trade</button>` : ""}
      ${npc.role==="Merc"   ? `<button class="choice" onclick="LW.talk('${npc.id}','hire')">Hire as Guard</button>` : ""}
      ${npc.role==="Scribe" ? `
        <button class="choice" onclick="LW.talk('${npc.id}','lore')">Share Knowledge</button>
        <button class="choice" onclick="LW.talk('${npc.id}','request')">Request Research</button>` : ""}
    </div>`;

    // Inject tasks panel if any tasks exist
    ensureTasks(npc);
    if (npc.tasks && npc.tasks.length) {
      html += `<div class="tasks" style="margin-top:12px;">
        <div class="small" style="margin-bottom:4px;"><b>Tasks</b></div>`;
      for (const t of npc.tasks) {
        const status = npc.taskStatus && npc.taskStatus[t.id];
        let actionHtml = "";
        if (status === "available") {
          actionHtml = isNearby ? `<button class="choice" onclick="LW.acceptNPCTask('${npc.id}','${t.id}')">Accept</button>` : `<span class="muted">Travel to accept</span>`;
        } else if (status === "accepted") {
          // Determine if requirements are met
          const canComplete = isNearby && meetsRequirements(t.req);
          actionHtml = isNearby ? (canComplete ? `<button class="choice" onclick="LW.completeNPCTask('${npc.id}','${t.id}')">Complete</button>` : `<span class="muted">Missing items</span>`) : `<span class="muted">Travel to complete</span>`;
        } else if (status === "completed") {
          actionHtml = `<span class="muted">Completed</span>`;
        } else {
          actionHtml = `<span class="muted">Unknown</span>`;
        }
        html += `<div class="task" style="margin-bottom:8px; border:1px solid #3a3124; padding:6px 8px; border-radius:6px;">
          <div><b>${t.title}</b></div>
          <div class="small" style="margin:4px 0;">${t.desc}</div>
          <div>${actionHtml}</div>
        </div>`;
      }
      html += `</div>`;
    }
    html += `</div>`;
    return html;
  }

  // Helper to get current player location name/id using your existing helpers
  const LOCNAME = (id) => {
    try {
      // The first block defined LOC in its own closure; we look for the visible text in the Social panel build
      const map = { ironwood:"Ironwood", dustown:"Dustown", dunes:"Wasteland Dunes", ruins_zone:"Cracked Ruins", flats_zone:"Salt Flats", canyon:"Red Canyons", swamp:"Irrad. Swamp" };
      return map[id] || id || "Unknown";
    } catch { return id || "Unknown"; }
  };

  LW.openNPC = function(idOrObj){
    // open the original modal first
    if (typeof _openNPC === "function") _openNPC(idOrObj);

    // find npc, ensure stats, compute “nearby”
    const id  = (typeof idOrObj === "string") ? idOrObj : idOrObj?.id;
    const npc = (LW.state.npcs||[]).map(assure).find(n=>n.id===id) || (typeof idOrObj==="object" ? assure(idOrObj) : null);
    if (!npc) return;

    npc.locName = LOCNAME(npc.locId);

    // are we in the same place? try to infer from the modal you already draw
    const playerLocText = (window.state && (window.state.location || window.state.locationId)) || "";
    const near = (String(playerLocText).toLowerCase().includes(String(npc.locName).toLowerCase())) ||
                 (window.state && window.state.locationId && String(window.state.locationId)===String(npc.locId));

    // replace modal content with upgraded panel
    const mc = document.getElementById("modal-content") || document.querySelector("#npc-modal .content");
    if (mc) mc.innerHTML = renderNPCPanel(npc, near);
  };

  /* -------- also enhance the Social table's NPC rows (optional) -------- */
  // Adds “(Faction)” after role in the Social list once it opens next time.
  const mo = new MutationObserver(() => {
    document.querySelectorAll("#modal-content table tr").forEach(tr=>{
      const btn = tr.querySelector("button.choice"); if (!btn) return;
      const name = btn.textContent.trim();
      const n = (LW.state.npcs||[]).find(x=>x.name===name); if (!n) return;
      const cells = tr.querySelectorAll("td");
      if (cells[1] && !cells[1].dataset.factionInjected) {
        cells[1].dataset.factionInjected = "1";
        cells[1].innerHTML = `${cells[1].innerHTML} <span class="muted">(${FNAME(n.factionId||"none")})</span>`;
      }
    });
  });
  mo.observe(document.documentElement, { childList:true, subtree:true });

  /* -------- Task interactions -------- */
  // Accept a task from an NPC. Changes status from "available" to "accepted" and logs the task description.
  LW.acceptNPCTask = function(npcId, taskId) {
    const npc = (LW.state.npcs||[]).find(n=>n.id===npcId);
    if (!npc) return;
    ensureTasks(npc);
    const status = npc.taskStatus && npc.taskStatus[taskId];
    if (status !== "available") return;
    npc.taskStatus[taskId] = "accepted";
    const task = (npc.tasks||[]).find(t=>t.id===taskId);
    if (task) {
      (window.log||console.log)(`${npc.name} gave you a task: ${task.title}. ${task.desc}`);
    }
    (window.updateUI||function(){})();
  };

  // Helper to check if requirements are met. Supports items, caps, explores, kills, flawlessKill and chats counters.
  function meetsRequirements(req) {
    if (!req) return true;
    const S = window.state;
    // Items requirement
    if (req.items && Array.isArray(req.items)) {
      for (const it of req.items) {
        const count = (window.countItem ? window.countItem(it.id) : 0) || 0;
        if (count < (it.qty||1)) return false;
      }
    }
    // Caps requirement
    if (req.caps && (S.caps||0) < req.caps) return false;
    // Kills/explores/flawlessKill/chats are tracked via LW.taskProgress per run; if not found, assume not met
    const tp = S.taskProgress || {};
    if (req.kills && (tp.kills||0) < req.kills) return false;
    if (req.explores && (tp.explores||0) < req.explores) return false;
    if (req.flawlessKill && !tp.flawlessKill) return false;
    if (req.chats && (tp.chats||0) < req.chats) return false;
    return true;
  }

  // Consume requirements: remove items and caps, but leave progress counters.
  function consumeRequirements(req) {
    const S = window.state;
    if (!req) return;
    if (req.items && Array.isArray(req.items) && window.removeItem) {
      for (const it of req.items) {
        for (let i=0; i< (it.qty||1); i++) window.removeItem(it.id);
      }
    }
    if (req.caps) {
      S.caps = (S.caps||0) - req.caps;
    }
  }

  // Grant rewards: add items, caps, xp, trust to npc
  function grantRewards(npc, reward) {
    const S = window.state;
    if (!reward) return;
    if (reward.items && Array.isArray(reward.items) && window.addItem) {
      for (const it of reward.items) {
        for (let i=0; i < (it.qty||1); i++) window.addItem(it.id);
      }
    }
    if (reward.caps) {
      S.caps = (S.caps||0) + reward.caps;
    }
    if (reward.xp && window.gainXP) {
      window.gainXP(reward.xp);
    } else if (reward.xp) {
      S.xp = (S.xp||0) + reward.xp;
    }
    if (reward.trust) {
      npc.trust = Math.min(100, (npc.trust||50) + reward.trust);
    }
  }

  // Complete a task. Checks requirements, consumes resources, grants rewards, and sets status to completed.
  LW.completeNPCTask = function(npcId, taskId) {
    const npc = (LW.state.npcs||[]).find(n=>n.id===npcId);
    if (!npc) return;
    ensureTasks(npc);
    const status = npc.taskStatus && npc.taskStatus[taskId];
    if (status !== "accepted") return;
    const task = (npc.tasks||[]).find(t=>t.id===taskId);
    if (!task) return;
    // Check requirements
    if (!meetsRequirements(task.req)) {
      (window.log||console.log)(`You do not meet the requirements for ${task.title}.`);
      return;
    }
    // Consume
    consumeRequirements(task.req);
    // Grant rewards
    grantRewards(npc, task.reward);
    // Mark completed
    npc.taskStatus[taskId] = "completed";
    (window.log||console.log)(`Task completed: ${task.title}.`);
    (window.updateUI||function(){})();
  };


  // expose manual refresh if you want to call it
  W.WL_NPC_GROWTH.refresh = function(){
    // reopen last opened modal by calling LW.openNPC again with the same id is app-specific; skipping
  };

  /* -------- Job Board -------- */
  // Opens a modal listing all NPC tasks regardless of location. Lets the player accept or complete tasks
  LW.openJobBoard = function(){
    const npcs = (LW.state.npcs||[]).map(assure);
    let html = '';
    npcs.forEach(npc => {
      ensureTasks(npc);
      if (!npc.tasks || npc.tasks.length === 0) return;
      html += `<div style="margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid rgba(255,255,255,0.05)">
        <div><b>${npc.name}</b> (${npc.role}) — <span class="muted">${FNAME(npc.factionId)}</span></div>`;
      npc.tasks.forEach(t => {
        const status = npc.taskStatus && npc.taskStatus[t.id];
        let actionHtml = '';
        if (status === 'available') {
          actionHtml = `<button class="choice" onclick="LW.acceptNPCTask('${npc.id}','${t.id}'); LW.openJobBoard();">Accept</button>`;
        } else if (status === 'accepted') {
          const canComplete = meetsRequirements(t.req);
          actionHtml = canComplete ? `<button class="choice" onclick="LW.completeNPCTask('${npc.id}','${t.id}'); LW.openJobBoard();">Complete</button>` : `<span class="muted">Missing items</span>`;
        } else if (status === 'completed') {
          actionHtml = `<span class="muted">Completed</span>`;
        } else {
          actionHtml = `<span class="muted">Unknown</span>`;
        }
        html += `<div style="margin-left:12px;margin-top:4px">
          <b>${t.title}</b><br>
          <span class="small muted">${t.desc}</span><br>
          ${actionHtml}
        </div>`;
      });
      html += `</div>`;
    });
    if (!html) html = '<p>(No tasks available)</p>';
    // Use the shared modal system to display the job board.  Prefer the
    // global openModal helper from main.js if available; this returns an
    // object with a .content property where we can inject our HTML.
    if (typeof openModal === 'function') {
      const mdl = openModal('Job Board');
      if (mdl && mdl.content) mdl.content.innerHTML = html;
    } else if (typeof showModalSimple === 'function') {
      // Fallback for older versions: use showModalSimple if defined
      showModalSimple('Job Board', html);
    } else {
      // Last resort: log to console
      (window.log||console.log)('Job Board:\n'+html);
    }
  };
  // Attach handler to button after DOM load
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('btn-jobboard');
    if (btn) btn.addEventListener('click', () => { LW.openJobBoard(); });
  }); else {
    const btn = document.getElementById('btn-jobboard');
    if (btn) btn.addEventListener('click', () => { LW.openJobBoard(); });
  }
})();</script>
<script>// npc_tasks.js
/* Wastelife — NPC Tasks & Job Board
 *
 * This add-on defines optional tasks for each faction NPC and provides a
 * centralized Job Board for players to view and manage those tasks.
 * It does not override the NPC dialogue UI; instead, tasks are accepted
 * and completed via the Job Board panel.  The script integrates with
 * existing game helpers (state, countItem, addItem, removeItem, gainXP,
 * openModal) and augments the LW object with new helpers:
 *   LW.acceptNPCTask(npcId, taskId)
 *   LW.completeNPCTask(npcId, taskId)
 *   LW.openJobBoard()
 */
(function(){
  const W  = window;
  const LW = W.LW || (W.LW = { state:{ npcs:[] } });
  LW.state = LW.state || { npcs:[] };

  // Only proceed if NPCs exist.  This script expects the base game to have
  // seeded LW.state.npcs via faction_npcs.js.  Without NPCs there is
  // nothing to do.
  if (!Array.isArray(LW.state.npcs) || LW.state.npcs.length === 0) return;

  /* -------- NPC Tasks Definitions -------- */
  // Each NPC id maps to an array of tasks.  Tasks have an id, title,
  // description, requirements (items or caps), and rewards (items, caps,
  // XP, trust).  Feel free to adjust values to balance gameplay.
  const NPC_TASKS_DEF = {
    pike: [
      {
        id: "pike_1",
        title: "Restock Supplies",
        desc: "Pike needs more materials for his caravans. Bring him 2× Junk and 1× Duct Tape.",
        req: { items: [{id:"junk", qty:2}, {id:"duct_tape", qty:1}] },
        reward: { caps: 30, xp: 10, trust: 5 }
      },
      {
        id: "pike_2",
        title: "Weapon Tune-Up",
        desc: "Pike wants to upgrade his guards. Bring him 1 Revolver and 10 rounds of .38 Ammo.",
        req: { items: [{id:"revolver", qty:1}, {id:"ammo_38", qty:10}] },
        reward: { caps: 60, xp: 25, trust: 12 }
      }
    ],
    mae: [
      {
        id: "mae_1",
        title: "Medical Emergency",
        desc: "Doc Mae needs medicine. Bring her 1 Rad Purge and 1 Duct Tape.",
        req: { items: [{id:"rad_purge", qty:1}, {id:"duct_tape", qty:1}] },
        reward: { caps: 50, xp: 20, trust: 10 }
      },
      {
        id: "mae_2",
        title: "Radiation Shield",
        desc: "Mae wants extra Rad Shield for her field kit. Bring her 1 Rad Shield.",
        req: { items: [{id:"rad_shield", qty:1}] },
        reward: { caps: 20, xp: 10, trust: 6 }
      }
    ],
    colt: [
      {
        id: "colt_1",
        title: "Scout the Perimeter",
        desc: "Ranger Colt is low on ammunition. Bring him 10 rounds of .308 Ammo.",
        req: { items: [{id:"ammo_308", qty:10}] },
        reward: { xp: 30, trust: 12, caps: 20 }
      },
      {
        id: "colt_2",
        title: "Sharpshooter Trial",
        desc: "Prove your precision. Deliver 1 Hunting Rifle to Colt.",
        req: { items: [{id:"hunting_rifle", qty:1}] },
        reward: { xp: 35, trust: 14 }
      }
    ],
    sal: [
      {
        id: "sal_1",
        title: "Hot Merchandise",
        desc: "Shady Sal wants you to fetch 2 junk and pay 15 caps. He'll make it worth your while.",
        req: { items: [{id:"junk", qty:2}], caps: 15 },
        reward: { caps: 40, xp: 15, trust: 8 }
      }
    ],
    ishi: [
      {
        id: "ishi_1",
        title: "Scrap Delivery",
        desc: "Ishi needs spare parts. Bring 3× Junk to help her build something new.",
        req: { items: [{id:"junk", qty:3}] },
        reward: { caps: 25, xp: 12, trust: 6 }
      }
    ],
    lark: [
      {
        id: "lark_1",
        title: "Old Holotapes",
        desc: "Old Man Lark is searching for lost stories. Find and bring him 1 Holotape.",
        req: { items: [{id:"holotape", qty:1}] },
        reward: { xp: 20, trust: 10, caps: 15 }
      }
    ]
  };

  /* -------- Generic role-based tasks -------- */
  // These tasks provide procedural NPCs with something to do.  They will be cloned
  // when assigned to an NPC.  Role keys are lower-case to match NPC.role.toLowerCase().
  const GENERIC_ROLE_TASKS = {
    trader: [
      {
        title: "Supply Run",
        desc: "Help restock my stall. Bring me 2× Junk and 1× Duct Tape.",
        req: { items: [{id: "junk", qty: 2}, {id:"duct_tape", qty: 1}] },
        reward: { caps: 25, xp: 10, trust: 5 }
      },
      {
        title: "Ammo Delivery",
        desc: "Deliver 10 rounds of .38 Ammo for my customers.",
        req: { items: [{id: "ammo_38", qty: 10}] },
        reward: { caps: 30, xp: 12, trust: 6 }
      }
    ],
    raider: [
      {
        title: "Requisition", // fancy word for stealing
        desc: "We're low on firepower. Bring me 1 Revolver and 5 rounds of .45 Ammo.",
        req: { items: [{id: "revolver", qty:1}, {id:"ammo_45", qty:5}] },
        reward: { caps: 40, xp: 15, trust: 8 }
      },
      {
        title: "Smash & Grab",
        desc: "Snag me 3× Junk from a nearby settlement. They'll never know.",
        req: { items: [{id: "junk", qty:3}] },
        reward: { caps: 20, xp: 8, trust: 4 }
      }
    ],
    scientist: [
      {
        title: "Artifact Analysis",
        desc: "Bring me 1 Holotape and 1 Scrap to analyze.",
        req: { items: [{id: "holotape", qty:1}, {id:"junk", qty:1}] },
        reward: { xp: 25, trust: 6, caps: 15 }
      },
      {
        title: "Rad Shield Calibration",
        desc: "I need 1 Rad Shield and 1 Duct Tape to fix my instruments.",
        req: { items: [{id:"rad_shield", qty:1}, {id:"duct_tape", qty:1}] },
        reward: { xp: 20, caps: 10, trust: 5 }
      }
    ],
    wanderer: [
      {
        title: "Mapping Expedition",
        desc: "Explore the wastes and bring back news. Pay me 1 Holotape as proof.",
        req: { items: [{id:"holotape", qty:1}] },
        reward: { caps: 15, xp: 8, trust: 4 }
      },
      {
        title: "Scrap Haul",
        desc: "Gather 2× Junk on your travels and bring it here.",
        req: { items: [{id:"junk", qty:2}] },
        reward: { caps: 10, xp: 5, trust: 3 }
      }
    ]
    ,
    merc: [
      {
        title: "Ammo Requisition",
        desc: "I'm low on ammo. Bring me 10 rounds of .45 Ammo.",
        req: { items: [{id:"ammo_45", qty:10}] },
        reward: { caps: 25, xp: 12, trust: 6 }
      },
      {
        title: "Weapon Swap",
        desc: "Looking for a fresh firearm. Bring me 1 Pistol to replace my old piece.",
        req: { items: [{id:"pistol", qty:1}] },
        reward: { caps: 35, xp: 15, trust: 8 }
      }
    ]
  };

  /* -------- Helpers -------- */
  function ensureTasks(npc) {
    // If tasks have not been assigned yet, clone from definitions and set status
    if (!npc) return;
    const defs = NPC_TASKS_DEF[npc.id] || [];
    // If no explicit tasks, try generic role tasks
    let tasksToAssign = defs;
    if (defs.length === 0) {
      const roleKey = (npc.role || "").toLowerCase().split(' ')[0];
      const g = GENERIC_ROLE_TASKS[roleKey];
      if (g && g.length) {
        // Clone generic tasks and assign unique IDs per NPC
        tasksToAssign = g.map((t, idx) => {
          const clone = Object.assign({}, t);
          clone.id = `gen_${roleKey}_${idx}_${npc.id}`;
          return clone;
        });
      }
    }
    if (!npc.tasks) {
      npc.tasks = tasksToAssign.map(d => Object.assign({}, d));
      npc.taskStatus = {};
      npc.tasks.forEach(t => { npc.taskStatus[t.id] = "available"; });
    }
  }
  // Determine if the player meets the requirements of a task
  function meetsRequirements(req) {
    if (!req) return true;
    const S = W.state || {};
    if (req.items && Array.isArray(req.items)) {
      for (const it of req.items) {
        const count = (typeof W.countItem === 'function' ? W.countItem(it.id) : 0) || 0;
        if (count < (it.qty || 1)) return false;
      }
    }
    if (req.caps && (S.caps || 0) < req.caps) return false;
    return true;
  }
  // Consume items and caps from the player when completing a task
  function consumeRequirements(req) {
    const S = W.state || {};
    if (!req) return;
    if (req.items && Array.isArray(req.items) && typeof W.removeItem === 'function') {
      for (const it of req.items) {
        for (let i = 0; i < (it.qty || 1); i++) W.removeItem(it.id);
      }
    }
    if (req.caps) {
      S.caps = (S.caps || 0) - req.caps;
    }
  }
  // Grant rewards to the player and NPC
  function grantRewards(npc, reward) {
    const S = W.state || {};
    if (!reward) return;
    if (reward.items && Array.isArray(reward.items) && typeof W.addItem === 'function') {
      for (const it of reward.items) {
        for (let i = 0; i < (it.qty || 1); i++) W.addItem(it.id);
      }
    }
    if (reward.caps) {
      S.caps = (S.caps || 0) + reward.caps;
    }
    if (reward.xp) {
      if (typeof W.gainXP === 'function') W.gainXP(reward.xp);
      else S.xp = (S.xp || 0) + reward.xp;
    }
    if (reward.trust) {
      npc.trust = Math.min(100, (npc.trust || 50) + reward.trust);
    }
  }

  /* -------- Public API on LW -------- */
  // Accept a task (marks status to 'accepted')
  LW.acceptNPCTask = function(npcId, taskId) {
    const npc = (LW.state.npcs || []).find(n => n.id === npcId);
    if (!npc) return;
    ensureTasks(npc);
    if (!npc.taskStatus) npc.taskStatus = {};
    const status = npc.taskStatus[taskId];
    if (status !== 'available') return;
    npc.taskStatus[taskId] = 'accepted';
    // Log acceptance
    try { (W.log || console.log)(`Task accepted: ${taskId}.`); } catch(_){}
    if (typeof W.updateUI === 'function') W.updateUI();
  };
  // Complete a task (check requirements, consume, reward, mark completed)
  LW.completeNPCTask = function(npcId, taskId) {
    const npc = (LW.state.npcs || []).find(n => n.id === npcId);
    if (!npc) return;
    ensureTasks(npc);
    const status = npc.taskStatus && npc.taskStatus[taskId];
    if (status !== 'accepted') return;
    const task = (npc.tasks || []).find(t => t.id === taskId);
    if (!task) return;
    if (!meetsRequirements(task.req)) {
      try { (W.log || console.log)(`You do not meet the requirements for ${task.title}.`); } catch(_){}
      return;
    }
    consumeRequirements(task.req);
    grantRewards(npc, task.reward);
    npc.taskStatus[taskId] = 'completed';
    try { (W.log || console.log)(`Task completed: ${task.title}.`); } catch(_){}
    if (typeof W.updateUI === 'function') W.updateUI();
  };
  // Display a modal listing all tasks for all NPCs
  LW.openJobBoard = function() {
    // Build HTML for each NPC
    const npcs = (LW.state.npcs || []).map(n => { ensureTasks(n); return n; });
    let html = '';
    npcs.forEach(npc => {
      if (!npc.tasks || npc.tasks.length === 0) return;
      html += `<div style="margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid rgba(255,255,255,0.05)">
        <div><b>${npc.name}</b> (${npc.role||'NPC'})</div>`;
      npc.tasks.forEach(t => {
        const status = npc.taskStatus && npc.taskStatus[t.id];
        let actionHtml = '';
        if (status === 'available') {
          actionHtml = `<button class="choice" onclick="LW.acceptNPCTask('${npc.id}','${t.id}'); LW.openJobBoard();">Accept</button>`;
        } else if (status === 'accepted') {
          const canComplete = meetsRequirements(t.req);
          actionHtml = canComplete ? `<button class="choice" onclick="LW.completeNPCTask('${npc.id}','${t.id}'); LW.openJobBoard();">Complete</button>` : `<span class="muted">Missing items</span>`;
        } else if (status === 'completed') {
          actionHtml = `<span class="muted">Completed</span>`;
        } else {
          actionHtml = `<span class="muted">Unknown</span>`;
        }
        html += `<div style="margin-left:12px;margin-top:4px">
          <b>${t.title}</b><br>
          <span class="small muted">${t.desc}</span><br>
          ${actionHtml}
        </div>`;
      });
      html += `</div>`;
    });
    if (!html) html = '<p>(No tasks available)</p>';
    if (typeof W.openModal === 'function') {
      const mdl = W.openModal('Job Board');
      if (mdl && mdl.content) mdl.content.innerHTML = html;
    } else if (typeof W.showModalSimple === 'function') {
      W.showModalSimple('Job Board', html);
    } else {
      // Last resort: write to console/log
      (W.log || console.log)('Job Board:\n' + html);
    }
  };
  // Expose ensureTasks for other modules (e.g., NPC interaction)
  LW.ensureNPCTasks = ensureTasks;
  // Once the DOM is ready, wire up the button
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('btn-jobboard');
      if (btn) btn.addEventListener('click', () => { LW.openJobBoard(); });
    });
  } else {
    const btn = document.getElementById('btn-jobboard');
    if (btn) btn.addEventListener('click', () => { LW.openJobBoard(); });
  }
  // Seed tasks for NPCs on script load
  (LW.state.npcs || []).forEach(npc => ensureTasks(npc));
})();</script>
<script>// procedural_npcs.js
// Procedural NPC Generation for Wastelife
(function(){
  // Ensure global LW namespace exists
  const W = window;
  const LW = W.LW || (W.LW = { state:{ npcs:[] } });
  LW.state = LW.state || { npcs:[] };

  // Pools of names, roles, factions and locations for NPC generation
  const FIRST_NAMES = [
    "Ash", "Blaze", "Cedar", "Dune", "Echo", "Flint",
    "Gale", "Hazel", "Juno", "Kestrel", "Luna", "Moss",
    "Nix", "Oak", "Pax", "Quill", "Roux", "Sable",
    "Thorn", "Umber", "Vega", "Willow", "Xan", "Yarrow", "Zephyr"
  ];
  const LAST_NAMES = [
    "Black", "Stone", "Reed", "Quarry", "Hawthorn", "Ridge",
    "Ashcroft", "Vale", "Hollow", "Harrison", "Morrow", "Davenport",
    "Rowan", "Mercer", "Graves", "Ridley", "Sloan", "Trask",
    "Pike", "March", "Corrigan", "Frost"
  ];
  const ROLES = [
    "Trader", "Raider", "Scientist", "Wanderer", "Scout",
    "Merc", "Field Medic", "Mechanic", "Lab Tech", "Explorer",
    "Hunter", "Farmer", "Caravan Guard", "Fence", "Scrapwright"
  ];
  // List of valid location IDs from the existing map (must match internal map IDs)
  const LOCATIONS = [
    "dustown", "ironwood", "dunes", "canyon",
    "ruins_zone", "flats_zone", "swamp"
  ];

  // Helper to pick a random element from an array
  function rnd(arr){
    return arr[Math.floor(Math.random()*arr.length)];
  }

  // Maintain a simple counter for unique NPC IDs
  let npcCounter = 0;
  function nextId(){
    npcCounter += 1;
    return `proc_${npcCounter}`;
  }

  // Pools for personality traits. NPCs pick one from each category to define their behaviour.
  const PERSONALITY_ATTITUDE = ["reckless", "cautious"];
  const PERSONALITY_MORALITY = ["honorable", "backstabbing"];
  const PERSONALITY_PRAGMATISM = ["pragmatic", "zealous"];

  // Helper to generate a random short-term goal for an NPC.
  function randomShortTermGoal() {
    // Choose goal type; weighting can be adjusted later for personality influences
    const types = ["raid", "trade", "research", "explore", "patrol", "recruit"];
    const type = rnd(types);
    // Pick a random location as the target for location-based goals
    const target = rnd(LOCATIONS);
    return { type, target };
  }

  // Helper to generate a random long-term goal for an NPC.
  function randomLongTermGoal() {
    const types = [
      { type: "unify", desc: "unify raiders under one banner" },
      { type: "prosper", desc: "ensure the prosperity of their people" },
      { type: "knowledge", desc: "uncover lost knowledge and technology" },
      { type: "power", desc: "rise to power within the wasteland" },
      { type: "legend", desc: "become a legend of the wastes" }
    ];
    return rnd(types);
  }

  // Assign random relationships between the new NPC and existing ones. Allies and rivals create gossip and tension.
  function assignRelationships(npc, npcs) {
    // With a small chance, create an ally or rival relationship with one existing NPC
    if (!npcs || npcs.length === 0) return;
    // Maximum one relationship for simplicity
    if (Math.random() < 0.5) {
      const other = rnd(npcs.filter(o => o.id !== npc.id));
      const relation = Math.random() < 0.5 ? "ally" : "rival";
      npc.relationships = npc.relationships || {};
      other.relationships = other.relationships || {};
      npc.relationships[other.id] = relation;
      // The other side sees the same relationship
      other.relationships[npc.id] = relation;
    }
  }

  // Generate a random NPC object
  function generateNPC(){
    // Determine factions list; fall back to known IDs if FACTIONS undefined
    const fList = (Array.isArray(W.FACTIONS) && W.FACTIONS.length)
      ? W.FACTIONS.map(f => f.id)
      : ["settlers","rangers","scribes","dust_marauders","none"];
    const id      = nextId();
    const name    = `${rnd(FIRST_NAMES)} ${rnd(LAST_NAMES)}`;
    const role    = rnd(ROLES);
    const factionId = rnd(fList);
    const locId   = rnd(LOCATIONS);
    // Base relationship stats (0–100)
    const trust   = Math.floor(Math.random()*50) + 25;
    const respect = Math.floor(Math.random()*50);
    const affection = Math.floor(Math.random()*50);
    // Base values used for memory adjustments. Age indicates lifecycle stage.
    const baseTrust = trust;
    const baseRespect = respect;
    const baseAffection = affection;
    const age = Math.floor(Math.random() * 40) + 18; // 18–57
    // Choose personality traits
    const attitude = rnd(PERSONALITY_ATTITUDE);
    const morality = rnd(PERSONALITY_MORALITY);
    const pragmatism = rnd(PERSONALITY_PRAGMATISM);
    const personality = { attitude, morality, pragmatism };
    // Assign goals
    const shortGoal = randomShortTermGoal();
    const longGoal = randomLongTermGoal();
    const goals = { short: shortGoal, long: longGoal };
    // Mood/state variables: morale, health, wealth, stress (0–100)
    const morale = Math.floor(Math.random() * 40) + 30; // 30–69
    const health = Math.floor(Math.random() * 40) + 30;
    const wealth = Math.floor(Math.random() * 40) + 30;
    const stress = Math.floor(Math.random() * 40) + 30;
    return {
      id,
      name,
      role,
      factionId,
      locId,
      baseTrust,
      baseRespect,
      baseAffection,
      trust,
      respect,
      affection,
      memory: [],
      alive: true,
      age,
      childOf: null,
      // New dynamic fields
      personality,
      goals,
      morale,
      health,
      wealth,
      stress,
      relationships: {}
    };
  }

  // Spawn a new procedural NPC and push into LW.state.npcs
  function spawnNPC(){
    if (!LW.state.npcs) LW.state.npcs = [];
    const npc = generateNPC();
    // Push to state first so assignRelationships can reference existing NPCs
    LW.state.npcs.push(npc);
    // Assign relationships with a chance to create an ally or rival
    try {
      assignRelationships(npc, LW.state.npcs);
    } catch(_ignored){}
    // For debugging: log spawn to Life Log if available
    try {
      (W.log||console.log)(`A new face emerges: ${npc.name} (${npc.role})`);
    } catch(_){}
  }

  // Ensure all existing NPCs (including hard-coded faction NPCs) have dynamic attributes.
  function ensureNPCAttributes() {
    if (!Array.isArray(LW.state.npcs)) return;
    for (const npc of LW.state.npcs) {
      if (!npc.personality) {
        const attitude = rnd(PERSONALITY_ATTITUDE);
        const morality = rnd(PERSONALITY_MORALITY);
        const pragmatism = rnd(PERSONALITY_PRAGMATISM);
        npc.personality = { attitude, morality, pragmatism };
      }
      if (!npc.goals) {
        npc.goals = {
          short: randomShortTermGoal(),
          long: randomLongTermGoal()
        };
      }
      if (typeof npc.morale !== 'number') npc.morale = Math.floor(Math.random()*40)+30;
      if (typeof npc.health !== 'number') npc.health = Math.floor(Math.random()*40)+30;
      if (typeof npc.wealth !== 'number') npc.wealth = Math.floor(Math.random()*40)+30;
      if (typeof npc.stress !== 'number') npc.stress = Math.floor(Math.random()*40)+30;
      npc.relationships = npc.relationships || {};
      // Ensure base values for memory adjustments exist
      if (typeof npc.baseTrust !== 'number') npc.baseTrust = npc.trust || 50;
      if (typeof npc.baseRespect !== 'number') npc.baseRespect = npc.respect || 25;
      if (typeof npc.baseAffection !== 'number') npc.baseAffection = npc.affection || 25;

      // If current respect/affection undefined, seed with base or random
      if (typeof npc.respect !== 'number') npc.respect = npc.baseRespect;
      if (typeof npc.affection !== 'number') npc.affection = npc.baseAffection;
    }
    // After ensuring attributes, assign a couple relationships between randomly chosen NPCs
    // to foster rivalries/alliances in the world. Limit relationships to avoid over-linking.
    const aliveNpcs = LW.state.npcs.filter(n => n.alive !== false);
    for (const npc of aliveNpcs) {
      // Skip if already has at least one relationship
      if (npc.relationships && Object.keys(npc.relationships).length) continue;
      assignRelationships(npc, aliveNpcs);
    }
  }

  // Remove NPCs flagged as dead (alive === false)
  function removeDeadNPCs(){
    if (!LW.state.npcs) return;
    LW.state.npcs = LW.state.npcs.filter(n => n.alive !== false);
  }

  // Determine if we should spawn a new NPC this cycle
  function maybeSpawnNPC(){
    const aliveCount = (LW.state.npcs||[]).filter(n=>n.alive!==false).length;
    // If too few NPCs or random chance, spawn one
    if (aliveCount < 10 || Math.random() < 0.30) {
      spawnNPC();
    }
  }

  // Hook into Age Up button: on each year tick, clean up and spawn new NPCs
  function attachAgeHook(){
    const btn = document.getElementById("btn-age");
    if (!btn || btn.dataset.procNpcs) return;
    btn.dataset.procNpcs = "1";
    btn.addEventListener("click", () => {
      // Defer to end of event loop so other age-up handlers run first
      setTimeout(() => {
        removeDeadNPCs();
        maybeSpawnNPC();
        // Refresh UI
        if (W.updateUI) W.updateUI();
      }, 0);
    });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", attachAgeHook);
  } else {
    attachAgeHook();
  }

  // Initial spawn on first run/load
  if (!LW.state.__procNPCSeeded){
    LW.state.__procNPCSeeded = true;
    for (let i=0; i<5; i++){
      spawnNPC();
    }
  }

  // After initial spawns, backfill all NPCs (including hard-coded ones) with dynamic attributes
  ensureNPCAttributes();

  // Expose functions and data for interoperability with legacy/world systems.
  // This allows external scripts to spawn NPCs and reference the name/location pools.
  W.spawnNPC = spawnNPC;
  W.maybeSpawnNPC = maybeSpawnNPC;
  W.PROC_FIRST_NAMES = FIRST_NAMES;
  W.PROC_LOCATIONS = LOCATIONS;

})();</script>
<script>// npc_legacy.js
// NPC Memory, Legacy System, and World Simulation
// This script augments Wastelife with generational continuity and background world dynamics.
(function(){
  const W = window;
  const LW = W.LW || (W.LW = { state:{} });
  // Ensure global tracking structures exist
  LW.state.charCounter = LW.state.charCounter || 1;
  LW.state.lineage = LW.state.lineage || [];
  LW.state.worldTicks = LW.state.worldTicks || 0;
  LW.state.inheritance = LW.state.inheritance || null;

  // Local helpers (replicate sample)
  const sample = arr => arr[Math.floor(Math.random() * arr.length)];
  // Use clamp from main.js if available; fallback
  const clampFn = W.clamp || ((v,min,max)=>Math.max(min, Math.min(max, v)));

  /** Apply memory from a parent character to all living NPCs. */
  function applyNPCMemory(parentId){
    if (!parentId) return;
    const npcs = LW.state.npcs || [];
    for (const npc of npcs) {
      // reset trust/respect/affection to base if available
      if (typeof npc.baseTrust === "number") {
        npc.trust = npc.baseTrust;
        npc.respect = npc.baseRespect;
        npc.affection = npc.baseAffection;
      }
      // find entries for given parent
      const entries = (npc.memory || []).filter(m => m.charId === parentId);
      for (const entry of entries) {
        npc.trust = clampFn(npc.trust + (entry.trustDelta || 0), 0, 100);
        npc.respect = clampFn(npc.respect + (entry.respectDelta || 0), 0, 100);
        npc.affection = clampFn(npc.affection + (entry.affectionDelta || 0), 0, 100);
      }
    }
  }

  /** Record the relationship deltas between the current character and all NPCs. */
  function recordNPCMemoryOnDeath(charId){
    if (!charId) return;
    const npcs = LW.state.npcs || [];
    for (const npc of npcs) {
      if (typeof npc.baseTrust === "number") {
        const dT = (npc.trust || 0) - (npc.baseTrust || 0);
        const dR = (npc.respect || 0) - (npc.baseRespect || 0);
        const dA = (npc.affection || 0) - (npc.baseAffection || 0);
        if (dT || dR || dA) {
          npc.memory = npc.memory || [];
          npc.memory.push({
            charId: charId,
            trustDelta: dT,
            respectDelta: dR,
            affectionDelta: dA
          });
        }
      }
    }
  }

  /** Compute inheritance and start a new character after death. */
  function handleLegacyOnDeath(){
    // Push the deceased into lineage
    if (state.charId != null) {
      LW.state.lineage.push({
        charId: state.charId,
        name: state.name,
        age: state.age,
        faction: state.faction,
        factionRep: state.factionRep,
        caps: state.caps,
        inventory: Array.isArray(state.inventory) ? state.inventory.slice() : []
      });
    }
    // Determine inheritance share
    const capsInherit = Math.floor((state.caps || 0) * 0.5);
    const inv = Array.isArray(state.inventory) ? state.inventory.slice() : [];
    const itemCount = Math.min(3, Math.floor(inv.length * 0.3) || 0);
    const items = [];
    for (let i=0; i<itemCount; i++){
      const idx = Math.floor(Math.random() * inv.length);
      items.push(inv[idx]);
      inv.splice(idx,1);
    }
    const rep = Math.floor((state.factionRep || 0) * 0.5);
    LW.state.inheritance = { caps: capsInherit, items, factionRep: rep };
    // Record memory for NPCs
    recordNPCMemoryOnDeath(state.charId);
    // Start new generation after a brief pause
    setTimeout(() => {
      if (typeof W.log === "function") {
        W.log("Your descendant takes up your legacy...", "muted");
      }
      if (typeof W.newRun === "function") {
        W.newRun();
      }
    }, 500);
  }

  /** Spawn a child NPC inheriting some attributes from a parent NPC. */
  function spawnChildNPC(parent){
    if (!parent) return;
    // Use arrays from procedural NPCs if available; otherwise fallback to defaults
    const firstNames = W.PROC_FIRST_NAMES || [
      "Ash","Blaze","Cedar","Dune","Echo","Flint",
      "Gale","Hazel","Juno","Kestrel","Luna","Moss",
      "Nix","Oak","Pax","Quill","Roux","Sable",
      "Thorn","Umber","Vega","Willow","Xan","Yarrow","Zephyr"
    ];
    const locPool = W.PROC_LOCATIONS || [
      "dustown","ironwood","dunes","canyon",
      "ruins_zone","flats_zone","swamp"
    ];
    // Construct new NPC
    const lastName = (parent.name || "").split(" ").slice(-1)[0] || "Ridge";
    const newName = `${sample(firstNames)} ${lastName}`;
    const role = parent.role;
    const factionId = parent.factionId;
    const locId = sample(locPool);
    // Base relationship values randomised but similar to parent's base
    const baseT = clampFn((parent.baseTrust || 50) + Math.floor(Math.random()*20) - 10, 0, 100);
    const baseR = clampFn((parent.baseRespect || 50) + Math.floor(Math.random()*20) - 10, 0, 100);
    const baseA = clampFn((parent.baseAffection || 50) + Math.floor(Math.random()*20) - 10, 0, 100);
    const npc = {
      id: `proc_${(LW.state.npcs?.length || 0) + 1}_${Date.now()}`,
      name: newName,
      role,
      factionId,
      locId,
      baseTrust: baseT,
      baseRespect: baseR,
      baseAffection: baseA,
      trust: baseT,
      respect: baseR,
      affection: baseA,
      memory: [],
      alive: true,
      age: 18,
      childOf: parent.id
    };
    // Inherit dampened memory from parent
    if (Array.isArray(parent.memory)) {
      for (const entry of parent.memory) {
        npc.memory.push({
          charId: entry.charId,
          trustDelta: Math.round((entry.trustDelta || 0) * 0.5),
          respectDelta: Math.round((entry.respectDelta || 0) * 0.5),
          affectionDelta: Math.round((entry.affectionDelta || 0) * 0.5)
        });
      }
    }
    LW.state.npcs = LW.state.npcs || [];
    LW.state.npcs.push(npc);
    if (typeof W.log === "function") {
      W.log(`A new generation rises: ${npc.name} takes their parent's place.`, "muted");
    }
  }

  /** Remove NPCs flagged as dead from global state. */
  function removeDeadNPCsLocal(){
    if (!LW.state.npcs) return;
    LW.state.npcs = LW.state.npcs.filter(n => n.alive !== false);
  }

  /** Background world simulation executed every 5 time ticks. */
  function runWorldSimulation(){
    // First update NPC states (mood/goals) before other world events
    updateNPCStates();
    const npcs = LW.state.npcs || [];
    // Age and evaluate each NPC
    for (const npc of npcs) {
      // Increment age
      npc.age = (npc.age || Math.floor(Math.random()*30)+20) + 1;
      // Determine death due to old age
      if (npc.alive && npc.age > 70 && Math.random() < 0.2) {
        npc.alive = false;
        if (typeof W.log === "function") W.log(`${npc.name} passed away due to old age.`, "muted");
        // If raider-like, spawn child successor
        if (npc.role && /Raider|Lord|Chief/i.test(npc.role)) {
          spawnChildNPC(npc);
        }
      } else if (npc.alive && Math.random() < 0.05) {
        npc.alive = false;
        if (typeof W.log === "function") W.log(`${npc.name} met their fate in the wastes.`, "muted");
      }
    }
    removeDeadNPCsLocal();
    // Traders and wanderers relocate
    for (const npc of npcs) {
      if (!npc.alive) continue;
      const role = npc.role || "";
      if (/Trader|Caravan Guard|Farmer|Fence|Wanderer/i.test(role)) {
        const locPool = W.PROC_LOCATIONS || [
          "dustown","ironwood","dunes","canyon",
          "ruins_zone","flats_zone","swamp"
        ];
        npc.locId = sample(locPool);
        if (typeof W.log === "function") W.log(`${npc.name} relocated to another settlement.`, "muted");
      }
    }
    // Raiders may attack a random location
    const raiders = npcs.filter(n => n.alive && /Raider/i.test(n.role));
    if (raiders.length) {
      // Base attack chance
      let attackChance = 0.3;
      // Reduce chance based on player's settlement defenses
      const def = (state.settlement && state.settlement.defense) || 0;
      attackChance = Math.max(0.05, attackChance - (def * 0.005));
      if (Math.random() < attackChance) {
        const locPool = W.PROC_LOCATIONS || [
          "dustown","ironwood","dunes","canyon",
          "ruins_zone","flats_zone","swamp"
        ];
        const loc = sample(locPool);
        if (typeof W.log === "function") W.log(`Raiders launch an attack on ${loc}.`, "danger");
        // If the player's camp is attacked (assume 'camp' at player's location)
        if (state.location && Math.random() < 0.5) {
          // Loss of scrap or building damage
          if (state.settlement) {
            const loss = 5 + Math.floor(Math.random()*5);
            const scrapLost = Math.min(loss, state.settlement.scrap || 0);
            if (scrapLost > 0) {
              state.settlement.scrap -= scrapLost;
              if (typeof W.log === "function") W.log(`Raiders plunder your settlement for ${scrapLost} scrap!`, "danger");
            } else if (state.settlement.buildings && state.settlement.buildings.length) {
              // Destroy a random building
              const idx = Math.floor(Math.random() * state.settlement.buildings.length);
              const destroyed = state.settlement.buildings.splice(idx,1)[0];
              const buildingNames = { shack:"Shack", waterStill:"Water Still", workshop:"Workshop", watchTower:"Watch Tower" };
              const label = buildingNames[destroyed] || destroyed;
              if (typeof W.log === "function") W.log(`Raiders destroy your ${label}!`, "danger");
            }
          }
        }
      }
    }
    // Evolve factions slightly
    if (typeof W.updateFactions === "function") {
      W.updateFactions();
    }
    // Rare chance of faction collapse
    if (Array.isArray(W.FACTIONS) && LW.state.factions) {
      const f = sample(W.FACTIONS);
      const fid = f.id;
      const fs = LW.state.factions[fid];
      if (fs && fs.level <= 1 && Math.random() < 0.05) {
        fs.level = 0;
        if (typeof W.log === "function") W.log(`The ${f.name} faction has collapsed due to infighting.`, "danger");
      }
    }
    // Keep NPC population healthy
    if (typeof W.maybeSpawnNPC === "function") {
      W.maybeSpawnNPC();
    }
    // Refresh UI after world changes
    if (typeof W.updateUI === "function") W.updateUI();

    // Settlement workshop production: occasional free consumable
    try {
      if (state && state.hasWorkshop && Math.random() < 0.2) {
        // simple pool of items produced by workshop
        const pool = ["duct_tape", "med_patch", "junk"];
        const item = pool[Math.floor(Math.random()*pool.length)];
        if (typeof W.addItem === "function") {
          W.addItem(item, 1);
        } else {
          // fallback: push to inventory
          state.inventory = state.inventory || [];
          state.inventory.push(item);
        }
        if (typeof W.log === "function") W.log(`Your workshop produces a ${W.ITEMS?.[item]?.name || item}.`, "muted");
      }
    } catch(e) {
      console.error("Error in workshop production:", e);
    }
  }

  /** Increment global world tick and trigger simulation every 5 ticks. */
  function incrementWorldTick(){
    LW.state.worldTicks = (LW.state.worldTicks || 0) + 1;
    if (LW.state.worldTicks % 5 === 0) {
      runWorldSimulation();
    }
  }

  // Save original functions to wrap them with tick increment and legacy logic
  const origNewRun = W.newRun;
  W.newRun = function(){
    if (typeof origNewRun === "function") {
      origNewRun();
    }
    // Assign character ID and parent ID for generational tracking
    const cid = LW.state.charCounter || 1;
    state.charId = cid;
    LW.state.charCounter = cid + 1;
    state.parentCharId = LW.state.lineage.length ? LW.state.lineage[LW.state.lineage.length - 1].charId : null;
    // Apply pending inheritance to new character
    const inh = LW.state.inheritance;
    if (inh) {
      state.caps = (state.caps || 0) + (inh.caps || 0);
      if (Array.isArray(inh.items)) {
        for (const item of inh.items) {
          if (typeof W.addItem === "function") {
            W.addItem(item, 1);
          } else {
            state.inventory = state.inventory || [];
            state.inventory.push(item);
          }
        }
      }
      state.factionRep = Math.max(state.factionRep || 0, inh.factionRep || 0);
      LW.state.inheritance = null;
    }
    // Apply NPC memory adjustments
    applyNPCMemory(state.parentCharId);
    if (typeof W.updateUI === "function") W.updateUI();
  };

  const origDie = W.die;
  W.die = function(){
    if (typeof origDie === "function") origDie();
    // Immediately handle legacy on death
    handleLegacyOnDeath();
  };

  // Wrap major actions to include world ticks
  const origExplore = W.explore;
  if (origExplore) {
    W.explore = function(){
      const res = origExplore.apply(this, arguments);
      incrementWorldTick();
      return res;
    };
  }
  const origWork = W.work;
  if (origWork) {
    W.work = function(){
      const res = origWork.apply(this, arguments);
      incrementWorldTick();
      return res;
    };
  }
  const origTravelTo = W.travelTo;
  if (origTravelTo) {
    W.travelTo = function(){
      const res = origTravelTo.apply(this, arguments);
      incrementWorldTick();
      return res;
    };
  }
  // Wrap maybeStartCombat to increment world tick when a fight starts
  const origMaybeStartCombat = W.maybeStartCombat;
  if (origMaybeStartCombat) {
    W.maybeStartCombat = function(){
      const result = origMaybeStartCombat.apply(this, arguments);
      if (result) {
        incrementWorldTick();
      }
      return result;
    };
  }

  // Expose some functions globally for debugging or other modules
  W.applyNPCMemory = applyNPCMemory;
  W.recordNPCMemoryOnDeath = recordNPCMemoryOnDeath;
  W.handleLegacyOnDeath = handleLegacyOnDeath;
  W.runWorldSimulation = runWorldSimulation;
  W.incrementWorldTick = incrementWorldTick;
  W.spawnChildNPC = spawnChildNPC;

  /**
   * Update NPC mood/state and attempt to progress their goals.
   * This function simulates the daily lives of NPCs between player actions.
   * It is called at the beginning of each world simulation cycle.
   */
  function updateNPCStates() {
    const npcs = LW.state.npcs || [];
    for (const npc of npcs) {
      if (!npc.alive) continue;
      // Ensure mood properties exist
      npc.morale = typeof npc.morale === "number" ? npc.morale : 50;
      npc.health = typeof npc.health === "number" ? npc.health : 50;
      npc.wealth = typeof npc.wealth === "number" ? npc.wealth : 50;
      npc.stress = typeof npc.stress === "number" ? npc.stress : 50;
      npc.goals = npc.goals || {};
      npc.personality = npc.personality || { attitude: "cautious", morality: "honorable", pragmatism: "pragmatic" };
      // Slightly adjust mood values randomly to simulate daily variance
      npc.morale = clampFn(npc.morale + Math.floor(Math.random()*7) - 3, 0, 100);
      npc.wealth = clampFn(npc.wealth + Math.floor(Math.random()*5) - 2, 0, 100);
      npc.stress = clampFn(npc.stress + Math.floor(Math.random()*7) - 3, 0, 100);
      // Stress and low morale affect health
      if (npc.stress > 70) npc.health = clampFn(npc.health - Math.floor(Math.random()*3), 0, 100);
      if (npc.morale < 30) npc.health = clampFn(npc.health - Math.floor(Math.random()*2), 0, 100);
      // Attempt to fulfill short-term goal
      const sg = npc.goals.short;
      if (sg && sg.type) {
        // Determine base success chance
        let successChance = 0.6;
        const att = npc.personality.attitude || "cautious";
        const mor = npc.personality.morality || "honorable";
        const prag = npc.personality.pragmatism || "pragmatic";
        // Personality influence: reckless favours raid/recruit; cautious favours trade/patrol/explore
        if (att === "reckless" && (sg.type === "raid" || sg.type === "recruit")) successChance += 0.2;
        if (att === "cautious" && (sg.type === "trade" || sg.type === "patrol" || sg.type === "explore")) successChance += 0.2;
        // Morality: backstabbing more likely to succeed at raid; honorable more likely to succeed at trade/research
        if (mor === "backstabbing" && sg.type === "raid") successChance += 0.1;
        if (mor === "honorable" && (sg.type === "trade" || sg.type === "research")) successChance += 0.1;
        // Pragmatism: pragmatic favours trade/patrol; zealous favours research/raid
        if (prag === "pragmatic" && (sg.type === "trade" || sg.type === "patrol")) successChance += 0.1;
        if (prag === "zealous" && (sg.type === "research" || sg.type === "raid")) successChance += 0.1;
        // Mood influences: high morale increases success; high stress decreases
        successChance += (npc.morale - 50) / 200; // +0.25 at 100 morale, -0.25 at 0 morale
        successChance -= (npc.stress - 50) / 200;
        // Clamp success between 0.1 and 0.9
        successChance = Math.max(0.1, Math.min(0.9, successChance));
        const succeeded = Math.random() < successChance;
        // Compose a human-readable goal description for logging
        let actionDesc;
        switch (sg.type) {
          case "raid":
            actionDesc = `raid ${sg.target}`;
            break;
          case "trade":
            actionDesc = `trade with ${sg.target}`;
            break;
          case "research":
            actionDesc = `study ancient tech at ${sg.target}`;
            break;
          case "explore":
            actionDesc = `explore the area around ${sg.target}`;
            break;
          case "patrol":
            actionDesc = `patrol the wastes near ${sg.target}`;
            break;
          case "recruit":
            actionDesc = `recruit new members in ${sg.target}`;
            break;
          default:
            actionDesc = `${sg.type} at ${sg.target}`;
        }
        if (succeeded) {
          // Successful goal completion improves morale and wealth, reduces stress
          npc.morale = clampFn(npc.morale + 10, 0, 100);
          npc.wealth = clampFn(npc.wealth + Math.floor(Math.random()*10) + 5, 0, 100);
          npc.stress = clampFn(npc.stress - 5, 0, 100);
          // Move location if goal involves travel
          if (["raid","trade","explore","patrol","recruit","research"].includes(sg.type)) {
            npc.locId = sg.target;
          }
          // If raid success, other factions might be affected (log it)
          if (typeof W.log === "function") {
            W.log(`${npc.name} succeeded in their mission to ${actionDesc}.`, "muted");
          }
        } else {
          // Failure decreases morale and health, increases stress
          npc.morale = clampFn(npc.morale - 10, 0, 100);
          npc.health = clampFn(npc.health - Math.floor(Math.random()*8), 0, 100);
          npc.stress = clampFn(npc.stress + 7, 0, 100);
          npc.wealth = clampFn(npc.wealth - Math.floor(Math.random()*5), 0, 100);
          if (typeof W.log === "function") {
            W.log(`${npc.name}'s attempt to ${actionDesc} went poorly.`, "danger");
          }
        }
        // Assign a new short-term goal regardless of outcome
        const newTarget = (W.PROC_LOCATIONS && W.PROC_LOCATIONS.length) ? sample(W.PROC_LOCATIONS) : sg.target;
        npc.goals.short = randomShortTermGoal();
        // Sometimes progress long-term goal when successful
        if (succeeded && npc.goals.long && Math.random() < 0.1) {
          // After a few successes, the long-term goal might shift as they get closer to completion
          const types = ["unify","prosper","knowledge","power","legend"];
          const newLong = sample(types.filter(t => t !== npc.goals.long.type));
          npc.goals.long = { type: newLong, desc: npc.goals.long.desc };
        }
      }
      // Mortality: if health or morale drop to zero, NPC dies
      if (npc.health <= 0 || npc.morale <= 0) {
        npc.alive = false;
        if (typeof W.log === "function") {
          W.log(`${npc.name} has died due to ${npc.health <= 0 ? 'injuries' : 'despair'}.`, "danger");
        }
        // If they are raider-like, spawn a child successor
        if (npc.role && /Raider|Lord|Chief/i.test(npc.role)) {
          spawnChildNPC(npc);
        }
      }
    }
    // Clean up dead NPCs from relationships
    // remove dead IDs from other NPCs' relationships
    const aliveIds = new Set(npcs.filter(n => n.alive).map(n => n.id));
    for (const npc of npcs) {
      if (!npc.relationships) continue;
      for (const rid in npc.relationships) {
        if (!aliveIds.has(rid)) delete npc.relationships[rid];
      }
    }
  }

  // Local helper function to generate a random short-term goal (same as in procedural NPCs).
  function randomShortTermGoal() {
    const types = ["raid", "trade", "research", "explore", "patrol", "recruit"];
    const type = sample(types);
    const locPool = W.PROC_LOCATIONS || ["dustown","ironwood","dunes","canyon","ruins_zone","flats_zone","swamp"];
    const target = sample(locPool);
    return { type, target };
  }

})();</script>
<script>// faction_leaders.js
// Faction Leaders & NPC Integration
// This script assigns a leader to each faction, keeps the global NPC list
// in sync with the core game state, and augments the faction UI to show
// leader information. It should be loaded after main.js, faction_npcs.js
// and procedural_npcs.js so that FACTIONS, LW.state.npcs and state.factions
// have been initialized.

(function(){
  const W = window;
  const LW = W.LW || (W.LW = { state:{} });
  LW.state = LW.state || {};

  // Ensure the core state exists
  if (!W.state) {
    W.state = {};
  }

  // Helper: pick a leader role name appropriate for a faction. You can
  // customize these titles per faction as desired.
  const LEADER_TITLES = {
    settlers: "Union Leader",
    rangers: "Ranger Captain",
    scribes: "Head Scribe",
    dust_marauders: "Raid Lord",
    none: "Independent Leader"
  };

  /** Assign a leader to each faction if one does not already exist.
   * This function looks through LW.state.npcs for alive members of each
   * faction that have leadership-style roles. If none exist, it will
   * spawn a new procedural NPC, set their factionId and role to an
   * appropriate leader title, and register them as the faction leader.
   * The chosen leader's ID is stored on state.factions[fid].leaderId.
   */
  function assignFactionLeaders() {
    // Ensure state.factions exists (seeded by main.js or npc_legacy.js)
    if (!state.factions) return;
    const factions = state.factions;
    const allNPCs = LW.state.npcs || [];
    // Function to spawn a new NPC with a given faction and role.
    function createLeaderFor(fid) {
      // Use procedural NPC generator if available
      let npc;
      if (typeof W.spawnNPC === 'function') {
        W.spawnNPC();
        npc = allNPCs[allNPCs.length - 1];
      } else {
        // Fallback: create a minimal NPC
        const id = `leader_${fid}_${Date.now()}`;
        npc = {
          id: id,
          name: `${fid} Leader`,
          role: "Leader",
          factionId: fid,
          locId: "ironwood",
          trust: 50,
          baseTrust: 50,
          baseRespect: 50,
          baseAffection: 50,
          respect: 50,
          affection: 50,
          memory: [],
          alive: true,
          age: Math.floor(Math.random() * 20) + 25
        };
        allNPCs.push(npc);
      }
      // Set explicit faction and leader role
      npc.factionId = fid;
      npc.role = LEADER_TITLES[fid] || "Leader";
      return npc;
    }
    // Loop through each faction except "none"
    for (const fid of Object.keys(factions)) {
      if (fid === 'none') continue;
      const fs = factions[fid];
      // If a leader exists and is alive, continue
      if (fs.leaderId) {
        const existing = allNPCs.find(n => n.id === fs.leaderId && n.alive !== false);
        if (existing) {
          // Ensure their role is a leader title
          existing.role = existing.role || (LEADER_TITLES[fid] || "Leader");
          existing.factionId = fid;
          continue;
        }
      }
      // Find any alive NPC with matching faction and a role implying leadership
      const candidate = allNPCs.find(n => n.alive !== false && n.factionId === fid && /Leader|Chief|Captain|Lord|Warlord|Boss/i.test(String(n.role)));
      const leader = candidate || createLeaderFor(fid);
      // Record leader ID on faction state
      fs.leaderId = leader.id;
    }
  }

  /** Synchronize state.npcs with LW.state.npcs.
   * Many legacy UIs (like the Social panel) reference state.npcs; but
   * procedural and faction scripts store NPCs in LW.state.npcs. This
   * utility copies the array over so both lists reference the same NPCs.
   */
  function syncNPCLists() {
    if (!LW.state.npcs) {
      LW.state.npcs = [];
    }
    state.npcs = LW.state.npcs;
  }

  /** Augment the faction UI after it renders. Adds a Leader row that
   * displays the name and role of the faction's leader. If the leader
   * cannot be found, no row is inserted. This wrapper relies on the
   * existing DOM structure of openJoinFaction: the modal content
   * resides in an element with id 'modal-content'.
   */
  function injectLeaderIntoFactionModal(fid) {
    const fs = state.factions && state.factions[fid];
    if (!fs || !fs.leaderId) return;
    const npc = (LW.state.npcs || []).find(n => n.id === fs.leaderId);
    if (!npc) return;
    // Wait for the modal to exist in the DOM; then insert leader row
    setTimeout(() => {
      const modal = document.getElementById('modal-content');
      if (!modal) return;
      // Find the "Status" row to insert after
      const rows = modal.querySelectorAll('div.kv');
      let insertAfter = null;
      rows.forEach(r => {
        const first = r.firstElementChild;
        if (first && first.textContent && first.textContent.trim() === 'Status') {
          insertAfter = r;
        }
      });
      // Build leader row
      const leaderRow = document.createElement('div');
      leaderRow.className = 'kv';
      const label = document.createElement('div');
      label.textContent = 'Leader';
      const value = document.createElement('div');
      value.innerHTML = `<b>${npc.name}</b> (${npc.role || 'Leader'})`;
      leaderRow.appendChild(label);
      leaderRow.appendChild(value);
      // Insert after the Status row or at end of modal body
      if (insertAfter && insertAfter.parentNode) {
        insertAfter.parentNode.insertBefore(leaderRow, insertAfter.nextSibling);
      } else {
        modal.appendChild(leaderRow);
      }
    }, 0);
  }

  // Wrap openJoinFaction to ensure leaders are assigned, NPC lists synced,
  // and the leader line inserted whenever the faction menu is opened.
  const origOpenJoinFaction = W.openJoinFaction;
  W.openJoinFaction = function() {
    // Always sync NPC lists
    try { syncNPCLists(); } catch (e) {}
    // Before opening, assign leaders so the current faction has one
    try { assignFactionLeaders(); } catch (e) {}
    // Call the original function
    if (typeof origOpenJoinFaction === 'function') {
      origOpenJoinFaction.apply(this, arguments);
    }
    // If in a faction, insert leader info into the modal
    if (state && state.faction && state.faction !== 'none') {
      injectLeaderIntoFactionModal(state.faction);
    }
  };

  // Patch updateUI to always sync NPC lists and assign leaders. This
  // ensures the Social panel and other UIs display up-to-date NPCs and
  // leaders after any state change.
  const origUpdateUI = W.updateUI;
  W.updateUI = function() {
    if (typeof origUpdateUI === 'function') {
      origUpdateUI.apply(this, arguments);
    }
    try {
      syncNPCLists();
      assignFactionLeaders();
    } catch (e) {}
  };

  // On first load/new run, perform an initial sync and leader assignment
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      try { syncNPCLists(); assignFactionLeaders(); } catch (e) {}
    });
  } else {
    try { syncNPCLists(); assignFactionLeaders(); } catch (e) {}
  }
})();</script>
<script>// settlement.js
/* Settlement / Base Building Expansion
 * This module introduces a personal settlement system where players can collect scrap
 * and construct buildings that provide long‑term benefits. Players can manage
 * their base via the new "Your Settlement" button. Building consumes scrap
 * (represented by the existing 'Junk' item) and time (world ticks) but yields
 * lasting advantages like increased HP, better resource generation, or defense.
 */

(function(W){
  // Define available building blueprints. Each structure has a name, cost
  // (amount of scrap required), description, and an effect callback that
  // modifies the player's state when constructed. Effects run once on build.
  const BUILDINGS = {
    shack: {
      name: "Shack",
      cost: 10,
      desc: "A crude shelter. +5 maximum HP; +2 resident capacity.",
      capAdd: 2,
      effect: ()=>{
        state.hpMax += 5;
        state.hp = Math.min(state.hp, state.hpMax);
        W.log("You feel a bit safer under a roof. Max HP +5.");
      }
    },
    waterStill: {
      name: "Water Still",
      cost: 15,
      desc: "Purifies water. Reduces radiation intake during travel.",
      capAdd: 0,
      effect: ()=>{
        // Grant a small permanent rad shield: reduce incoming RAD by 1
        state.buffs.radShield = state.buffs.radShield || { turns: 0 };
        state.buffs.radShield.turns += 1000; // effectively permanent
        W.log("Fresh water flows at your camp. Radiation intake reduced.");
      }
    },
    workshop: {
      name: "Workshop",
      cost: 20,
      desc: "Allows simple crafting. Provides occasional free consumables and +1 resident capacity.",
      capAdd: 1,
      effect: ()=>{
        // Unlock occasional random item each year via world ticks
        state.hasWorkshop = true;
        W.log("Your workshop is ready. You can craft basic items and occasionally find supplies.");
      }
    },
    watchTower: {
      name: "Watch Tower",
      cost: 25,
      desc: "Improves camp defense. Reduces chance of raider attacks.",
      capAdd: 0,
      effect: ()=>{
        state.settlement.defense = (state.settlement.defense || 0) + 10;
        W.log("A watch tower stands over your settlement. Raiders will think twice.");
      }
    }
  };

  /** Initialize the settlement for a new run if it doesn't exist. */
  function initSettlement(){
    if (!state.settlement) {
      state.settlement = {
        scrap: 0,
        buildings: [],
        defense: 0,
        name: "Camp",
        residents: [],
        capacity: 2,
        // No allegiance by default (independent)
        allegiance: null
      };
    } else {
      // Backfill missing properties on older saves
      if (!('name' in state.settlement)) state.settlement.name = "Camp";
      if (!Array.isArray(state.settlement.residents)) state.settlement.residents = [];
      if (typeof state.settlement.capacity !== 'number') state.settlement.capacity = 2;
      if (typeof state.settlement.defense !== 'number') state.settlement.defense = state.settlement.defense || 0;
      if (!('allegiance' in state.settlement)) state.settlement.allegiance = null;
    }
  }

  /** Collect scrap from scavenge. Adds 1–3 scrap and increments world tick. */
  function collectScrap(){
    const amt = 1 + Math.floor(Math.random()*3);
    state.settlement.scrap += amt;
    W.log(`You scavenge the wasteland for materials. +${amt} scrap.`);
    // increment world tick for background simulation
    if (typeof W.incrementWorldTick === "function") W.incrementWorldTick();
    W.updateUI && W.updateUI();
    // Show the settlement panel again after collection
    openSettlement();
  }

  /** Build a structure if enough scrap is available. Applies the structure's effect. */
  function buildStructure(key){
    const b = BUILDINGS[key];
    if (!b) return;
    if (state.settlement.scrap < b.cost) {
      W.log("Not enough scrap to build " + b.name + ".", "danger");
      return;
    }
    // Spend scrap and add structure
    state.settlement.scrap -= b.cost;
    state.settlement.buildings.push(key);
    // Apply building effect
    if (typeof b.effect === "function") b.effect();
    // Increase resident capacity if building grants it
    if (typeof b.capAdd === "number" && b.capAdd > 0) {
      state.settlement.capacity = (state.settlement.capacity || 0) + b.capAdd;
    }
    // Increment world tick to reflect time spent building
    if (typeof W.incrementWorldTick === "function") W.incrementWorldTick();
    W.updateUI && W.updateUI();
    // Refresh the settlement UI
    openSettlement();
  }

  /** Generate the settlement modal UI. */
  function openSettlement(){
    initSettlement();
    const m = W.openModal(state.settlement.name || "Your Settlement");
    const c = m.content;
    // Name row with rename
    const nameRow = el("div","kv");
    nameRow.append(el("div", null, "Name"));
    const nameBox = el("div");
    nameBox.append(el("span", null, state.settlement.name || "Camp"));
    const renameBtn = el("button","choice small", "Rename");
    renameBtn.onclick = ()=>{
      const newName = prompt("Enter a name for your settlement:", state.settlement.name || "");
      if (newName && newName.trim().length) {
        state.settlement.name = newName.trim();
        openSettlement();
      }
    };
    nameBox.append(renameBtn);
    nameRow.append(nameBox);
    c.append(nameRow);
    // Scrap total
    const scrapRow = el("div","kv");
    scrapRow.append(el("div", null, "Scrap"));
    scrapRow.append(el("div", null, `${state.settlement.scrap}`));
    c.append(scrapRow);
    // Population and capacity
    const popRow = el("div","kv");
    popRow.append(el("div", null, "Population"));
    const pop = state.settlement.residents?.length || 0;
    const cap = state.settlement.capacity || 0;
    popRow.append(el("div", null, `${pop}/${cap}`));
    c.append(popRow);
    // Allegiance row
    const allyRow = el("div","kv");
    allyRow.append(el("div", null, "Allegiance"));
    const allyBox = el("div");
    // Determine display name for allegiance
    let allyName = "Neutral";
    if (state.settlement.allegiance) {
      const fid = state.settlement.allegiance;
      if (Array.isArray(W.FACTIONS)) {
        const fobj = W.FACTIONS.find(f => f.id === fid);
        allyName = fobj ? fobj.name : fid;
      } else {
        allyName = fid;
      }
    }
    allyBox.append(el("span", null, allyName));
    const changeBtn = el("button","choice small", "Change");
    changeBtn.onclick = () => {
      // Build a set of possible allegiances: residents' factions, all factions, plus none
      const choices = new Set();
      choices.add("none");
      (state.settlement.residents || []).forEach(rid=>{
        const npc = (LW.state && LW.state.npcs) ? LW.state.npcs.find(n => n.id === rid) : null;
        if (npc && npc.factionId) choices.add(npc.factionId);
      });
      if (Array.isArray(W.FACTIONS)) {
        W.FACTIONS.forEach(f => choices.add(f.id));
      }
      const list = Array.from(choices);
      const current = state.settlement.allegiance || "none";
      const input = prompt(`Choose allegiance (${list.join(', ')}). Current: ${current}`, current);
      if (!input) return;
      const choice = input.trim().toLowerCase();
      let newAlly = null;
      if (choice === "none" || choice === "neutral" || choice === "independent") {
        newAlly = null;
      } else {
        let fid = null;
        if (Array.isArray(W.FACTIONS)) {
          const matchById = W.FACTIONS.find(f => f.id.toLowerCase() === choice);
          if (matchById) fid = matchById.id;
          else {
            const matchByName = W.FACTIONS.find(f => f.name.toLowerCase() === choice);
            if (matchByName) fid = matchByName.id;
          }
        }
        fid = fid || choice;
        newAlly = fid;
      }
      const prevAlly = state.settlement.allegiance;
      state.settlement.allegiance = newAlly;
      // Adjust faction reputation when allegiance changes
      state.factionRep = state.factionRep || {};
      if (prevAlly !== newAlly) {
        if (newAlly) {
          state.factionRep[newAlly] = (state.factionRep[newAlly] || 0) + 5;
          if (Array.isArray(W.FACTIONS)) {
            W.FACTIONS.forEach(f => {
              if (f.id !== newAlly) state.factionRep[f.id] = (state.factionRep[f.id] || 0) - 2;
            });
          }
          if (typeof W.log === "function") {
            const allyDisplay = Array.isArray(W.FACTIONS) ? (W.FACTIONS.find(f => f.id === newAlly)?.name || newAlly) : newAlly;
            W.log(`Your settlement pledges allegiance to ${allyDisplay}.`, "muted");
          }
        } else {
          if (typeof W.log === "function") W.log("Your settlement is now independent.", "muted");
        }
      }
      openSettlement();
    };
    allyBox.append(changeBtn);
    allyRow.append(allyBox);
    c.append(allyRow);
    // Defense row
    const defRow = el("div","kv");
    defRow.append(el("div", null, "Defense"));
    defRow.append(el("div", null, `${state.settlement.defense || 0}`));
    c.append(defRow);
    // Built structures
    c.append(el("div","hr"));
    const builtTitle = el("div","title"); builtTitle.textContent = "Built Structures";
    c.append(builtTitle);
    if (!state.settlement.buildings.length){
      c.append(el("p","muted","(none yet)"));
    } else {
      state.settlement.buildings.forEach(key=>{
        const b = BUILDINGS[key];
        const row = el("div","kv");
        row.append(el("div", null, b.name));
        row.append(el("div","small muted", b.desc));
        c.append(row);
      });
    }
    // Residents list
    c.append(el("div","hr"));
    const resTitle = el("div","title"); resTitle.textContent = "Residents";
    c.append(resTitle);
    const resList = state.settlement.residents || [];
    if (!resList.length){
      c.append(el("p","muted","(no residents yet)"));
    } else {
      resList.forEach(rid=>{
        const npc = (LW.state && LW.state.npcs) ? LW.state.npcs.find(n => n.id === rid) : null;
        if (!npc) return;
        const row = el("div","kv");
        row.append(el("div", null, `${npc.name}`));
        const right = el("div");
        right.append(el("div","small muted", npc.role || "Resident"));
        const talkBtn = el("button","choice small", "Talk");
        talkBtn.onclick = ()=>{
          if (typeof LW.openNPC === "function") {
            LW.openNPC(npc.id);
          }
        };
        right.append(talkBtn);
        row.append(right);
        c.append(row);
      });
    }
    // Faction influence summary
    c.append(el("div","hr"));
    const facTitle = el("div","title"); facTitle.textContent = "Faction Influence";
    c.append(facTitle);
    const counts = {};
    (state.settlement.residents || []).forEach(rid=>{
      const npc = (LW.state && LW.state.npcs) ? LW.state.npcs.find(n => n.id === rid) : null;
      if (npc && npc.factionId) {
        counts[npc.factionId] = (counts[npc.factionId] || 0) + 1;
      }
    });
    if (Object.keys(counts).length === 0) {
      c.append(el("p","muted","(neutral)"));
    } else {
      Object.keys(counts).forEach(fid => {
        let fname = fid;
        if (Array.isArray(W.FACTIONS)){
          const fobj = W.FACTIONS.find(f => f.id === fid);
          if (fobj) fname = fobj.name;
        }
        const row = el("div","kv");
        row.append(el("div", null, fname));
        row.append(el("div", null, `${counts[fid]}`));
        c.append(row);
      });
    }
    // Available construction options
    c.append(el("div","hr"));
    const availTitle = el("div","title"); availTitle.textContent = "Available Constructions";
    c.append(availTitle);
    Object.keys(BUILDINGS).forEach(key=>{
      const builtCount = state.settlement.buildings.filter(b=>b===key).length;
      if (builtCount && key === "shack") return;
      const b = BUILDINGS[key];
      const row = el("div","kv");
      row.append(el("div", null, `${b.name} (Cost: ${b.cost} scrap)`));
      const right = el("div");
      right.append(el("div","small muted", b.desc));
      const btn = el("button","choice", "Build");
      btn.disabled = state.settlement.scrap < b.cost;
      btn.onclick = ()=>{ buildStructure(key); };
      right.append(btn);
      row.append(right);
      c.append(row);
    });
    // Actions: scrap collection
    c.append(el("div","hr"));
    const scrapRow2 = el("div","kv");
    scrapRow2.append(el("div", null, "Actions"));
    const actBox = el("div");
    const scavengeBtn = el("button","choice", "Scavenge for Scrap");
    scavengeBtn.onclick = collectScrap;
    actBox.append(scavengeBtn);
    scrapRow2.append(actBox);
    c.append(scrapRow2);
  }

  // Hook up the settlement button after DOM has loaded
  document.addEventListener("DOMContentLoaded", ()=>{
    const btn = document.getElementById("btn-settlement");
    if (btn) btn.onclick = openSettlement;
  });

  // Expose functions for other modules if needed
  W.initSettlement = initSettlement;
  W.openSettlement = openSettlement;

  // Attempt to spawn a new resident if capacity allows. Called after each world simulation.
  function maybeSpawnResident(){
    if (!state.settlement) return;
    const cap = state.settlement.capacity || 0;
    const pop = state.settlement.residents?.length || 0;
    if (pop >= cap) return;
    // Chance for new settler
    if (Math.random() < 0.3) {
      try {
        if (typeof W.spawnNPC === "function") {
          W.spawnNPC();
          const arr = (LW.state && LW.state.npcs) || [];
          const npc = arr[arr.length - 1];
          if (npc) {
            // If settlement has an allegiance, there is a higher chance new settlers belong to that faction
            if (state.settlement && state.settlement.allegiance && Math.random() < 0.8) {
              npc.factionId = state.settlement.allegiance;
            }
            npc.locId = state.locationId;
            npc.location = state.location;
            state.settlement.residents = state.settlement.residents || [];
            state.settlement.residents.push(npc.id);
            if (typeof W.log === "function") W.log(`A wanderer named ${npc.name} joins your settlement.`, "muted");
          }
        }
      } catch(e) { console.error("Error spawning resident", e); }
    }
  }

  /** Apply faction allegiance effects each time the world simulation runs.
   * Settlers grant extra scrap, Rangers bolster defense, Scribes improve rad protection,
   * and Dust Marauders provide lots of scrap but erode defenses. Neutral yields no effect.
   */
  function applyAllegianceEffects(){
    if (!state.settlement || !state.settlement.allegiance) return;
    const fid = state.settlement.allegiance;
    switch(fid){
      case 'settlers':
        state.settlement.scrap = (state.settlement.scrap || 0) + 2;
        if (typeof W.log === 'function') W.log("Settler allies send supplies (+2 scrap).", "muted");
        break;
      case 'rangers':
        state.settlement.defense = (state.settlement.defense || 0) + 2;
        if (typeof W.log === 'function') W.log("Rangers train your guards (+2 defense).", "muted");
        break;
      case 'scribes':
        state.buffs = state.buffs || {};
        state.buffs.radShield = state.buffs.radShield || { turns: 0 };
        state.buffs.radShield.turns += 5;
        if (typeof W.log === 'function') W.log("Scribes share knowledge of radiation shielding.", "muted");
        break;
      case 'dust_marauders':
        state.settlement.scrap = (state.settlement.scrap || 0) + 4;
        // Marauders often sabotage your defenses in their rowdy ways
        state.settlement.defense = Math.max(0, (state.settlement.defense || 0) - 1);
        if (typeof W.log === 'function') W.log("Dust Marauders send loot (+4 scrap) but roughhouse your defenses (-1).", "warning");
        break;
      default:
        // unknown allegiance: minor benefit
        state.settlement.scrap = (state.settlement.scrap || 0) + 1;
        break;
    }
  }

  // Wrap runWorldSimulation to include settlement growth
  document.addEventListener("DOMContentLoaded", ()=>{
    const origSim = W.runWorldSimulation;
    if (origSim) {
      W.runWorldSimulation = function(){
        const res = origSim.apply(this, arguments);
        maybeSpawnResident();
        // Apply allegiance effects after world simulation
        if (typeof applyAllegianceEffects === "function") applyAllegianceEffects();
        return res;
      };
    }
  });
})(window);</script>
</body>
</html>
